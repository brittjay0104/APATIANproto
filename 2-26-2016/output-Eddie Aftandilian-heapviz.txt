heapviz -- eaftan -- Eddie Aftandilian
https://github.com/eaftan/heapviz.git
git clone https://github.com/eaftan/heapviz.git
.\heapviz\
.\heapviz\.git
0
Project cloned!
Eddie Aftandilian is responsible for commit a4f43836b9c01a553696ef1a5c57b9d756d82b59
Eddie Aftandilian is responsible for commit 382f1fc8e2087322638070f57eaf8af033403cec
Eddie Aftandilian is responsible for commit abd1da0f323ab2e6194c921dfc64eae5d29f0931
Eddie Aftandilian is responsible for commit 9f3327621d15f1b5b1a9f95fe95934551de37a7b
Eddie Aftandilian is responsible for commit 2e78625b6a110724a76cc2341a374891760608bc
Eddie Aftandilian is responsible for commit ff7a2215571bd907e562742bbba501cac743c1e3
Eddie Aftandilian is responsible for commit b8c427004310bde332f761f734aac09cd34fc287
Eddie Aftandilian is responsible for commit 7bfdc433be27c83a27eb9e483e3989502388679c
Eddie Aftandilian is responsible for commit 37de2b3518b8459d9b7f47f9418547a4f194f641
Eddie Aftandilian is responsible for commit acc4d1cf43f0cc7b241715cfcf343a2fe6e10309
Eddie Aftandilian is responsible for commit 7f9dcd0ce2319412c614eb03484c97ddf89af3d5
Eddie Aftandilian is responsible for commit ae46e4caa81c9e6be639b36e26a3c9b038da851e
Eddie Aftandilian is responsible for commit ed4aaf11d2b07f882eb8a7e805612921472f74d7
Eddie Aftandilian is responsible for commit cc474ccd29035c94402a28af4f6e0d64e897b00a
Eddie Aftandilian is responsible for commit 7c42844a2b2b534a894889c5462ce3d67c4a91dd
Eddie Aftandilian is responsible for commit b70f3ce05ac413c5379a8156c3d0b8cb2981537c
Eddie Aftandilian is responsible for commit d177dd308568ccc8d821930b583e333f78daaf5a
Eddie Aftandilian is responsible for commit a4ba8338ba512806a6565ed351ca65e432dda3ad
Added Parse.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added InvalidVertexException.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
Added SummarizersTest.java to .\heapviz\ repository source files.

 ************ ANALYZING FOR USAGE PATTERN ADDITION ************


****Parsing for addition at revision a4f43836b9c01a553696ef1a5c57b9d756d82b59****

Added Parse.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added InvalidVertexException.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
Added SummarizersTest.java to .\heapviz\ repository source files.
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
Vertex target;
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance) obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value<?> value = objInstance.instanceFieldValues[i];
Value<?> value = objInstance.instanceFieldValues[i];
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,longValue.value)
Vertex to = findOrCreateVertex(objIdToVertex, longValue.value);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id),
        printDomEdges, printPtrEdges);
blackListStream=getClass().getResourceAsStream(blacklistFileName)
InputStream blackListStream = getClass().getResourceAsStream(blacklistFileName);
BufferedReader in = new BufferedReader(new InputStreamReader(blackListStream));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className,
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;

 Generics pattern public class InvalidVertexException was added at revision a4f43836b9c01a553696ef1a5c57b9d756d82b59

atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new AllocSiteSummarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new IdentitySummarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new Softvis2010Summarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new TypeGraphSummarizer());
hprofFileAbsolutePath=getAbsolutePathForResource(hprofFileRelativePath)
String hprofFileAbsolutePath = getAbsolutePathForResource(hprofFileRelativePath);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(hprofFileAbsolutePath);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));

Diff of a4f43836b9c01a553696ef1a5c57b9d756d82b59 and 382f1fc8e2087322638070f57eaf8af033403cec:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 1
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision a4f43836b9c01a553696ef1a5c57b9d756d82b59 to 382f1fc8e2087322638070f57eaf8af033403cec


****Parsing for addition at revision 382f1fc8e2087322638070f57eaf8af033403cec****

Added Parse.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
Added SummarizersTest.java to .\heapviz\ repository source files.
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance) obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value<?> value = objInstance.instanceFieldValues[i];
Value<?> value = objInstance.instanceFieldValues[i];
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,longValue.value)
Vertex to = findOrCreateVertex(objIdToVertex, longValue.value);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id),
        printDomEdges, printPtrEdges);
File blackList = new File(ClassLoader.getSystemResource(blacklistFileName).toURI());
BufferedReader in = new BufferedReader(new FileReader(blackList));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className,
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new AllocSiteSummarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new IdentitySummarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new Softvis2010Summarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new TypeGraphSummarizer());
hprofFileAbsolutePath=getAbsolutePathForResource(hprofFileRelativePath)
String hprofFileAbsolutePath = getAbsolutePathForResource(hprofFileRelativePath);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(hprofFileAbsolutePath);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));

Diff of 382f1fc8e2087322638070f57eaf8af033403cec and abd1da0f323ab2e6194c921dfc64eae5d29f0931:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 1
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 382f1fc8e2087322638070f57eaf8af033403cec to abd1da0f323ab2e6194c921dfc64eae5d29f0931


****Parsing for addition at revision abd1da0f323ab2e6194c921dfc64eae5d29f0931****

Added Parse.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
Added SummarizersTest.java to .\heapviz\ repository source files.
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance) obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value<?> value = objInstance.instanceFieldValues[i];
Value<?> value = objInstance.instanceFieldValues[i];
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,longValue.value)
Vertex to = findOrCreateVertex(objIdToVertex, longValue.value);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id),
        printDomEdges, printPtrEdges);
File blackList = new File(ClassLoader.getSystemResource(blacklistFileName).toURI());
BufferedReader in = new BufferedReader(new FileReader(blackList));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className,
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new AllocSiteSummarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new IdentitySummarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new Softvis2010Summarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new TypeGraphSummarizer());
hprofFileAbsolutePath=getAbsolutePathForResource(hprofFileRelativePath)
String hprofFileAbsolutePath = getAbsolutePathForResource(hprofFileRelativePath);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(hprofFileAbsolutePath);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));

Diff of abd1da0f323ab2e6194c921dfc64eae5d29f0931 and 9f3327621d15f1b5b1a9f95fe95934551de37a7b:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 1
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision abd1da0f323ab2e6194c921dfc64eae5d29f0931 to 9f3327621d15f1b5b1a9f95fe95934551de37a7b


****Parsing for addition at revision 9f3327621d15f1b5b1a9f95fe95934551de37a7b****

Added Parse.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
Added SummarizersTest.java to .\heapviz\ repository source files.
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance) obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value<?> value = objInstance.instanceFieldValues[i];
Value<?> value = objInstance.instanceFieldValues[i];
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,longValue.value)
Vertex to = findOrCreateVertex(objIdToVertex, longValue.value);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id),
        printDomEdges, printPtrEdges);
File blackList = new File(ClassLoader.getSystemResource(blacklistFileName).toURI());
BufferedReader in = new BufferedReader(new FileReader(blackList));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className,
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new AllocSiteSummarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new IdentitySummarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new Softvis2010Summarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new TypeGraphSummarizer());
hprofFileAbsolutePath=getAbsolutePathForResource(hprofFileRelativePath)
String hprofFileAbsolutePath = getAbsolutePathForResource(hprofFileRelativePath);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(hprofFileAbsolutePath);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));

Diff of 9f3327621d15f1b5b1a9f95fe95934551de37a7b and 2e78625b6a110724a76cc2341a374891760608bc:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 1
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 9f3327621d15f1b5b1a9f95fe95934551de37a7b to 2e78625b6a110724a76cc2341a374891760608bc


****Parsing for addition at revision 2e78625b6a110724a76cc2341a374891760608bc****

Added Parse.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
Added SummarizersTest.java to .\heapviz\ repository source files.
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance) obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value<?> value = objInstance.instanceFieldValues[i];
Value<?> value = objInstance.instanceFieldValues[i];
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,longValue.value)
Vertex to = findOrCreateVertex(objIdToVertex, longValue.value);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id),
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className,
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();
PrintStream throwawayPrintStream = new PrintStream(new OutputStream() {
      @Override
      public void write(int b) throws IOException {
        // do nothing
      }
    });
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new AllocSiteSummarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new IdentitySummarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new Softvis2010Summarizer());
RecordHandler summarizeHandler = new SummarizeHandler(
        true, false, true, new TypeGraphSummarizer());
hprofFileAbsolutePath=getAbsolutePathForResource(hprofFileRelativePath)
String hprofFileAbsolutePath = getAbsolutePathForResource(hprofFileRelativePath);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(hprofFileAbsolutePath);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));

Diff of 2e78625b6a110724a76cc2341a374891760608bc and ff7a2215571bd907e562742bbba501cac743c1e3:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 1
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 2e78625b6a110724a76cc2341a374891760608bc to ff7a2215571bd907e562742bbba501cac743c1e3


****Parsing for addition at revision ff7a2215571bd907e562742bbba501cac743c1e3****

Added Parse.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
Added AllExampleHandlersTest.java to .\heapviz\ repository source files.
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance) obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value<?> value = objInstance.instanceFieldValues[i];
Value<?> value = objInstance.instanceFieldValues[i];
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,longValue.value)
Vertex to = findOrCreateVertex(objIdToVertex, longValue.value);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id),
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className,
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();
PrintStream throwawayPrintStream = new PrintStream(new OutputStream() {
      @Override
      public void write(int b) throws IOException {
        // do nothing
      }
    });
Summarizer allocSiteSummarizer = new AllocSiteSummarizer();
RecordHandler summarizeHandler = new SummarizeHandler(true, false, true, allocSiteSummarizer);
hprofFileAbsolutePath=getAbsolutePathForResource(hprofFileRelativePath)
String hprofFileAbsolutePath = getAbsolutePathForResource(hprofFileRelativePath);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(hprofFileAbsolutePath);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));

Diff of ff7a2215571bd907e562742bbba501cac743c1e3 and b8c427004310bde332f761f734aac09cd34fc287:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 1
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision ff7a2215571bd907e562742bbba501cac743c1e3 to b8c427004310bde332f761f734aac09cd34fc287


****Parsing for addition at revision b8c427004310bde332f761f734aac09cd34fc287****

Added Parse.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance) obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value<?> value = objInstance.instanceFieldValues[i];
Value<?> value = objInstance.instanceFieldValues[i];
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,longValue.value)
Vertex to = findOrCreateVertex(objIdToVertex, longValue.value);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id),
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className,
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of b8c427004310bde332f761f734aac09cd34fc287 and 7bfdc433be27c83a27eb9e483e3989502388679c:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 6
	--> recency = years
	--> Added type declarations  = 1
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 2
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision b8c427004310bde332f761f734aac09cd34fc287 to 7bfdc433be27c83a27eb9e483e3989502388679c


****Parsing for addition at revision 7bfdc433be27c83a27eb9e483e3989502388679c****

Added Parse.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance) obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value<?> value = objInstance.instanceFieldValues[i];
Value<?> value = objInstance.instanceFieldValues[i];
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,longValue.value)
Vertex to = findOrCreateVertex(objIdToVertex, longValue.value);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id),
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className,
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of 7bfdc433be27c83a27eb9e483e3989502388679c and 37de2b3518b8459d9b7f47f9418547a4f194f641:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 6
	--> recency = years
	--> Added type declarations  = 1
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 2
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 7bfdc433be27c83a27eb9e483e3989502388679c to 37de2b3518b8459d9b7f47f9418547a4f194f641


****Parsing for addition at revision 37de2b3518b8459d9b7f47f9418547a4f194f641****

Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added Parse.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
@SuppressWarnings("unchecked")
          Value<Long> value = (Value<Long>) s.value;
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance) obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value<?> value = objInstance.instanceFieldValues[i];
Value<?> value = objInstance.instanceFieldValues[i];
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
@SuppressWarnings("unchecked")
                      Value<Long> longValue = (Value<Long>) value;
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,longValue.value)
Vertex to = findOrCreateVertex(objIdToVertex, longValue.value);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id),
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className,
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);

 Generics pattern Value<?> value = objInstance.instanceFieldValues[i]; was added at revision 37de2b3518b8459d9b7f47f9418547a4f194f641


 Generics pattern Value<?> was added at revision 37de2b3518b8459d9b7f47f9418547a4f194f641

int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of 37de2b3518b8459d9b7f47f9418547a4f194f641 and acc4d1cf43f0cc7b241715cfcf343a2fe6e10309:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 7
	--> recency = years
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 4
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 37de2b3518b8459d9b7f47f9418547a4f194f641 to acc4d1cf43f0cc7b241715cfcf343a2fe6e10309


****Parsing for addition at revision acc4d1cf43f0cc7b241715cfcf343a2fe6e10309****

Added PrintHandler.java to .\heapviz\ repository source files.
Added RecordHandler.java to .\heapviz\ repository source files.
Added StaticPrintHandler.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added Parse.java to .\heapviz\ repository source files.
Added AbstractValue.java to .\heapviz\ repository source files.
Added AllocSite.java to .\heapviz\ repository source files.
Added BoolValue.java to .\heapviz\ repository source files.
Added ByteValue.java to .\heapviz\ repository source files.
Added CharValue.java to .\heapviz\ repository source files.
Added ClassInfo.java to .\heapviz\ repository source files.
Added Constant.java to .\heapviz\ repository source files.
Added CPUSample.java to .\heapviz\ repository source files.
Added DoubleValue.java to .\heapviz\ repository source files.
Added FloatValue.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added InstanceField.java to .\heapviz\ repository source files.
Added IntValue.java to .\heapviz\ repository source files.
Added LongValue.java to .\heapviz\ repository source files.
Added ObjValue.java to .\heapviz\ repository source files.
Added OldValue.java to .\heapviz\ repository source files.
Added ShortValue.java to .\heapviz\ repository source files.
Added Static.java to .\heapviz\ repository source files.
Added Type.java to .\heapviz\ repository source files.
Added Value.java to .\heapviz\ repository source files.
Added HprofParser.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
int i = 0;
long nextClass = classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
SimpleDateFormat formatter = 
        new SimpleDateFormat("MM/dd/yyyy HH:mm:ss.SSS");
calendar=Calendar.getInstance()
Calendar calendar = Calendar.getInstance();
Class cls = new Class();
cls=classMap.get(classObjId)
Class cls = classMap.get(classObjId);
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value value = objInstance.instanceFieldValues[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,value.getValueObj())
Vertex to = findOrCreateVertex(objIdToVertex, value.getValueObj());
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id), 
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className, 
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
format=readUntilNull(in)
String format = readUntilNull(in);
idSize=in.readInt()
int idSize = in.readInt();
startTime=in.readLong()
long startTime = in.readLong();
int bytesRead = 0;
byte[] bytes = new byte[25];
byte[] newBytes = new byte[bytesRead + 20];
tag=in.readByte()
byte tag = in.readByte();
time=in.readInt()
int time = in.readInt();
bytesLeft=in.readInt()
int bytesLeft = in.readInt();
long l1, l2, l3, l4;
int i1, i2, i3, i4, i5, i6, i7, i8, i9;
short s1;
byte b1;
float f1;
byte[] bArr1;
long[] lArr1;
AllocSite[] allocSites = new AllocSite[i3];
CPUSample[] samples = new CPUSample[i2];
tag=in.readByte()
byte tag = in.readByte();
int bytesRead = 1;
long l1, l2, l3, l4, l5, l6, l7;
int i1, i2;
short s1, s2, s3;
byte b1;
byte[] bArr1;
long [] lArr1;
Constant[] constants = null;
constantPoolIndex=in.readShort()
short constantPoolIndex = in.readShort();
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
Static[] statics = null;
staticFieldNameStringId=readId(idSize,in)
long staticFieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
InstanceField[] instanceFields = null;
fieldNameStringId=readId(idSize,in)
long fieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value[] vs = null;
t=Type.hprofTypeToEnum(b1)
Type t = Type.hprofTypeToEnum(b1);
vb=readValue(in,idSize,t)
ValueBytesReadPair vb = readValue(in, idSize, t);
ByteArrayInputStream bs = new ByteArrayInputStream(i.packedValues);
DataInputStream input = new DataInputStream(bs);
ArrayList<Value> values = new ArrayList<Value>();
long nextClass = i.classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
Value v = null;
vb=readValue(input,idSize,field.type)
ValueBytesReadPair vb = readValue(input, idSize, field.type);
Value[] valuesArr = new Value[values.size()];
long id = -1;
Value v = null;
int bytesRead = 0;
vid=readId(idSize,in)
long vid = readId(idSize, in);
vbool=in.readBoolean()
boolean vbool = in.readBoolean();
vc=in.readChar()
char vc = in.readChar();
vf=in.readFloat()
float vf = in.readFloat();
vd=in.readDouble()
double vd = in.readDouble();
vbyte=in.readByte()
byte vbyte = in.readByte();
vs=in.readShort()
short vs = in.readShort();
vi=in.readInt()
int vi = in.readInt();
vl=in.readLong()
long vl = in.readLong();
int bytesRead = 0;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of acc4d1cf43f0cc7b241715cfcf343a2fe6e10309 and 7f9dcd0ce2319412c614eb03484c97ddf89af3d5:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 7
	--> recency = years
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 4
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision acc4d1cf43f0cc7b241715cfcf343a2fe6e10309 to 7f9dcd0ce2319412c614eb03484c97ddf89af3d5


****Parsing for addition at revision 7f9dcd0ce2319412c614eb03484c97ddf89af3d5****

Added PrintHandler.java to .\heapviz\ repository source files.
Added RecordHandler.java to .\heapviz\ repository source files.
Added StaticPrintHandler.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added Parse.java to .\heapviz\ repository source files.
Added AbstractValue.java to .\heapviz\ repository source files.
Added AllocSite.java to .\heapviz\ repository source files.
Added BoolValue.java to .\heapviz\ repository source files.
Added ByteValue.java to .\heapviz\ repository source files.
Added CharValue.java to .\heapviz\ repository source files.
Added ClassInfo.java to .\heapviz\ repository source files.
Added Constant.java to .\heapviz\ repository source files.
Added CPUSample.java to .\heapviz\ repository source files.
Added DoubleValue.java to .\heapviz\ repository source files.
Added FloatValue.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added InstanceField.java to .\heapviz\ repository source files.
Added IntValue.java to .\heapviz\ repository source files.
Added LongValue.java to .\heapviz\ repository source files.
Added ObjValue.java to .\heapviz\ repository source files.
Added OldValue.java to .\heapviz\ repository source files.
Added ShortValue.java to .\heapviz\ repository source files.
Added Static.java to .\heapviz\ repository source files.
Added Type.java to .\heapviz\ repository source files.
Added Value.java to .\heapviz\ repository source files.
Added HprofParser.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
int i = 0;
long nextClass = classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
SimpleDateFormat formatter = 
        new SimpleDateFormat("MM/dd/yyyy HH:mm:ss.SSS");
calendar=Calendar.getInstance()
Calendar calendar = Calendar.getInstance();
Class cls = new Class();
cls=classMap.get(classObjId)
Class cls = classMap.get(classObjId);
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value value = objInstance.instanceFieldValues[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,value.getValueObj())
Vertex to = findOrCreateVertex(objIdToVertex, value.getValueObj());
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id), 
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className, 
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
format=readUntilNull(in)
String format = readUntilNull(in);
idSize=in.readInt()
int idSize = in.readInt();
startTime=in.readLong()
long startTime = in.readLong();
int bytesRead = 0;
byte[] bytes = new byte[25];
byte[] newBytes = new byte[bytesRead + 20];
tag=in.readByte()
byte tag = in.readByte();
time=in.readInt()
int time = in.readInt();
bytesLeft=in.readInt()
int bytesLeft = in.readInt();
long l1, l2, l3, l4;
int i1, i2, i3, i4, i5, i6, i7, i8, i9;
short s1;
byte b1;
float f1;
byte[] bArr1;
long[] lArr1;
AllocSite[] allocSites = new AllocSite[i3];
CPUSample[] samples = new CPUSample[i2];
tag=in.readByte()
byte tag = in.readByte();
int bytesRead = 1;
long l1, l2, l3, l4, l5, l6, l7;
int i1, i2;
short s1, s2, s3;
byte b1;
byte[] bArr1;
long [] lArr1;
Constant[] constants = null;
constantPoolIndex=in.readShort()
short constantPoolIndex = in.readShort();
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
Static[] statics = null;
staticFieldNameStringId=readId(idSize,in)
long staticFieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
InstanceField[] instanceFields = null;
fieldNameStringId=readId(idSize,in)
long fieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value[] vs = null;
t=Type.hprofTypeToEnum(b1)
Type t = Type.hprofTypeToEnum(b1);
vb=readValue(in,idSize,t)
ValueBytesReadPair vb = readValue(in, idSize, t);
ByteArrayInputStream bs = new ByteArrayInputStream(i.packedValues);
DataInputStream input = new DataInputStream(bs);
ArrayList<Value> values = new ArrayList<Value>();
long nextClass = i.classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
Value v = null;
vb=readValue(input,idSize,field.type)
ValueBytesReadPair vb = readValue(input, idSize, field.type);
Value[] valuesArr = new Value[values.size()];
long id = -1;
Value v = null;
int bytesRead = 0;
vid=readId(idSize,in)
long vid = readId(idSize, in);
vbool=in.readBoolean()
boolean vbool = in.readBoolean();
vc=in.readChar()
char vc = in.readChar();
vf=in.readFloat()
float vf = in.readFloat();
vd=in.readDouble()
double vd = in.readDouble();
vbyte=in.readByte()
byte vbyte = in.readByte();
vs=in.readShort()
short vs = in.readShort();
vi=in.readInt()
int vi = in.readInt();
vl=in.readLong()
long vl = in.readLong();
int bytesRead = 0;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of 7f9dcd0ce2319412c614eb03484c97ddf89af3d5 and ae46e4caa81c9e6be639b36e26a3c9b038da851e:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 7
	--> recency = years
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 4
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 7f9dcd0ce2319412c614eb03484c97ddf89af3d5 to ae46e4caa81c9e6be639b36e26a3c9b038da851e


****Parsing for addition at revision ae46e4caa81c9e6be639b36e26a3c9b038da851e****

Added PrintHandler.java to .\heapviz\ repository source files.
Added RecordHandler.java to .\heapviz\ repository source files.
Added StaticPrintHandler.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added Parse.java to .\heapviz\ repository source files.
Added AbstractValue.java to .\heapviz\ repository source files.
Added AllocSite.java to .\heapviz\ repository source files.
Added BoolValue.java to .\heapviz\ repository source files.
Added ByteValue.java to .\heapviz\ repository source files.
Added CharValue.java to .\heapviz\ repository source files.
Added ClassInfo.java to .\heapviz\ repository source files.
Added Constant.java to .\heapviz\ repository source files.
Added CPUSample.java to .\heapviz\ repository source files.
Added DoubleValue.java to .\heapviz\ repository source files.
Added FloatValue.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added InstanceField.java to .\heapviz\ repository source files.
Added IntValue.java to .\heapviz\ repository source files.
Added LongValue.java to .\heapviz\ repository source files.
Added ObjValue.java to .\heapviz\ repository source files.
Added OldValue.java to .\heapviz\ repository source files.
Added ShortValue.java to .\heapviz\ repository source files.
Added Static.java to .\heapviz\ repository source files.
Added Type.java to .\heapviz\ repository source files.
Added Value.java to .\heapviz\ repository source files.
Added HprofParser.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
int i = 0;
long nextClass = classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
SimpleDateFormat formatter = 
        new SimpleDateFormat("MM/dd/yyyy HH:mm:ss.SSS");
calendar=Calendar.getInstance()
Calendar calendar = Calendar.getInstance();
Class cls = new Class();
cls=classMap.get(classObjId)
Class cls = classMap.get(classObjId);
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value value = objInstance.instanceFieldValues[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,value.getValueObj())
Vertex to = findOrCreateVertex(objIdToVertex, value.getValueObj());
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id), 
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className, 
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
format=readUntilNull(in)
String format = readUntilNull(in);
idSize=in.readInt()
int idSize = in.readInt();
startTime=in.readLong()
long startTime = in.readLong();
int bytesRead = 0;
byte[] bytes = new byte[25];
byte[] newBytes = new byte[bytesRead + 20];
tag=in.readByte()
byte tag = in.readByte();
time=in.readInt()
int time = in.readInt();
bytesLeft=in.readInt()
int bytesLeft = in.readInt();
long l1, l2, l3, l4;
int i1, i2, i3, i4, i5, i6, i7, i8, i9;
short s1;
byte b1;
float f1;
byte[] bArr1;
long[] lArr1;
AllocSite[] allocSites = new AllocSite[i3];
CPUSample[] samples = new CPUSample[i2];
tag=in.readByte()
byte tag = in.readByte();
int bytesRead = 1;
long l1, l2, l3, l4, l5, l6, l7;
int i1, i2;
short s1, s2, s3;
byte b1;
byte[] bArr1;
long [] lArr1;
Constant[] constants = null;
constantPoolIndex=in.readShort()
short constantPoolIndex = in.readShort();
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
Static[] statics = null;
staticFieldNameStringId=readId(idSize,in)
long staticFieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
InstanceField[] instanceFields = null;
fieldNameStringId=readId(idSize,in)
long fieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value[] vs = null;
t=Type.hprofTypeToEnum(b1)
Type t = Type.hprofTypeToEnum(b1);
vb=readValue(in,idSize,t)
ValueBytesReadPair vb = readValue(in, idSize, t);
ByteArrayInputStream bs = new ByteArrayInputStream(i.packedValues);
DataInputStream input = new DataInputStream(bs);
ArrayList<Value> values = new ArrayList<Value>();
long nextClass = i.classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
Value v = null;
vb=readValue(input,idSize,field.type)
ValueBytesReadPair vb = readValue(input, idSize, field.type);
Value[] valuesArr = new Value[values.size()];
long id = -1;
Value v = null;
int bytesRead = 0;
vid=readId(idSize,in)
long vid = readId(idSize, in);
vbool=in.readBoolean()
boolean vbool = in.readBoolean();
vc=in.readChar()
char vc = in.readChar();
vf=in.readFloat()
float vf = in.readFloat();
vd=in.readDouble()
double vd = in.readDouble();
vbyte=in.readByte()
byte vbyte = in.readByte();
vs=in.readShort()
short vs = in.readShort();
vi=in.readInt()
int vi = in.readInt();
vl=in.readLong()
long vl = in.readLong();
int bytesRead = 0;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of ae46e4caa81c9e6be639b36e26a3c9b038da851e and ed4aaf11d2b07f882eb8a7e805612921472f74d7:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 7
	--> recency = years
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 4
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision ae46e4caa81c9e6be639b36e26a3c9b038da851e to ed4aaf11d2b07f882eb8a7e805612921472f74d7


****Parsing for addition at revision ed4aaf11d2b07f882eb8a7e805612921472f74d7****

Added PrintHandler.java to .\heapviz\ repository source files.
Added RecordHandler.java to .\heapviz\ repository source files.
Added StaticPrintHandler.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added Parse.java to .\heapviz\ repository source files.
Added AbstractValue.java to .\heapviz\ repository source files.
Added AllocSite.java to .\heapviz\ repository source files.
Added BoolValue.java to .\heapviz\ repository source files.
Added ByteValue.java to .\heapviz\ repository source files.
Added CharValue.java to .\heapviz\ repository source files.
Added ClassInfo.java to .\heapviz\ repository source files.
Added Constant.java to .\heapviz\ repository source files.
Added CPUSample.java to .\heapviz\ repository source files.
Added DoubleValue.java to .\heapviz\ repository source files.
Added FloatValue.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added InstanceField.java to .\heapviz\ repository source files.
Added IntValue.java to .\heapviz\ repository source files.
Added LongValue.java to .\heapviz\ repository source files.
Added ObjValue.java to .\heapviz\ repository source files.
Added OldValue.java to .\heapviz\ repository source files.
Added ShortValue.java to .\heapviz\ repository source files.
Added Static.java to .\heapviz\ repository source files.
Added Type.java to .\heapviz\ repository source files.
Added Value.java to .\heapviz\ repository source files.
Added HprofParser.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
int i = 0;
long nextClass = classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
SimpleDateFormat formatter = 
        new SimpleDateFormat("MM/dd/yyyy HH:mm:ss.SSS");
calendar=Calendar.getInstance()
Calendar calendar = Calendar.getInstance();
Class cls = new Class();
cls=classMap.get(classObjId)
Class cls = classMap.get(classObjId);
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value value = objInstance.instanceFieldValues[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,value.getValueObj())
Vertex to = findOrCreateVertex(objIdToVertex, value.getValueObj());
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id), 
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className, 
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
format=readUntilNull(in)
String format = readUntilNull(in);
idSize=in.readInt()
int idSize = in.readInt();
startTime=in.readLong()
long startTime = in.readLong();
int bytesRead = 0;
byte[] bytes = new byte[25];
byte[] newBytes = new byte[bytesRead + 20];
tag=in.readByte()
byte tag = in.readByte();
time=in.readInt()
int time = in.readInt();
bytesLeft=in.readInt()
int bytesLeft = in.readInt();
long l1, l2, l3, l4;
int i1, i2, i3, i4, i5, i6, i7, i8, i9;
short s1;
byte b1;
float f1;
byte[] bArr1;
long[] lArr1;
AllocSite[] allocSites = new AllocSite[i3];
CPUSample[] samples = new CPUSample[i2];
tag=in.readByte()
byte tag = in.readByte();
int bytesRead = 1;
long l1, l2, l3, l4, l5, l6, l7;
int i1, i2;
short s1, s2, s3;
byte b1;
byte[] bArr1;
long [] lArr1;
Constant[] constants = null;
constantPoolIndex=in.readShort()
short constantPoolIndex = in.readShort();
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
Static[] statics = null;
staticFieldNameStringId=readId(idSize,in)
long staticFieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
InstanceField[] instanceFields = null;
fieldNameStringId=readId(idSize,in)
long fieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value[] vs = null;
t=Type.hprofTypeToEnum(b1)
Type t = Type.hprofTypeToEnum(b1);
vb=readValue(in,idSize,t)
ValueBytesReadPair vb = readValue(in, idSize, t);
ByteArrayInputStream bs = new ByteArrayInputStream(i.packedValues);
DataInputStream input = new DataInputStream(bs);
ArrayList<Value> values = new ArrayList<Value>();
long nextClass = i.classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
Value v = null;
vb=readValue(input,idSize,field.type)
ValueBytesReadPair vb = readValue(input, idSize, field.type);
Value[] valuesArr = new Value[values.size()];
long id = -1;
Value v = null;
int bytesRead = 0;
vid=readId(idSize,in)
long vid = readId(idSize, in);
vbool=in.readBoolean()
boolean vbool = in.readBoolean();
vc=in.readChar()
char vc = in.readChar();
vf=in.readFloat()
float vf = in.readFloat();
vd=in.readDouble()
double vd = in.readDouble();
vbyte=in.readByte()
byte vbyte = in.readByte();
vs=in.readShort()
short vs = in.readShort();
vi=in.readInt()
int vi = in.readInt();
vl=in.readLong()
long vl = in.readLong();
int bytesRead = 0;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of ed4aaf11d2b07f882eb8a7e805612921472f74d7 and cc474ccd29035c94402a28af4f6e0d64e897b00a:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 7
	--> recency = years
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 4
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision ed4aaf11d2b07f882eb8a7e805612921472f74d7 to cc474ccd29035c94402a28af4f6e0d64e897b00a


****Parsing for addition at revision cc474ccd29035c94402a28af4f6e0d64e897b00a****

Added PrintHandler.java to .\heapviz\ repository source files.
Added RecordHandler.java to .\heapviz\ repository source files.
Added StaticPrintHandler.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added Parse.java to .\heapviz\ repository source files.
Added AbstractValue.java to .\heapviz\ repository source files.
Added AllocSite.java to .\heapviz\ repository source files.
Added BoolValue.java to .\heapviz\ repository source files.
Added ByteValue.java to .\heapviz\ repository source files.
Added CharValue.java to .\heapviz\ repository source files.
Added ClassInfo.java to .\heapviz\ repository source files.
Added Constant.java to .\heapviz\ repository source files.
Added CPUSample.java to .\heapviz\ repository source files.
Added DoubleValue.java to .\heapviz\ repository source files.
Added FloatValue.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added InstanceField.java to .\heapviz\ repository source files.
Added IntValue.java to .\heapviz\ repository source files.
Added LongValue.java to .\heapviz\ repository source files.
Added ObjValue.java to .\heapviz\ repository source files.
Added OldValue.java to .\heapviz\ repository source files.
Added ShortValue.java to .\heapviz\ repository source files.
Added Static.java to .\heapviz\ repository source files.
Added Type.java to .\heapviz\ repository source files.
Added Value.java to .\heapviz\ repository source files.
Added HprofParser.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
int i = 0;
long nextClass = classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
SimpleDateFormat formatter = 
        new SimpleDateFormat("MM/dd/yyyy HH:mm:ss.SSS");
calendar=Calendar.getInstance()
Calendar calendar = Calendar.getInstance();
Class cls = new Class();
cls=classMap.get(classObjId)
Class cls = classMap.get(classObjId);
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value value = objInstance.instanceFieldValues[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,value.getValueObj())
Vertex to = findOrCreateVertex(objIdToVertex, value.getValueObj());
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id), 
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className, 
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
format=readUntilNull(in)
String format = readUntilNull(in);
idSize=in.readInt()
int idSize = in.readInt();
startTime=in.readLong()
long startTime = in.readLong();
int bytesRead = 0;
byte[] bytes = new byte[25];
byte[] newBytes = new byte[bytesRead + 20];
tag=in.readByte()
byte tag = in.readByte();
time=in.readInt()
int time = in.readInt();
bytesLeft=in.readInt()
int bytesLeft = in.readInt();
long l1, l2, l3, l4;
int i1, i2, i3, i4, i5, i6, i7, i8, i9;
short s1;
byte b1;
float f1;
byte[] bArr1;
long[] lArr1;
AllocSite[] allocSites = new AllocSite[i3];
CPUSample[] samples = new CPUSample[i2];
tag=in.readByte()
byte tag = in.readByte();
int bytesRead = 1;
long l1, l2, l3, l4, l5, l6, l7;
int i1, i2;
short s1, s2, s3;
byte b1;
byte[] bArr1;
long [] lArr1;
Constant[] constants = null;
constantPoolIndex=in.readShort()
short constantPoolIndex = in.readShort();
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
Static[] statics = null;
staticFieldNameStringId=readId(idSize,in)
long staticFieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
InstanceField[] instanceFields = null;
fieldNameStringId=readId(idSize,in)
long fieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value[] vs = null;
t=Type.hprofTypeToEnum(b1)
Type t = Type.hprofTypeToEnum(b1);
vb=readValue(in,idSize,t)
ValueBytesReadPair vb = readValue(in, idSize, t);
ByteArrayInputStream bs = new ByteArrayInputStream(i.packedValues);
DataInputStream input = new DataInputStream(bs);
ArrayList<Value> values = new ArrayList<Value>();
long nextClass = i.classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
Value v = null;
vb=readValue(input,idSize,field.type)
ValueBytesReadPair vb = readValue(input, idSize, field.type);
Value[] valuesArr = new Value[values.size()];
long id = -1;
Value v = null;
int bytesRead = 0;
vid=readId(idSize,in)
long vid = readId(idSize, in);
vbool=in.readBoolean()
boolean vbool = in.readBoolean();
vc=in.readChar()
char vc = in.readChar();
vf=in.readFloat()
float vf = in.readFloat();
vd=in.readDouble()
double vd = in.readDouble();
vbyte=in.readByte()
byte vbyte = in.readByte();
vs=in.readShort()
short vs = in.readShort();
vi=in.readInt()
int vi = in.readInt();
vl=in.readLong()
long vl = in.readLong();
int bytesRead = 0;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of cc474ccd29035c94402a28af4f6e0d64e897b00a and 7c42844a2b2b534a894889c5462ce3d67c4a91dd:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 7
	--> recency = years
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 4
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision cc474ccd29035c94402a28af4f6e0d64e897b00a to 7c42844a2b2b534a894889c5462ce3d67c4a91dd


****Parsing for addition at revision 7c42844a2b2b534a894889c5462ce3d67c4a91dd****

Added PrintHandler.java to .\heapviz\ repository source files.
Added RecordHandler.java to .\heapviz\ repository source files.
Added StaticPrintHandler.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added Parse.java to .\heapviz\ repository source files.
Added AbstractValue.java to .\heapviz\ repository source files.
Added AllocSite.java to .\heapviz\ repository source files.
Added BoolValue.java to .\heapviz\ repository source files.
Added ByteValue.java to .\heapviz\ repository source files.
Added CharValue.java to .\heapviz\ repository source files.
Added ClassInfo.java to .\heapviz\ repository source files.
Added Constant.java to .\heapviz\ repository source files.
Added CPUSample.java to .\heapviz\ repository source files.
Added DoubleValue.java to .\heapviz\ repository source files.
Added FloatValue.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added InstanceField.java to .\heapviz\ repository source files.
Added IntValue.java to .\heapviz\ repository source files.
Added LongValue.java to .\heapviz\ repository source files.
Added ObjValue.java to .\heapviz\ repository source files.
Added OldValue.java to .\heapviz\ repository source files.
Added ShortValue.java to .\heapviz\ repository source files.
Added Static.java to .\heapviz\ repository source files.
Added Type.java to .\heapviz\ repository source files.
Added Value.java to .\heapviz\ repository source files.
Added HprofParser.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
int i = 0;
long nextClass = classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
SimpleDateFormat formatter = 
        new SimpleDateFormat("MM/dd/yyyy HH:mm:ss.SSS");
calendar=Calendar.getInstance()
Calendar calendar = Calendar.getInstance();
Class cls = new Class();
cls=classMap.get(classObjId)
Class cls = classMap.get(classObjId);
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value value = objInstance.instanceFieldValues[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,value.getValueObj())
Vertex to = findOrCreateVertex(objIdToVertex, value.getValueObj());
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id), 
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className, 
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
format=readUntilNull(in)
String format = readUntilNull(in);
idSize=in.readInt()
int idSize = in.readInt();
startTime=in.readLong()
long startTime = in.readLong();
int bytesRead = 0;
byte[] bytes = new byte[25];
byte[] newBytes = new byte[bytesRead + 20];
tag=in.readByte()
byte tag = in.readByte();
time=in.readInt()
int time = in.readInt();
bytesLeft=in.readInt()
int bytesLeft = in.readInt();
long l1, l2, l3, l4;
int i1, i2, i3, i4, i5, i6, i7, i8, i9;
short s1;
byte b1;
float f1;
byte[] bArr1;
long[] lArr1;
AllocSite[] allocSites = new AllocSite[i3];
CPUSample[] samples = new CPUSample[i2];
tag=in.readByte()
byte tag = in.readByte();
int bytesRead = 1;
long l1, l2, l3, l4, l5, l6, l7;
int i1, i2;
short s1, s2, s3;
byte b1;
byte[] bArr1;
long [] lArr1;
Constant[] constants = null;
constantPoolIndex=in.readShort()
short constantPoolIndex = in.readShort();
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
Static[] statics = null;
staticFieldNameStringId=readId(idSize,in)
long staticFieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
InstanceField[] instanceFields = null;
fieldNameStringId=readId(idSize,in)
long fieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value[] vs = null;
t=Type.hprofTypeToEnum(b1)
Type t = Type.hprofTypeToEnum(b1);
vb=readValue(in,idSize,t)
ValueBytesReadPair vb = readValue(in, idSize, t);
ByteArrayInputStream bs = new ByteArrayInputStream(i.packedValues);
DataInputStream input = new DataInputStream(bs);
ArrayList<Value> values = new ArrayList<Value>();
long nextClass = i.classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
Value v = null;
vb=readValue(input,idSize,field.type)
ValueBytesReadPair vb = readValue(input, idSize, field.type);
Value[] valuesArr = new Value[values.size()];
long id = -1;
Value v = null;
int bytesRead = 0;
vid=readId(idSize,in)
long vid = readId(idSize, in);
vbool=in.readBoolean()
boolean vbool = in.readBoolean();
vc=in.readChar()
char vc = in.readChar();
vf=in.readFloat()
float vf = in.readFloat();
vd=in.readDouble()
double vd = in.readDouble();
vbyte=in.readByte()
byte vbyte = in.readByte();
vs=in.readShort()
short vs = in.readShort();
vi=in.readInt()
int vi = in.readInt();
vl=in.readLong()
long vl = in.readLong();
int bytesRead = 0;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of 7c42844a2b2b534a894889c5462ce3d67c4a91dd and b70f3ce05ac413c5379a8156c3d0b8cb2981537c:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 7
	--> recency = years
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 4
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 7c42844a2b2b534a894889c5462ce3d67c4a91dd to b70f3ce05ac413c5379a8156c3d0b8cb2981537c


****Parsing for addition at revision b70f3ce05ac413c5379a8156c3d0b8cb2981537c****

Added PrintHandler.java to .\heapviz\ repository source files.
Added RecordHandler.java to .\heapviz\ repository source files.
Added StaticPrintHandler.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added Parse.java to .\heapviz\ repository source files.
Added AbstractValue.java to .\heapviz\ repository source files.
Added AllocSite.java to .\heapviz\ repository source files.
Added BoolValue.java to .\heapviz\ repository source files.
Added ByteValue.java to .\heapviz\ repository source files.
Added CharValue.java to .\heapviz\ repository source files.
Added ClassInfo.java to .\heapviz\ repository source files.
Added Constant.java to .\heapviz\ repository source files.
Added CPUSample.java to .\heapviz\ repository source files.
Added DoubleValue.java to .\heapviz\ repository source files.
Added FloatValue.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added InstanceField.java to .\heapviz\ repository source files.
Added IntValue.java to .\heapviz\ repository source files.
Added LongValue.java to .\heapviz\ repository source files.
Added ObjValue.java to .\heapviz\ repository source files.
Added OldValue.java to .\heapviz\ repository source files.
Added ShortValue.java to .\heapviz\ repository source files.
Added Static.java to .\heapviz\ repository source files.
Added Type.java to .\heapviz\ repository source files.
Added Value.java to .\heapviz\ repository source files.
Added HprofParser.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
int i = 0;
long nextClass = classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
SimpleDateFormat formatter = 
        new SimpleDateFormat("MM/dd/yyyy HH:mm:ss.SSS");
calendar=Calendar.getInstance()
Calendar calendar = Calendar.getInstance();
Class cls = new Class();
cls=classMap.get(classObjId)
Class cls = classMap.get(classObjId);
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value value = objInstance.instanceFieldValues[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,value.getValueObj())
Vertex to = findOrCreateVertex(objIdToVertex, value.getValueObj());
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id), 
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className, 
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
format=readUntilNull(in)
String format = readUntilNull(in);
idSize=in.readInt()
int idSize = in.readInt();
startTime=in.readLong()
long startTime = in.readLong();
int bytesRead = 0;
byte[] bytes = new byte[25];
byte[] newBytes = new byte[bytesRead + 20];
tag=in.readByte()
byte tag = in.readByte();
time=in.readInt()
int time = in.readInt();
bytesLeft=in.readInt()
int bytesLeft = in.readInt();
long l1, l2, l3, l4;
int i1, i2, i3, i4, i5, i6, i7, i8, i9;
short s1;
byte b1;
float f1;
byte[] bArr1;
long[] lArr1;
AllocSite[] allocSites = new AllocSite[i3];
CPUSample[] samples = new CPUSample[i2];
tag=in.readByte()
byte tag = in.readByte();
int bytesRead = 1;
long l1, l2, l3, l4, l5, l6, l7;
int i1, i2;
short s1, s2, s3;
byte b1;
byte[] bArr1;
long [] lArr1;
Constant[] constants = null;
constantPoolIndex=in.readShort()
short constantPoolIndex = in.readShort();
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
Static[] statics = null;
staticFieldNameStringId=readId(idSize,in)
long staticFieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
InstanceField[] instanceFields = null;
fieldNameStringId=readId(idSize,in)
long fieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value[] vs = null;
t=Type.hprofTypeToEnum(b1)
Type t = Type.hprofTypeToEnum(b1);
vb=readValue(in,idSize,t)
ValueBytesReadPair vb = readValue(in, idSize, t);
ByteArrayInputStream bs = new ByteArrayInputStream(i.packedValues);
DataInputStream input = new DataInputStream(bs);
ArrayList<Value> values = new ArrayList<Value>();
long nextClass = i.classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
Value v = null;
vb=readValue(input,idSize,field.type)
ValueBytesReadPair vb = readValue(input, idSize, field.type);
Value[] valuesArr = new Value[values.size()];
long id = -1;
Value v = null;
int bytesRead = 0;
vid=readId(idSize,in)
long vid = readId(idSize, in);
vbool=in.readBoolean()
boolean vbool = in.readBoolean();
vc=in.readChar()
char vc = in.readChar();
vf=in.readFloat()
float vf = in.readFloat();
vd=in.readDouble()
double vd = in.readDouble();
vbyte=in.readByte()
byte vbyte = in.readByte();
vs=in.readShort()
short vs = in.readShort();
vi=in.readInt()
int vi = in.readInt();
vl=in.readLong()
long vl = in.readLong();
int bytesRead = 0;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of b70f3ce05ac413c5379a8156c3d0b8cb2981537c and d177dd308568ccc8d821930b583e333f78daaf5a:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 7
	--> recency = years
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 4
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision b70f3ce05ac413c5379a8156c3d0b8cb2981537c to d177dd308568ccc8d821930b583e333f78daaf5a


****Parsing for addition at revision d177dd308568ccc8d821930b583e333f78daaf5a****

Added PrintHandler.java to .\heapviz\ repository source files.
Added RecordHandler.java to .\heapviz\ repository source files.
Added StaticPrintHandler.java to .\heapviz\ repository source files.
Added Analysis.java to .\heapviz\ repository source files.
Added Class.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added ObjectArray.java to .\heapviz\ repository source files.
Added ObjectInstance.java to .\heapviz\ repository source files.
Added PrimArray.java to .\heapviz\ repository source files.
Added Render.java to .\heapviz\ repository source files.
Added Root.java to .\heapviz\ repository source files.
Added RootJavaFrame.java to .\heapviz\ repository source files.
Added RootStatic.java to .\heapviz\ repository source files.
Added StackFrame.java to .\heapviz\ repository source files.
Added StackTrace.java to .\heapviz\ repository source files.
Added SummarizeHandler2.java to .\heapviz\ repository source files.
Added Vertex.java to .\heapviz\ repository source files.
Added Parse.java to .\heapviz\ repository source files.
Added AbstractValue.java to .\heapviz\ repository source files.
Added AllocSite.java to .\heapviz\ repository source files.
Added BoolValue.java to .\heapviz\ repository source files.
Added ByteValue.java to .\heapviz\ repository source files.
Added CharValue.java to .\heapviz\ repository source files.
Added ClassInfo.java to .\heapviz\ repository source files.
Added Constant.java to .\heapviz\ repository source files.
Added CPUSample.java to .\heapviz\ repository source files.
Added DoubleValue.java to .\heapviz\ repository source files.
Added FloatValue.java to .\heapviz\ repository source files.
Added Instance.java to .\heapviz\ repository source files.
Added InstanceField.java to .\heapviz\ repository source files.
Added IntValue.java to .\heapviz\ repository source files.
Added LongValue.java to .\heapviz\ repository source files.
Added ObjValue.java to .\heapviz\ repository source files.
Added OldValue.java to .\heapviz\ repository source files.
Added ShortValue.java to .\heapviz\ repository source files.
Added Static.java to .\heapviz\ repository source files.
Added Type.java to .\heapviz\ repository source files.
Added Value.java to .\heapviz\ repository source files.
Added HprofParser.java to .\heapviz\ repository source files.
Added AllocSiteSummarizer.java to .\heapviz\ repository source files.
Added DominatorSetSummarizer.java to .\heapviz\ repository source files.
Added GEdge.java to .\heapviz\ repository source files.
Added GGraph.java to .\heapviz\ repository source files.
Added GNode.java to .\heapviz\ repository source files.
Added InternalConnRelation.java to .\heapviz\ repository source files.
Added RCCRefName.java to .\heapviz\ repository source files.
Added RCCType.java to .\heapviz\ repository source files.
Added RefTarget.java to .\heapviz\ repository source files.
Added SimpleDom.java to .\heapviz\ repository source files.
Added IdentitySummarizer.java to .\heapviz\ repository source files.
Added SimpleXMLAttribute.java to .\heapviz\ repository source files.
Added SimpleXMLNode.java to .\heapviz\ repository source files.
Added SimpleXMLParser.java to .\heapviz\ repository source files.
Added Softvis2010Summarizer.java to .\heapviz\ repository source files.
Added Summarizer.java to .\heapviz\ repository source files.
Added TypeGraphSummarizer.java to .\heapviz\ repository source files.
Added Utils.java to .\heapviz\ repository source files.
Added DuplicateEdgeException.java to .\heapviz\ repository source files.
Added Edge.java to .\heapviz\ repository source files.
Added Graph.java to .\heapviz\ repository source files.
Added TestGraph.java to .\heapviz\ repository source files.
Added XMLSanitizer.java to .\heapviz\ repository source files.
int i = 0;
long nextClass = classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
SimpleDateFormat formatter = 
        new SimpleDateFormat("MM/dd/yyyy HH:mm:ss.SSS");
calendar=Calendar.getInstance()
Calendar calendar = Calendar.getInstance();
Class cls = new Class();
cls=classMap.get(classObjId)
Class cls = classMap.get(classObjId);
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
boolean changed = true;
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
fsep=System.getProperty("file.separator")
String fsep = System.getProperty("file.separator");
File dispDirFile = new File(dispDir);
File visgml = new File(dispGml.replace("$", extraLabel));
BufferedWriter out = new BufferedWriter(new FileWriter(visgml.getCanonicalPath()));
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
edges=g.getEdges()
Set<Edge<Vertex, String>> edges = g.getEdges();
Set<Edge<Vertex, String>> edges = g.getEdges();
StringBuilder sb = new StringBuilder();
frame=stackFrameMap.get(stackFrameId)
StackFrame frame = stackFrameMap.get(stackFrameId);
cls=classSerialNumMap.get(frame.classSerialNum)
Class cls = classSerialNumMap.get(frame.classSerialNum);
Class cls = new Class();
StackFrame frame = new StackFrame();
StackTrace stack = new StackTrace();
RootJavaFrame newRoot = new RootJavaFrame();
cls=classIdMap.get(classObjId)
Class cls = classIdMap.get(classObjId);
RootStatic newRoot = new RootStatic();
ObjectInstance newInstance = new ObjectInstance();
ObjectArray newArray = new ObjectArray();
PrimArray newArray = new PrimArray();
Graph<Vertex, String> g = new Graph<Vertex, String>(instanceMap.size(), 10);
HashMap<Long, Vertex> objIdToVertex = new HashMap<Long, Vertex>(instanceMap.size());
Stack<Long> worklist = new Stack<Long>();
HashSet<Long> visited = new HashSet<Long>(instanceMap.size());
Vertex root = new Vertex(0, "Fake root", 0, null);
target=findOrCreateVertex(objIdToVertex,r.targetId)
Vertex target = findOrCreateVertex(objIdToVertex, r.targetId);
String label = null;
RootJavaFrame rjf = (RootJavaFrame)r;
RootStatic rs = (RootStatic)r;
objId=worklist.pop()
long objId = worklist.pop();
obj=instanceMap.get(objId)
Instance obj = instanceMap.get(objId);
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
Value value = objInstance.instanceFieldValues[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,value.getValueObj())
Vertex to = findOrCreateVertex(objIdToVertex, value.getValueObj());
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long ref = arrayInstance.elems[i];
from=findOrCreateVertex(objIdToVertex,objId)
Vertex from = findOrCreateVertex(objIdToVertex, objId);
to=findOrCreateVertex(objIdToVertex,ref)
Vertex to = findOrCreateVertex(objIdToVertex, ref);
id=heapImages.size()
int id = heapImages.size();
gmlpath=Render.graphToGraphML(g,Integer.toString(id),printDomEdges,printPtrEdges)
String gmlpath = Render.graphToGraphML(g, Integer.toString(id), 
        printDomEdges, printPtrEdges);
BufferedReader in = new BufferedReader(new FileReader(fn));
String line;
parts=line.split(",")
String[] parts = line.split(",");
bannedFields=staticsBlacklist.get(parts[1].trim())
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
HashSet<String> bannedFields = staticsBlacklist.get(parts[1].trim());
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
ObjectArray arrayInstance = (ObjectArray)obj;
String arrayType = classIdMap.get(arrayInstance.elemClassObjId).className;
long size = 0;
ObjectInstance objInstance  = (ObjectInstance)obj;
cls=classIdMap.get(objInstance.classObjId)
Class cls = classIdMap.get(objInstance.classObjId);
Vertex v = new Vertex(objInstance.objId, cls.className, cls.instanceSize, allocContext);
int i = 0;
long nextClass = objInstance.classObjId;
ci=classIdMap.get(nextClass)
Class ci = classIdMap.get(nextClass);
fieldName=stringMap.get(field.fieldNameStringId)
String fieldName = stringMap.get(field.fieldNameStringId);
value=objInstance.instanceFieldValues[i].toString()
String value = objInstance.instanceFieldValues[i].toString();
PrimArray arrayInstance = (PrimArray)obj;
String arrayType = arrayInstance.elemType.toString() + "[]";
long size = 0;
Vertex v = new Vertex(arrayInstance.objId, arrayType, size, allocContext);
long size = 0;
stack=stackTraceMap.get(obj.stackTraceSerialNum)
StackTrace stack = stackTraceMap.get(obj.stackTraceSerialNum);
allocContext=stack.toString(stackFrameMap,classSerialNumMap)
String allocContext = stack.toString(stackFrameMap, classSerialNumMap);
Vertex v = new Vertex(obj.classObjId, "java.lang.Class - " + obj.className, 
        size, allocContext);
target=objIdToVertex.get(objId)
Vertex target = objIdToVertex.get(objId);
i=instanceMap.get(objId)
Instance i = instanceMap.get(objId);
c=classIdMap.get(objId)
Class c = classIdMap.get(objId);
instance=instanceMap.get(r.targetId)
Instance instance = instanceMap.get(r.targetId);
Class cls = null;
RootStatic rs = (RootStatic)r;
fieldNames=staticsBlacklist.get(classIdMap.get(rs.classObjId).className)
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
HashSet<String> fieldNames = staticsBlacklist.get(classIdMap.get(rs.classObjId).className);
int totalIds = 0;
long[] ids = new long[totalIds];
ArrayList<String> types = new ArrayList<String>();
String repType = null;
String allocContext = null;
long totalSize = 0;
int idIndex = 0;
boolean first = true;
StringBuilder sb = new StringBuilder();
boolean first = true;
value=fields.get(fieldName)
String value = fields.get(fieldName);
length=value.length()
int length = value.length();
final int PRIME = 31;
int result = 1;
final Vertex other = (Vertex) obj;
long id;
String inputfile;
boolean doSummary = true, printDomEdges = true, printPtrEdges = true;
int i;
Summarizer summarizer = null;
argmap=parseCommandLineArgs(args)
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
Map<String,String> argmap = parseCommandLineArgs(args);
RecordHandler handler = new SummarizeHandler2(doSummary, printDomEdges, printPtrEdges, summarizer);
HprofParser parser = new HprofParser(handler);
FileInputStream fs = new FileInputStream(inputfile);
DataInputStream in = new DataInputStream(new BufferedInputStream(fs));
HashMap<String,String> argMap = new HashMap<String,String>();
format=readUntilNull(in)
String format = readUntilNull(in);
idSize=in.readInt()
int idSize = in.readInt();
startTime=in.readLong()
long startTime = in.readLong();
int bytesRead = 0;
byte[] bytes = new byte[25];
byte[] newBytes = new byte[bytesRead + 20];
tag=in.readByte()
byte tag = in.readByte();
time=in.readInt()
int time = in.readInt();
bytesLeft=in.readInt()
int bytesLeft = in.readInt();
long l1, l2, l3, l4;
int i1, i2, i3, i4, i5, i6, i7, i8, i9;
short s1;
byte b1;
float f1;
byte[] bArr1;
long[] lArr1;
AllocSite[] allocSites = new AllocSite[i3];
CPUSample[] samples = new CPUSample[i2];
tag=in.readByte()
byte tag = in.readByte();
int bytesRead = 1;
long l1, l2, l3, l4, l5, l6, l7;
int i1, i2;
short s1, s2, s3;
byte b1;
byte[] bArr1;
long [] lArr1;
Constant[] constants = null;
constantPoolIndex=in.readShort()
short constantPoolIndex = in.readShort();
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
Static[] statics = null;
staticFieldNameStringId=readId(idSize,in)
long staticFieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value v = null;
vb=readValue(in,idSize,type)
ValueBytesReadPair vb = readValue(in, idSize, type);
InstanceField[] instanceFields = null;
fieldNameStringId=readId(idSize,in)
long fieldNameStringId = readId(idSize, in);
btype=in.readByte()
byte btype = in.readByte();
type=Type.hprofTypeToEnum(btype)
Type type = Type.hprofTypeToEnum(btype);
Value[] vs = null;
t=Type.hprofTypeToEnum(b1)
Type t = Type.hprofTypeToEnum(b1);
vb=readValue(in,idSize,t)
ValueBytesReadPair vb = readValue(in, idSize, t);
ByteArrayInputStream bs = new ByteArrayInputStream(i.packedValues);
DataInputStream input = new DataInputStream(bs);
ArrayList<Value> values = new ArrayList<Value>();
long nextClass = i.classObjId;
ci=classMap.get(nextClass)
ClassInfo ci = classMap.get(nextClass);
Value v = null;
vb=readValue(input,idSize,field.type)
ValueBytesReadPair vb = readValue(input, idSize, field.type);
Value[] valuesArr = new Value[values.size()];
long id = -1;
Value v = null;
int bytesRead = 0;
vid=readId(idSize,in)
long vid = readId(idSize, in);
vbool=in.readBoolean()
boolean vbool = in.readBoolean();
vc=in.readChar()
char vc = in.readChar();
vf=in.readFloat()
float vf = in.readFloat();
vd=in.readDouble()
double vd = in.readDouble();
vbyte=in.readByte()
byte vbyte = in.readByte();
vs=in.readShort()
short vs = in.readShort();
vi=in.readInt()
int vi = in.readInt();
vl=in.readLong()
long vl = in.readLong();
int bytesRead = 0;
HashMap<String, ArrayList<Vertex>> allocSiteMap =
        new HashMap<String, ArrayList<Vertex>>();
nodes=allocSiteMap.get(v.allocContext)
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
ArrayList<Vertex> nodes = allocSiteMap.get(v.allocContext);
vs=allocSiteMap.get(s)
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Vertex> vs = allocSiteMap.get(s);
ArrayList<Map<Vertex,Vertex>> dominatorSets;
ArrayList<Map<Vertex,Vertex>> dominatorSets;
Softvis2010Summarizer s = new Softvis2010Summarizer();
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
HashMap<Set<Vertex>,Set<Vertex>> m;
StringBuilder sb = new StringBuilder("(");
StringBuilder sb = new StringBuilder();
Vector<GNode> topov = new Vector<GNode>();
Vector<GNode> nscc = new Vector<GNode>();
TopoComparator c = new TopoComparator();
HashSet<GEdge> ebtn1n2 = new HashSet<GEdge>();
HashSet<GEdge> ebtn2n1 = new HashSet<GEdge>();
HashSet<GEdge> allebt = new HashSet<GEdge>();
aredj=eRemain.getEnd().areEdgesDisjoint(eRemain,eRemove)
boolean aredj = eRemain.getEnd().areEdgesDisjoint(eRemain, eRemove);
e1=toNorm.get(i)
GEdge e1 = toNorm.get(i);
e2=toNorm.get(j)
GEdge e2 = toNorm.get(j);
Vector<GEdge> tee = new Vector<GEdge>(rt.getTargets());
HashMap<RCCRefName, Vector<GEdge>> mergeMap = new HashMap<RCCRefName, Vector<GEdge>>();
f=oe.getEdgeRef()
RCCRefName f = oe.getEdgeRef();
pp=topop.iterator()
Iterator<GNode> pp = topop.iterator();
Iterator<GNode> pp = topop.iterator();
nn=pp.next()
GNode nn = pp.next();
boolean chtt;
np=oe.getEnd()
GNode np = oe.getEnd();
boolean recReachTrue = (! Collections.disjoint(n.getNodeTypes(), np.getRecReachTypeSet()));
boolean recAdjTrue = (! Collections.disjoint(n.getNodeTypes(), np.getNodeTypes()));
Vector<GNode> pTopoSort = new Vector<GNode>();
boolean changed;
LinkedList<GNode> ntp = new LinkedList<GNode>(pTopoSort);
nodev=ntp.getLast()
GNode nodev = ntp.getLast();
startn=ine.getStart()
GNode startn = ine.getStart();
Vector<Vector<GNode>> sccs = new Vector<Vector<GNode>>();
trr=scc.firstElement()
GNode trr = scc.firstElement();
onn=scc.get(i)
GNode onn = scc.get(i);
HashSet<GEdge> ebt = new HashSet<GEdge>();
int thisDeadCT = this.nodes.size() + this.edges.size();
int lastDeadCT;
Vector<GNode> pTopoSort = new Vector<GNode>();
ort=g2.getRefTargetSameAsOther(rt)
RefTarget ort = g2.getRefTargetSameAsOther(rt);
StringBuilder ds = new StringBuilder();
StringBuilder edgeStr = new StringBuilder();
StringBuilder nodeStr = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nStr=ni.stringifyIntoGViz(nullityStrMap)
String nStr = ni.stringifyIntoGViz(nullityStrMap);
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder();
HashSet<GNode> toPrint = new HashSet<GNode>();
LinkedList<GNode> pending = new LinkedList<GNode>();
HashMap<RCCRefName, String> nullityStrMap = new HashMap<RCCRefName, String>();
ni=pending.getFirst()
GNode ni = pending.getFirst();
nn=ee.getEnd()
GNode nn = ee.getEnd();
conns=nn.stringifyConnInfoInto(ee.getEdgeID())
String conns = nn.stringifyConnInfoInto(ee.getEdgeID());
StringBuilder sb = new StringBuilder("(");
boolean first;
HashSet<RCCRefName> inves1 = new HashSet<RCCRefName>();
HashSet<RCCRefName> inves2 = new HashSet<RCCRefName>();
StringBuilder sb = new StringBuilder();
boolean first;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
StringBuilder sb = new StringBuilder();
boolean first = true;
vv=this.nullityInfo.get(fd).intValue()
int vv = this.nullityInfo.get(fd).intValue();
String dv = (vv == SimpleDom.mustNonNull) ? "solid" : "dotted";
mbss=SimpleDom.mayBeSameSource(this.sourceID,nd.sourceID)
boolean mbss = SimpleDom.mayBeSameSource(this.sourceID, nd.sourceID);
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
nrebtiei=nd.inEdges.listIterator()
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
ListIterator<GEdge> nrebtiei = nd.inEdges.listIterator();
nebtoei=nd.outEdges.listIterator()
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
ListIterator<GEdge> nebtoei = nd.outEdges.listIterator();
rebtiei=this.inEdges.listIterator()
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
ListIterator<GEdge> rebtiei = this.inEdges.listIterator();
rebtoei=this.outEdges.listIterator()
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
ListIterator<GEdge> rebtoei = this.outEdges.listIterator();
allptrDisjoint=nd.ici.areAllEdgesDisjointInSet(ebt)
boolean allptrDisjoint = nd.ici.areAllEdgesDisjointInSet(ebt);
int ebtSum = 0;
HashSet<RCCRefName> ebtOffsets = new HashSet<RCCRefName>();
ndnf=nd.nullityInfo.get(fd).intValue()
int ndnf = nd.nullityInfo.get(fd).intValue();
tnif=this.nullityInfo.get(fd).intValue()
int tnif = this.nullityInfo.get(fd).intValue();
iei=nd.inEdges.listIterator()
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ListIterator<GEdge> iei = nd.inEdges.listIterator();
ee=iei.next()
GEdge ee = iei.next();
oei=nd.outEdges.listIterator()
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ListIterator<GEdge> oei = nd.outEdges.listIterator();
ee=oei.next()
GEdge ee = oei.next();
boolean change = (! this.recReachSet.containsAll(oNode.recReachSet)) || (! this.recReachSet.containsAll(oNode.types));
StringBuilder sb = new StringBuilder("{??}");
StringBuilder sb = new StringBuilder();
tt=this.disj.get(te)
TreeSet<Integer> tt =  this.disj.get(te);
TreeSet<Integer> tt =  this.disj.get(te);
boolean first = true;
tts=this.disj.get(ee1.getEdgeID())
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
TreeSet<Integer> tts = this.disj.get(ee1.getEdgeID());
ots=this.disj.get(ee2.getEdgeID())
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
TreeSet<Integer> ots = this.disj.get(ee2.getEdgeID());
ebti=ebt.iterator()
Iterator<GEdge> ebti = ebt.iterator();
Iterator<GEdge> ebti = ebt.iterator();
eidi=ebti.next().getEdgeID()
int eidi = ebti.next().getEdgeID();
ebtj=ebt.iterator()
Iterator<GEdge> ebtj = ebt.iterator();
Iterator<GEdge> ebtj = ebt.iterator();
eidj=ebtj.next().getEdgeID()
int eidj = ebtj.next().getEdgeID();
StringBuilder sb = new StringBuilder();
String vname;
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
StringBuilder sb = new StringBuilder();
nn=te.getEnd()
GNode nn = te.getEnd();
conns=nn.stringifyConnInfoInto(te.getEdgeID())
String conns = nn.stringifyConnInfoInto(te.getEdgeID());
String nullStr = (this.mayNull) ? "dotted" : "solid";
ebtOff=ebtOffsets.iterator().next()
RCCRefName ebtOff = ebtOffsets.iterator().next();
boolean upperListOk = (sa == SimpleDom.singleton_S) | (internalOffsetsA.size() == 1 && internalOffsetsA.iterator().next() == ebtOff);
boolean lowerListOk = (sb == SimpleDom.singleton_S) | (internalOffsetsB.size() == 1 && internalOffsetsB.iterator().next() == ebtOff);
boolean listOk = (ebtSum == 1) & upperListOk & lowerListOk;
int sr;
atri=this.attrl.iterator()
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
Iterator<SimpleXMLAttribute> atri = this.attrl.iterator();
nnli=this.nnl.iterator()
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
Iterator<SimpleXMLNode> nnli = this.nnl.iterator();
StringBuilder sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
int i = 0;
SimpleXMLNode rn = null;
LinkedList<SimpleXMLNode> ps = new LinkedList<SimpleXMLNode>();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
nn=this.readOpenTag()
SimpleXMLNode nn = this.readOpenTag();
nn=ps.getLast()
SimpleXMLNode nn = ps.getLast();
int window = 10;
ploc=Math.max(0,this.pos - window)
int ploc = Math.max(0, this.pos - window);
int psize = this.pos - ploc;
asize=Math.min(window,this.s.length() - this.pos)
int asize = Math.min(window, this.s.length() - this.pos);
eqloc=this.s.indexOf('=',this.pos)
int eqloc = this.s.indexOf('=', this.pos);
endloc=this.s.indexOf('\"',eqloc + 2)
int endloc = this.s.indexOf('\"', eqloc + 2);
atrn=this.s.substring(this.pos,eqloc)
String atrn = this.s.substring(this.pos, eqloc);
atv=this.s.substring(eqloc + 2,endloc)
String atv = this.s.substring(eqloc + 2, endloc);
a=this.s.indexOf(' ',this.pos)
int a = this.s.indexOf(' ', this.pos);
b=this.s.indexOf('>',this.pos)
int b = this.s.indexOf('>', this.pos);
c=Math.min(a,b)
int c = Math.min(a, b);
ename=this.s.substring(this.pos,c)
String ename = this.s.substring(this.pos, c);
Vector<SimpleXMLAttribute> attrl = new Vector<SimpleXMLAttribute>();
cl=this.s.indexOf('>',this.pos)
int cl = this.s.indexOf('>', this.pos);
cet=this.s.substring(this.pos + 2,cl)
String cet = this.s.substring(this.pos + 2, cl);
cl=this.s.indexOf('<',this.pos)
int cl = this.s.indexOf('<', this.pos);
cds=SimpleXMLNode.deXMLifyString(this.s.substring(this.pos,cl))
String cds = SimpleXMLNode.deXMLifyString(this.s.substring(this.pos, cl));
g=inputG.deepishCopy()
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
Graph<Vertex,String> g = inputG.deepishCopy();
boolean changed = true;
boolean anychange = false;
boolean changed = true;
vertices=g.getVertices()
Set<Vertex> vertices = g.getVertices();
Set<Vertex> vertices = g.getVertices();
outEdges=g.getOutgoingEdges(v)
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
List<Edge<Vertex, String>> outEdges = g.getOutgoingEdges(v);
ArrayList<Vertex> thisList = new ArrayList<Vertex>();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
boolean changed = false;
HashMap<Set<Vertex>, ArrayList<Vertex>> data = new HashMap<Set<Vertex>, ArrayList<Vertex>>();
ps=g.getPredecessors(v)
Set<Vertex> ps = g.getPredecessors(v);
Set<Vertex> ps = g.getPredecessors(v);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
list=data.get(ps)
ArrayList<Vertex> list = data.get(ps);
ArrayList<Vertex> list = data.get(ps);
HashMap<String, ArrayList<Vertex>> byType = new HashMap<String, ArrayList<Vertex>>();
list2=byType.get(v.repType)
ArrayList<Vertex> list2 = byType.get(v.repType);
ArrayList<Vertex> list2 = byType.get(v.repType);
toMerge=byType.get(type)
ArrayList<Vertex> toMerge = byType.get(type);
ArrayList<Vertex> toMerge = byType.get(type);
HashMap<List<String>, List<Vertex>> m = new HashMap<List<String>, List<Vertex>>();
copy=g.deepishCopy()
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
Graph<Vertex,String> copy = g.deepishCopy();
newVertex=Vertex.merge(vertices)
Vertex newVertex = Vertex.merge(vertices);
HashSet<Vertex> preds = new HashSet<Vertex>();
HashSet<Vertex> succs = new HashSet<Vertex>();
edges=g.getEdges(v)
List<Edge<Vertex, String>> edges = g.getEdges(v);
List<Edge<Vertex, String>> edges = g.getEdges(v);
final int PRIME = 31;
int result = 1;
final Edge other = (Edge) obj;
final Edge other = (Edge) obj;
Graph<V,E> newGraph = new Graph<V,E>();
Edge<V, E> newEdge = new Edge<V, E>(from, to, data, true, false);
boolean duplicate = false;
boolean found = false;
HashSet<V> successors = new HashSet<V>(avgDegree/2);
HashSet<V> predecessors = new HashSet<V>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
ArrayList<Edge<V, E>> edges = new ArrayList<Edge<V, E>>(avgDegree/2);
HashSet<Edge<V, E>> edges = new HashSet<Edge<V, E>>(expectedVertices);
int i = 0;
ArrayList<V> postordering = new ArrayList<V>(getNumVertices());
HashSet<V> visited = new HashSet<V>(getNumVertices());
Stack<StackElem> worklist = new Stack<StackElem>();
curr=worklist.pop()
StackElem curr = worklist.pop();
postorderToVertex=computePostordering(root)
List<V> postorderToVertex = computePostordering(root);
List<V> postorderToVertex = computePostordering(root);
HashMap<V,Integer> vertexToPostorder = new HashMap<V, Integer>(getNumVertices());
int[] doms = new int[getNumVertices()];
boolean changed = true;
int new_idom = -1;
V firstPred = null;
currVertex=postorderToVertex.get(i)
V currVertex = postorderToVertex.get(i);
preds=getPredecessors(currVertex)
Set<V> preds = getPredecessors(currVertex);
Set<V> preds = getPredecessors(currVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
predPostorder=vertexToPostorder.get(predVertex)
int predPostorder = vertexToPostorder.get(predVertex);
HashMap<V, V> dominators = new HashMap<V, V>(getNumVertices());
int finger1 = b1;
int finger2 = b2;
boolean edgesValid = true;
Graph<Character, Object> g = new Graph<Character, Object>();
postordering=g.computePostordering('a')
List<Character> postordering = g.computePostordering('a');
List<Character> postordering = g.computePostordering('a');
dominators=g.computeDominators('a')
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
Map<Character,Character> dominators = g.computeDominators('a');
StringBuilder output = new StringBuilder();
StringBuilder output = new StringBuilder();

Diff of d177dd308568ccc8d821930b583e333f78daaf5a and a4ba8338ba512806a6565ed351ca65e432dda3ad:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 7
	--> recency = years
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 4
	--> recency = years
	--> Added class instantiations = 1
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision d177dd308568ccc8d821930b583e333f78daaf5a to a4ba8338ba512806a6565ed351ca65e432dda3ad

************Analysis complete************
Added generics to repository heapviz = 3

Eddie Aftandilian added type argument method count = 0
	--> recency = null
Eddie Aftandilian added wildcard count = 7
	--> recency = years
Eddie Aftandilian added type declaration count = 2
	--> recency = years
Eddie Aftandilian added type parameter method count = 0
	--> recency = null
Eddie Aftandilian added type parameter field count = 0
	--> recency = null
Eddie Aftandilian added diamond count = 0
	--> recency = null
Eddie Aftandilian added method invocation count = 0
	--> recency = null
Eddie Aftandilian added implicit method invocation count = 4
	--> recency = years
Eddie Aftandilian added class instantiation count = 1
	--> recency = years
Eddie Aftandilian added nested count = 0
	--> recency = null
Eddie Aftandilian added bounds count = 0
	--> recency = null
File copied successfully!
