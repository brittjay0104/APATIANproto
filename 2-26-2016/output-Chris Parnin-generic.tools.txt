generic.tools -- chrisparnin -- Chris Parnin
https://github.com/chrisparnin/generic.tools.git
git clone https://github.com/chrisparnin/generic.tools.git
.\generic.tools\
.\generic.tools\.git
0
Project cloned!
Chris Parnin is responsible for commit 74f8d0df854a2cc63639c4038cbe65a8a8f2efee
Chris Parnin is responsible for commit 4adb0d3b0d9d23bfb322bc84ae9edb08ba6a6d9d
Chris Parnin is responsible for commit af9b4f0346a2349c2369cf16d51689ebf1eff3c2
Chris Parnin is responsible for commit 74523cd98997cbf3bfc95208bee6679d700f7100
Chris Parnin is responsible for commit 4d51040f764a85fd22c9477b48373f3ebd4d6609
Chris Parnin is responsible for commit 873112ed1310d709618bdc808c0496cefc485dd0
Chris Parnin is responsible for commit 294ae1129618f7dccc9f5f558ee633c40e8f8e45
Chris Parnin is responsible for commit ca156fcc3eb5158008510c691e1c901475032fcb
Chris Parnin is responsible for commit 8dea7a3696373866c1fe6e698d2a88e1f66566c6
Chris Parnin is responsible for commit 4c562b59193ffe9990e454988f51bf90248d2ed2
Added GetTransactions.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added AnalyzeDeclarations.java to .\generic.tools\ repository source files.
Added GenericDeclVisitor.java to .\generic.tools\ repository source files.
Added Results.java to .\generic.tools\ repository source files.
Added TestVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added CheckoutAll.java to .\generic.tools\ repository source files.
Added TestTimezones.java to .\generic.tools\ repository source files.
Added DevelopersController.2890.java to .\generic.tools\ repository source files.
Added DevelopersController.3838.java to .\generic.tools\ repository source files.
Added AbstractVisitor.java to .\generic.tools\ repository source files.
Added AnnotationVisitor.java to .\generic.tools\ repository source files.
Added CastsVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersAndMethoParametersVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersVisitor.java to .\generic.tools\ repository source files.
Added ContainerGranularity.java to .\generic.tools\ repository source files.
Added HalsteadVisitor.java to .\generic.tools\ repository source files.
Added ParameterizedTypeVisitor.java to .\generic.tools\ repository source files.
Added RawTypesVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added Application.java to .\generic.tools\ repository source files.
Added MyAnnotation.java to .\generic.tools\ repository source files.
Added package-info.java to .\generic.tools\ repository source files.
Added TokenizeServer.java to .\generic.tools\ repository source files.
Added Util.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added AdoptionTiming7_3.java to .\generic.tools\ repository source files.
Added Analysis.java to .\generic.tools\ repository source files.
Added AnalyzeAll.java to .\generic.tools\ repository source files.
Added AnnotationAnalysis.java to .\generic.tools\ repository source files.
Added BasicAnalysis.java to .\generic.tools\ repository source files.
Added BasicMetric.java to .\generic.tools\ repository source files.
Added CastAnalysis.java to .\generic.tools\ repository source files.
Added CastInvestigation.java to .\generic.tools\ repository source files.
Added DeveloperFeatureUsage.java to .\generic.tools\ repository source files.
Added GeneralFeatureUsage.java to .\generic.tools\ repository source files.
Added HalsteadAnalysis.java to .\generic.tools\ repository source files.
Added HalsteadMetric.java to .\generic.tools\ repository source files.
Added MethodClassFeatureUsage.java to .\generic.tools\ repository source files.
Added ParameterizedDeclarationAnalysis.java to .\generic.tools\ repository source files.
Added ParameterizedTypeAnalysis.java to .\generic.tools\ repository source files.
Added RawAnalysis.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added TestFile.java to .\generic.tools\ repository source files.
Added UniqueParamAnalysis.java to .\generic.tools\ repository source files.
Added ExtractMethodFinderPlugin.java to .\generic.tools\ repository source files.
Added FindHeteroAdds.java to .\generic.tools\ repository source files.
Added FindInterestingMethods.java to .\generic.tools\ repository source files.
Added HeteroVisitor.java to .\generic.tools\ repository source files.
Added Variable.java to .\generic.tools\ repository source files.
Added VariableReference.java to .\generic.tools\ repository source files.
Added SubtractFinder.java to .\generic.tools\ repository source files.
Added SuperTypeCollector.java to .\generic.tools\ repository source files.
Added FastRevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added FastRevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GitLogParser.java to .\generic.tools\ repository source files.
Added LogParser.java to .\generic.tools\ repository source files.
Added RevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added RevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GetTop100Projects.java to .\generic.tools\ repository source files.
Added Repo.java to .\generic.tools\ repository source files.

 ************ ANALYZING FOR USAGE PATTERN ADDITION ************


****Parsing for addition at revision 74f8d0df854a2cc63639c4038cbe65a8a8f2efee****

Added GetTransactions.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added AnalyzeDeclarations.java to .\generic.tools\ repository source files.
Added GenericDeclVisitor.java to .\generic.tools\ repository source files.
Added Results.java to .\generic.tools\ repository source files.
Added TestVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added CheckoutAll.java to .\generic.tools\ repository source files.
Added TestTimezones.java to .\generic.tools\ repository source files.
Added DevelopersController.2890.java to .\generic.tools\ repository source files.
Added DevelopersController.3838.java to .\generic.tools\ repository source files.
Added AbstractVisitor.java to .\generic.tools\ repository source files.
Added AnnotationVisitor.java to .\generic.tools\ repository source files.
Added CastsVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersAndMethoParametersVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersVisitor.java to .\generic.tools\ repository source files.
Added ContainerGranularity.java to .\generic.tools\ repository source files.
Added HalsteadVisitor.java to .\generic.tools\ repository source files.
Added ParameterizedTypeVisitor.java to .\generic.tools\ repository source files.
Added RawTypesVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added Application.java to .\generic.tools\ repository source files.
Added MyAnnotation.java to .\generic.tools\ repository source files.
Added package-info.java to .\generic.tools\ repository source files.
Added TokenizeServer.java to .\generic.tools\ repository source files.
Added Util.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added AdoptionTiming7_3.java to .\generic.tools\ repository source files.
Added Analysis.java to .\generic.tools\ repository source files.
Added AnalyzeAll.java to .\generic.tools\ repository source files.
Added AnnotationAnalysis.java to .\generic.tools\ repository source files.
Added BasicAnalysis.java to .\generic.tools\ repository source files.
Added BasicMetric.java to .\generic.tools\ repository source files.
Added CastAnalysis.java to .\generic.tools\ repository source files.
Added CastInvestigation.java to .\generic.tools\ repository source files.
Added DeveloperFeatureUsage.java to .\generic.tools\ repository source files.
Added GeneralFeatureUsage.java to .\generic.tools\ repository source files.
Added HalsteadAnalysis.java to .\generic.tools\ repository source files.
Added HalsteadMetric.java to .\generic.tools\ repository source files.
Added MethodClassFeatureUsage.java to .\generic.tools\ repository source files.
Added ParameterizedDeclarationAnalysis.java to .\generic.tools\ repository source files.
Added ParameterizedTypeAnalysis.java to .\generic.tools\ repository source files.
Added RawAnalysis.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added TestFile.java to .\generic.tools\ repository source files.
Added UniqueParamAnalysis.java to .\generic.tools\ repository source files.
Added ExtractMethodFinderPlugin.java to .\generic.tools\ repository source files.
Added FindHeteroAdds.java to .\generic.tools\ repository source files.
Added FindInterestingMethods.java to .\generic.tools\ repository source files.
Added HeteroVisitor.java to .\generic.tools\ repository source files.
Added Variable.java to .\generic.tools\ repository source files.
Added VariableReference.java to .\generic.tools\ repository source files.
Added SubtractFinder.java to .\generic.tools\ repository source files.
Added SuperTypeCollector.java to .\generic.tools\ repository source files.
Added FastRevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added FastRevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GitLogParser.java to .\generic.tools\ repository source files.
Added LogParser.java to .\generic.tools\ repository source files.
Added RevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added RevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GetTop100Projects.java to .\generic.tools\ repository source files.
Added Repo.java to .\generic.tools\ repository source files.
String project = args[0];
String module = args[1];
String jdbcUrl = args[2];
boolean doingGit=false;
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
results=stmt.getResultSet()
ResultSet results = stmt.getResultSet();
files=results.getString("filename")
String files = results.getString("filename");
transId=results.getInt("transactionId")
int transId = results.getInt("transactionId");
datetime=results.getString("datetimestr")
String datetime = results.getString("datetimestr");
state=results.getString("state")
String state = results.getString("state");
revision=results.getString("revision")
String revision = results.getString("revision");
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit)parser.createAST(new NullProgressMonitor());
GenericDeclVisitor v = new GenericDeclVisitor();
TestVisitor test = new TestVisitor();
SimpleType st = (SimpleType)t;
b=st.getName().resolveBinding()
IBinding b = st.getName().resolveBinding();
gb=computeDistanceToDecl(st.getName())
GenericBinding gb = computeDistanceToDecl(st.getName());
bound=((WildcardType)t).getBound()
Type bound = ((WildcardType) t).getBound();
ArrayType at = (ArrayType) t;
QualifiedType qt = (QualifiedType) t;
ASTNode node = sn;
int depth = 0;
targetName=sn.getFullyQualifiedName()
String targetName = sn.getFullyQualifiedName();
TypeParameter tp = (TypeParameter) o;
TypeParameter tp = (TypeParameter) o;
superclassType=td.getSuperclassType()
Type superclassType = td.getSuperclassType();
returnType=md.getReturnType2()
Type returnType = md.getReturnType2();
SingleVariableDeclaration sd = (SingleVariableDeclaration) o;
A a2;
M m2;
A a2;
M m2;
binding=st.resolveBinding()
IBinding binding = st.resolveBinding();
Set<Type> otherCopy = new HashSet<Type>(typesProducedByOtherVisitor);
Set<Type> thisCopy = new HashSet<Type>(found);
List<ProjectInterval> changes = new ArrayList<ProjectInterval>();
activeEditor=targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor()
IEditorPart activeEditor = targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor();
ITextSelection selection = (ITextSelection)((ITextEditor)activeEditor).getSelectionProvider().getSelection();
lines=selection.getText()
String lines = selection.getText();
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S");
str=line.replace("\r","").replace("\n","")
String str = line.replace("\r", "").replace("\n", "");
components=line.split(",")
String[] components = line.split(",");
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
IWorkbenchAdapter adapter = (IWorkbenchAdapter)firstElement;
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
l=((CVSTagElement)firstElement).getRoot()
ICVSRepositoryLocation l = ((CVSTagElement)firstElement).getRoot();
resources=getRemoteResource()
ICVSRemoteResource[] resources = getRemoteResource();
List<CheckoutSingleProjectOperation> checkouts = 
			new LinkedList<CheckoutSingleProjectOperation>();
Job job = new Job("Checking out..."){
			public IStatus run(IProgressMonitor mon){
				
				mon.beginTask("Checking out projects from CVS", checkouts.size());
				
				List<IStatus> status = new ArrayList<IStatus>();
				
				for(CheckoutSingleProjectOperation checkout : checkouts){
					try {
						checkout.execute(new SubProgressMonitor(mon,1));						
						checkForErrors(status,checkout);
					} catch (Exception e) {
						e.printStackTrace();
					}
					 if (mon.isCanceled()) return Status.CANCEL_STATUS;
				}
				
				mon.done();
				
				return new MultiStatus(	Activator.PLUGIN_ID, 
										IStatus.WARNING, 
										status.toArray(new IStatus[0]), 
										"Checkout Warnings", 
										new RuntimeException());
			}

			private void checkForErrors(List<IStatus> existing, CheckoutSingleProjectOperation checkout) throws Exception {
				Method m = CVSOperation.class.getDeclaredMethod("getErrors");
				m.setAccessible(true);
				IStatus[] status = (IStatus[]) m.invoke(checkout);
				for(IStatus s : status){
					existing.add(s);
				}
			}
		};
List<IStatus> status = new ArrayList<IStatus>();
m=CVSOperation.class.getDeclaredMethod("getErrors")
Method m = CVSOperation.class.getDeclaredMethod("getErrors");
IStatus[] status = (IStatus[]) m.invoke(checkout);
Calendar cal = new GregorianCalendar();
Timestamp timestamp = new Timestamp(timeInUTC.getTime()
				+ cal.get(Calendar.DST_OFFSET) + cal.get(Calendar.ZONE_OFFSET)
				+ offset);
projectBefore=remoteFolderAtTime(time)
RemoteFolder projectBefore = remoteFolderAtTime(time);
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss");
String projectName = this.projectName + " " + df.format(time) + " " + resource.getName() + " " + postfix;
newProject=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName)
IProject newProject = ResourcesPlugin.getWorkspace().getRoot().
						getProject(projectName);
Timestamp predaylightSavings = new Timestamp(1172625369000l);
int oneMonthInMillis = 1000*60*60*24*50000000;
Timestamp postDaylightSavings = new Timestamp(1172625369000l+oneMonthInMillis);
Timestamp old = new Timestamp(fromDb.getTime()-60*60*1000*8);
nu=localTime(fromDb)
Timestamp nu = localTime(fromDb);
Calendar cal = new GregorianCalendar();
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList newProps = new ArrayList();
ArrayList replaceProps = new ArrayList();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{new Integer(occurrences),
													          new Integer(occurrencesFound),
																 files[i].getPath() };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[]{new Integer(newProps.size()), new Integer(replaceProps.size()), i18nStringFile.getPath()};
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList linesToPrint = new ArrayList();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList<String> newProps = new ArrayList<String>();
ArrayList<String> replaceProps = new ArrayList<String>();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{
                                        Integer.valueOf(occurrences),
										Integer.valueOf(occurrencesFound),
										files[i].getPath() 
                                    };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[] {
                        Integer.valueOf(newProps.size()), 
                        Integer.valueOf(replaceProps.size()), 
                        i18nStringFile.getPath()
                };
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList<String> linesToPrint = new ArrayList<String>();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator<?> iter = s.iterator();
Iterator<?> iter = s.iterator();
StringBuffer s = new StringBuffer();
int bracketCount = 0;
chars=containerSignature.toCharArray()
char []chars = containerSignature.toCharArray();
parent=input.getParent()
ASTNode parent = input.getParent();
ArrayList<String> names = new ArrayList<String>();
SingleVariableDeclaration param = (SingleVariableDeclaration)method.parameters().get(i);
parent=GetEnclosingContainer(input)
ASTNode parent = GetEnclosingContainer(input);
String name = "ERROR";
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
List<String> values = new ArrayList<String>();
MemberValuePair pair = (MemberValuePair)obj;
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
MethodDeclaration meth = (MethodDeclaration)node;
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
lineNumber=Unit.getLineNumber(cast.getStartPosition())
int lineNumber = Unit.getLineNumber(cast.getStartPosition());
t=cast.getType()
Type t = cast.getType();
parent=GetEnclosingContainerName(cast)
String parent = GetEnclosingContainerName(cast);
lineNumber=Unit.getLineNumber(method.getStartPosition())
int lineNumber = Unit.getLineNumber(method.getStartPosition());
name=method.getName().getFullyQualifiedName()
String name = method.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
binding=type.resolveBinding()
ITypeBinding binding = type.resolveBinding();
ParameterizedType pt = (ParameterizedType) type;
lineNumber=Unit.getLineNumber(pt.getStartPosition())
int lineNumber = Unit.getLineNumber(pt.getStartPosition());
parent=GetEnclosingContainerName(pt)
String parent = GetEnclosingContainerName(pt);
StringBuffer typeArgs = new StringBuffer();
boolean first = true;
String rawTypesString = "BlockingQueue, List, Queue, Set, SortedSet, AbstractCollection, AbstractList, " +
				"AbstractQueue, AbstractSequentialList, AbstractSet, ArrayBlockingQueue, ArrayList, ConcurrentLinkedQueue, " +
				"CopyOnWriteArrayList, CopyOnWriteArraySet, DelayQueue, EnumSet, HashSet, LinkedBlockingQueue, LinkedHashSet, " +
				"LinkedList, PriorityBlockingQueue, PriorityQueue, Stack, SynchronousQueue, TreeSet, Vector, " + 
				"Map, ConcurrentMap, SortedMap, AbstractMap, ConcurrentHashMap, EnumMap, HashMap, Hashtable, IdentityHashMap, " +
				"LinkedHashMap, TreeMap, WeakHashMap";
ParameterizedType pt = (ParameterizedType) type;
o=type.getProperty("typeArguments")
Object o = type.getProperty("typeArguments");
parts=type.toString().split("\\.")
String[] parts = type.toString().split("\\.");
String simpleTypeName = parts[parts.length-1];
lineNumber=sourceNode.getStartPosition()
int lineNumber = sourceNode.getStartPosition();
parent=GetEnclosingContainerName(sourceNode)
String parent = GetEnclosingContainerName(sourceNode);
sp=type.structuralPropertiesForType()
List sp = type.structuralPropertiesForType();
type=node.getReturnType2()
Type type = node.getReturnType2();
SingleVariableDeclaration svd = (SingleVariableDeclaration) o;
type=node.getType()
Type type = node.getType();
String foo;
int a, b = 4, c;
List badList;
String bar = "fred";
List<String> l = new LinkedList<String>();
java.util.Map m;
options=ProcessCommandArgs()
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		int test,test1,test2;
String output = "output.txt";
TokenizeServer server = new TokenizeServer(this);
int port = 6000;
Writer outputWriter = new FileWriter(output);
File dir = new File(options.get("directory"));
path=javaFile.getAbsolutePath()
String path = javaFile.getAbsolutePath();
List<File> files = new LinkedList<File>();
args=Platform.getCommandLineArgs()
String[] args = Platform.getCommandLineArgs();
Hashtable<String,String> options = new Hashtable<String,String>();
String arg = args[i];
BufferedReader r=null;
StringBuffer buffer = new StringBuffer();
String line = null;
buffer=GetFileContents(file)
StringBuffer buffer = GetFileContents(file);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
node=parser.createAST(null)
ASTNode node = parser.createAST(null);
visitor=AbstractVisitor.getVisitor(pattern,output)
AbstractVisitor visitor = AbstractVisitor.getVisitor(pattern, output);
FileWriter writer = null;
int x = (int)3.0f;
T too = null;
T[] array = (T[]) new Object[3];
ArrayList<T> a = new ArrayList<T>();
List<Double> ints = new ArrayList<Double>();
List<Double> nums = ints;
List<Double> nums = ints;
x=ints.get(1)
Number x=ints.get(1);
lineNumber=Unit.getLineNumber(t.getStartPosition())
int lineNumber = Unit.getLineNumber(t.getStartPosition());
lineNumber=Unit.getLineNumber(p.getStartPosition())
int lineNumber = Unit.getLineNumber(p.getStartPosition());
scanner=ToolFactory.createScanner(true,true,false,true)
IScanner scanner = ToolFactory.createScanner(true, true, false, true);
int token = 0;
ServerSocket serverSocket = new ServerSocket(port);
BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
Writer out = new PrintWriter(clientSocket.getOutputStream(), true);
request=reader.readLine()
String request = reader.readLine();
parts[]=request.trim().split(":")
String parts[] = request.trim().split(":");
String filepath = parts[0];
String pattern = parts[1];
ContainerGranularity containerGranularity = ContainerGranularity.FULL;
String args = parts[2];
argParts[]=args.split("=")
String argParts[] = args.split("=");
gran=argParts[1].trim().toLowerCase()
String gran = argParts[1].trim().toLowerCase();
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator iter = s.iterator();
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						"DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
String annotationsQuery = new AnnotationAnalysis(null).query()+", revisions.DateTime";
String typesQuery = new ParameterizedTypeAnalysis(null).query()+", revisions.DateTime";
Hashtable<String,ProjectTiming> timing = new Hashtable<String,ProjectTiming>();
set=s.executeQuery(annotationsQuery)
ResultSet set = s.executeQuery(annotationsQuery);
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
Connection conn = null;
Statement statement = null;
ResultSet results = null;
results=statement.executeQuery(query())
ResultSet results = statement.executeQuery(query());
Map<String,Revision> mostRecentRevision = new HashMap<String, Revision>();
t=e.getKey()
Timestamp t = e.getKey();
String lastProjectName = null;
Revision rev = new Revision();
project=r.getString("revisions.project")
String project = r.getString("revisions.project");
project=projects.get(projectName)
Project project = projects.get(projectName);
revs=project.timeToRevs.get(time)
List<Revision> revs = project.timeToRevs.get(time);
List<Revision> revs = project.timeToRevs.get(time);
String url = "jdbc:mysql://<database>/generics?netTimeoutForStreamingResults=200000";
FileWriter writer = new FileWriter("output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("an_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
int total = 0;
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
revs=getRevisionsFor(timestamp,projectName)
List<Revision> revs = getRevisionsFor(timestamp,projectName);
List<Revision> revs = getRevisionsFor(timestamp,projectName);
int val = 0;
tg=gatherResults()
TimeGraph<CombinedMetric> tg = gatherResults();
TimeGraph<CombinedMetric> tg = gatherResults();
PrintWriter out = new PrintWriter(System.out);
CastReducer cr = new CastReducer(out);
GenericReducer gr = new GenericReducer(out);
HalsteadReducer hr = new HalsteadReducer(out);
TimeGraph<CombinedMetric> tg = new TimeGraph<CombinedMetric>();
project=e.getKey()
String project = e.getKey();
CombinedMetric cm = new CombinedMetric();
map=cr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
map2=gr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
CombinedMetric last = null;
map=totals.get(projectName)
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
castIncrease=subset(projectName,castIncreasePredicate)
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
Random r = new Random();
Set<Timestamp> stamps = new HashSet<Timestamp>();
rand=r.nextInt(castIncrease.size())
int rand = r.nextInt(castIncrease.size());
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
statement=conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?")
PreparedStatement statement = conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?");
rs=statement.executeQuery()
ResultSet rs = statement.executeQuery();
module=rs.getString(1)
String module = rs.getString(1);
next=values.next()
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
metrics=totals.get(projectName)
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
castIncrease=PredicatedSortedMap.decorate(new TreeMap<Timestamp,Metric>(),TruePredicate.INSTANCE,castIncreasePredicate)
@SuppressWarnings("unchecked")
		SortedMap<Timestamp, Metric> castIncrease = PredicatedSortedMap.decorate(new TreeMap<Timestamp, Metric>(), TruePredicate.INSTANCE, castIncreasePredicate);
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,DeveloperData> devInfo = new Hashtable<String,DeveloperData>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
kind=set.getString(paramDecs() + ".kind")
String kind = set.getString(paramDecs()+".kind");
num=set.getString("num")
String num = set.getString("num");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
num=set.getInt("num")
int num = set.getInt("num");
String key = project+"^_^"+userId;
devAnnotations=CalculateAnnotationsDeltas(s)
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
DeveloperData data = new DeveloperData();
Hashtable<String,Integer> developerCount = new Hashtable<String,Integer>();
set=s.executeQuery(annotationsQuery())
ResultSet set = s.executeQuery(annotationsQuery());
Hashtable<String,Integer> fileCount = new Hashtable<String,Integer>();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
module=set.getString("revisions.module")
String module = set.getString("revisions.module");
file=set.getString("revisions.filename")
String file = set.getString("revisions.filename");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
state=set.getString("revisions.state")
String state = set.getString("revisions.state");
String key = project + "." + module + "." + file;
int last = 0;
int delta =  set.getInt("num") - last;
int lastDev = 0;
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
sumMetric=metricFrom(mostRecentRevisions.values())
HalsteadMetric sumMetric = metricFrom(mostRecentRevisions.values());
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
HalsteadMetric m = new HalsteadMetric();
HalsteadMetric sumMetric = new HalsteadMetric();
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
module=set.getString("module")
String module = set.getString("module");
filename=set.getString("filename")
String filename = set.getString("filename");
kind=set.getString("kind")
String kind = set.getString("kind");
classType=set.getString("class_type")
String classType = set.getString("class_type");
typeArgs=set.getString("type_args")
String typeArgs = set.getString("type_args");
String key = module + "." + filename + "." + classType + "." + typeArgs;
FileWriter writer = new FileWriter("pt_output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("raw_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/schoolwork/activity/generics/working_database.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						//"DBQ=C:/Users/Adminuser/Documents/Database2.accdb");
						"DBQ=C:/schoolwork/activity/generics/working_database.accdb");
String url = "jdbc:mysql://<database>:4747/generics?netTimeoutForStreamingResults=200000";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
set=s.executeQuery("SELECT project,baseEncodedAttachment FROM table")
ResultSet set = s.executeQuery("SELECT project,baseEncodedAttachment FROM table");
project=set.getString("project")
String project = set.getString("project");
module=set.getString("baseEncodedAttachment")
String module = set.getString("baseEncodedAttachment");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("proj")
String project = set.getString("proj");
classType=set.getString("class")
String classType = set.getString("class");
HeteroVisitor visitor = new HeteroVisitor(u);
projectName=u.getJavaProject().getElementName()
String projectName = u.getJavaProject().getElementName();
path=u.getResource().getFullPath()
IPath path = u.getResource().getFullPath();
writer=getWriter()
FileWriter writer = getWriter();
superTypes=ref.superTypes()
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
JFileChooser fr = new JFileChooser();
fw=fr.getFileSystemView()
FileSystemView fw = fr.getFileSystemView();
dir=fw.getDefaultDirectory().toString()
String dir = fw.getDefaultDirectory().toString();
FileWriter writer = new FileWriter(dir + "/HeteroAdds.sql", true);
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
unit=unitsToInspect.get(i)
ICompilationUnit unit = unitsToInspect.get(i);
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit) parser
				.createAST(new NullProgressMonitor());
methodName=mi.getName().getIdentifier()
String methodName = mi.getName().getIdentifier();
expression=mi.getExpression()
Expression expression = mi.getExpression();
SimpleName sn = (SimpleName) expression;
binding=sn.resolveBinding()
IBinding binding = sn.resolveBinding();
IVariableBinding varBinding = (IVariableBinding) binding;
type=varBinding.getType()
ITypeBinding type = varBinding.getType();
decl=varBinding.getVariableDeclaration()
IVariableBinding decl = varBinding
								.getVariableDeclaration();
existingTypes=typeInserts.get(decl)
List<Expression> existingTypes = typeInserts.get(decl);
List<Expression> existingTypes = typeInserts.get(decl);
Expression expr = (Expression) mi.arguments().get(0);
List<Bag<String>> superClasses = new LinkedList<Bag<String>>();
Set<String> baseClasses = new HashSet<String>();
iterator=ref.superTypes().entrySet().iterator()
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
int i = 0;
pair=iterator.next()
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Bag<String> potentialsSoFar = new HashBag<String>();
HashMap<String, Integer> superTypes = new HashMap<String, Integer>();
expressionType=expression.resolveTypeBinding()
ITypeBinding expressionType = expression.resolveTypeBinding();
SuperTypeMapSort sortedSuperTypes = new SuperTypeMapSort(superTypes);
SortedMap<String, Integer> sortedMap = new TreeMap<String, Integer>(
				sortedSuperTypes);
binding=expression.resolveTypeBinding()
ITypeBinding binding = expression.resolveTypeBinding();
bindingName=typeBinding.getName()
String bindingName = typeBinding.getName();
List<ITypeBinding> directSupertypes = new ArrayList<ITypeBinding>(
				Arrays.asList(typeBinding.getInterfaces()));
superClass=typeBinding.getSuperclass()
ITypeBinding superClass = typeBinding.getSuperclass();
oldLevel=superTypes.get(bindingName)
Integer oldLevel = superTypes.get(bindingName);
int diff = sort.get(x) - sort.get(y);
ArrayList<String> subtracts = new ArrayList<String>();
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;")
PreparedStatement stmt = conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;");
rs=stmt.executeQuery()
ResultSet rs = stmt.executeQuery();
ArrayList<String> projects = new ArrayList<String>();
String count = "", previous = "";
rsRevisions=stmt.executeQuery()
ResultSet rsRevisions = stmt.executeQuery();
ArrayList<Integer> revisions = new ArrayList<Integer>();
r=rsRevisions.getInt(1)
Integer r = rsRevisions.getInt(1);
rsCount=stmt.executeQuery()
ResultSet rsCount = stmt.executeQuery();
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
ResultSet rs;
projectName=rs.getString("ProjectName")
String projectName = rs.getString("ProjectName");
declType=rs.getString("DeclType")
String declType = rs.getString("DeclType");
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
File dataFile = new File(project + "/" + module + ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(dataFile));
st=conn.createStatement()
Statement st = conn.createStatement();
List<Revision> revisions = new ArrayList<Revision>();
Revision revisionInst = new Revision();
BufferedReader reader = new BufferedReader(new FileReader(file));
String line, path;
String timestampStr;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
long timeWindow = 1000 * 60 * 15;
DateFormat CVSDateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
DateFormat otherCVSDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);", flags);
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
pattern=Pattern.compile("branches:\\s+[0-9.]+;")
Pattern pattern = Pattern.compile("branches:\\s+[0-9.]+;");
matcherLog=pattern.matcher(revisionInst.logMessage)
Matcher matcherLog = pattern.matcher(revisionInst.logMessage);
int transactionId = 1;
Revision r1, r2;
int j;
Hashtable<Integer, List<Revision>> trans = new Hashtable<Integer, List<Revision>>();
List<Transaction> transactions = new ArrayList<Transaction>();
Transaction t = new Transaction(trans.get(id));
int id = 0;
overlaps=FindOverlaps(transactions)
HashSet<Transaction> overlaps = FindOverlaps(transactions);
HashSet<Transaction> overlaps = FindOverlaps(transactions);
overlapSize=overlaps.size()
int overlapSize = overlaps.size();
tempPath=dataFile.getAbsolutePath()
String tempPath = dataFile.getAbsolutePath();
o=c.Parent.HasRevisionWithFile(r.filename)
Revision o = c.Parent.HasRevisionWithFile(r.filename);
oVersion=Integer.parseInt(o.revision.split("[.]")[1])
int oVersion = Integer.parseInt(o.revision.split("[.]")[1]);
rVersion=Integer.parseInt(r.revision.split("[.]")[1])
int rVersion = Integer.parseInt(r.revision.split("[.]")[1]);
HashSet<Transaction> overlaps = new HashSet<Transaction>();
boolean afterStart = t.First().date.compareTo(p.Last().date) < 0;
boolean overlapsStart = p.Last().date.compareTo(t.Last().date) < 0;
boolean beforeEnd = t.Last().date.compareTo(p.First().date) > 0;
boolean overlapsEnd = p.First().date.compareTo(t.First().date) > 0;
String info = t.First().date + " to " + t.Last().date + " overlaps with " + 
					              p.First().date + " to " + p.Last().date;
String nums = t.Id + " " + p.Id;
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
filename=parts[1].replace("/Attic","")
String filename = parts[1].replace("/Attic", "");
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path)
String fileName = formatFile(path);
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
FastRevisionCVSLogParser logParser = new FastRevisionCVSLogParser();
BufferedWriter sqlWriter = new BufferedWriter(new FileWriter(outputBase + ".sql"));
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(outputBase + ".data"));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
String project = args[0];
String logFilename = args[1];
String outputBase = args[2];
FastRevisionSVNLogParser logParser = new FastRevisionSVNLogParser(project);
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
BufferedReader logReader = new BufferedReader(new FileReader(file));
DateFormat gitDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
StringBuilder sb;
String line;
String revision, committer, parent, msg, status, path, diffUrl;
Date dateTime;
String[] parts;
int transaction = 1;
boolean validTransaction = false;
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String logCmd = "git log --reverse --full-history --all --date=iso --name-status -M -C --pretty=format:\"" +
    			"__START_GIT_COMMIT_LOG_MSG__%nrevision: %H%ncommitter: %cn%ndate: %ci%nparent: %P%n%s%n%b%n__END_GIT_COMMIT_LOG_MSG__\"";
String project = args[0];
String logFilename = args[1];
String jdbcUrl = args[2];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
GitLogParser logParser = new GitLogParser(project);
nodeList=node.getElementsByTagName(tag)
NodeList nodeList = node.getElementsByTagName(tag);
Element valueNode = (Element)nodeList.item(0);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
BufferedReader reader = new BufferedReader(new FileReader(file));
String line;
String filename, revision, author, timestampStr;
Timestamp timestamp;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);", flags);
statement=conn.createStatement()
Statement statement = conn.createStatement();
String insertPart = "insert into revisions (project, filename, datetime, revision, userid, logmessage, module, diffUrl) VALUES ";
insertStatement=conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)")
PreparedStatement insertStatement = conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)");
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
StringBuilder bigInsert = new StringBuilder(insertPart);
boolean first = true;
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
String filename = module + parts[1];
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path,project,module)
String fileName = formatFile( path, project, module);
StringBuilder sb = new StringBuilder("update revisions set transactionid = " + transaction + " where fileid in (");
boolean first = true;
st=conn.createStatement()
Statement st = conn.createStatement();
String sql = "select userid, datetime, fileID from revisions where project = '" 
    			+ project + "' and module = '" + module + "' order by userid, datetime asc";
st=conn.createStatement()
Statement st = conn.createStatement();
long timeWindow = 1000 * 60 * 60;
rs=st.getResultSet()
ResultSet rs = st.getResultSet();
String lastUser = null;
String currentUser;
Date lastCommitDate = new Date(0);
Date currentCommitDate;
int transaction = 1;
List<Integer> transactionFileIds = new LinkedList<Integer>();
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionCVSLogParser logParser = new RevisionCVSLogParser();
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
java.util.Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
diffUrl=formatRevisionLink(project,path,revision)
String diffUrl = formatRevisionLink(project, path, revision);
action=fileNode.getAttributes().getNamedItem("action").getTextContent()
String action = fileNode.getAttributes().getNamedItem("action").getTextContent();
String state = "";
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String baseUrl = "http://" + project + ".svn.sourceforge.net/viewvc/" + project;
a=Integer.parseInt(version)
int a = Integer.parseInt(version);
int b = a - 1;
String fileName = path;
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionSVNLogParser logParser = new RevisionSVNLogParser(project, module);
List<ProjectEntry> projects = new ArrayList<ProjectEntry>(100);
int pageNum = projects.size()/10+1;
doc=getDoc("p.xml?page=" + pageNum + "&q=language%3Ajava&sort=users&")
Document doc =getDoc("p.xml?page="+pageNum+"&q=language%3Ajava&sort=users&");
Element resultElement = (Element)element.getElementsByTagName("result").item(0);
projectId=elementIn(projectNode,"id")
String projectId = elementIn(projectNode, "id");
projectName=elementIn(projectNode,"name")
String projectName = elementIn(projectNode, "name");
ProjectEntry p = new ProjectEntry();
boolean complete = false;
int page = 0;
String pageString;
doc=getDoc("p/" + projectId + "/enlistments.xml"+ pageString)
Document doc = getDoc("p/" + projectId+ "/enlistments.xml"+pageString);
itemsReturned=Integer.parseInt(elementIn(response,"items_returned"))
int itemsReturned = Integer.parseInt(elementIn(response, "items_returned"));
itemsAvailable=Integer.parseInt(elementIn(response,"items_available"))
int itemsAvailable = Integer.parseInt(elementIn(response, "items_available"));
firstItemPosition=Integer.parseInt(elementIn(response,"first_item_position"))
int firstItemPosition = Integer.parseInt(elementIn(response, "first_item_position"));
Element resultElement = (Element)response.getElementsByTagName("result").item(0);
type=elementIn(repo,"type")
String type = elementIn(repo, "type");
repoURL=elementIn(repo,"url")
String repoURL = elementIn(repo, "url");
module=elementIn(repo,"module_name")
String module = elementIn(repo, "module_name");
username=elementIn(repo,"username")
String username = elementIn(repo, "username");
password=elementIn(repo,"password")
String password = elementIn(repo, "password");
status=elementIn(repo,"ohloh_job_status")
String status = elementIn(repo, "ohloh_job_status");
Repo r = new Repo(type,repoURL,module,username,password,status);
String pre = "https://www.ohloh.net/";
String post = "api_key=waDryU9cuiDEO64aJLYMA";
URL url = new URL(pre+string+post);
con=url.openConnection()
URLConnection con = url.openConnection();
builder=DocumentBuilderFactory.newInstance().newDocumentBuilder()
DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
doc=builder.parse(con.getInputStream())
Document doc = builder.parse(con.getInputStream());
elem=parent.getElementsByTagName(s)
NodeList elem = parent.getElementsByTagName(s);
StringBuilder sb = new StringBuilder();
Element temp = next;
item=coll.item(pointer++)
Node item = coll.item(pointer++);
wholeText=((Text)item).getWholeText()
String wholeText = ((Text)item).getWholeText();
Element elem = (Element) item;
statusList=element.getElementsByTagName("status")
NodeList statusList = element.getElementsByTagName("status");
statusNode=statusList.item(0)
Node statusNode = statusList.item(0);

Diff of 74f8d0df854a2cc63639c4038cbe65a8a8f2efee and 4adb0d3b0d9d23bfb322bc84ae9edb08ba6a6d9d:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 74f8d0df854a2cc63639c4038cbe65a8a8f2efee to 4adb0d3b0d9d23bfb322bc84ae9edb08ba6a6d9d


****Parsing for addition at revision 4adb0d3b0d9d23bfb322bc84ae9edb08ba6a6d9d****

Added GetTransactions.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added AnalyzeDeclarations.java to .\generic.tools\ repository source files.
Added GenericDeclVisitor.java to .\generic.tools\ repository source files.
Added Results.java to .\generic.tools\ repository source files.
Added TestVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added CheckoutAll.java to .\generic.tools\ repository source files.
Added TestTimezones.java to .\generic.tools\ repository source files.
Added DevelopersController.2890.java to .\generic.tools\ repository source files.
Added DevelopersController.3838.java to .\generic.tools\ repository source files.
Added AbstractVisitor.java to .\generic.tools\ repository source files.
Added AnnotationVisitor.java to .\generic.tools\ repository source files.
Added CastsVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersAndMethoParametersVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersVisitor.java to .\generic.tools\ repository source files.
Added ContainerGranularity.java to .\generic.tools\ repository source files.
Added HalsteadVisitor.java to .\generic.tools\ repository source files.
Added ParameterizedTypeVisitor.java to .\generic.tools\ repository source files.
Added RawTypesVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added Application.java to .\generic.tools\ repository source files.
Added MyAnnotation.java to .\generic.tools\ repository source files.
Added package-info.java to .\generic.tools\ repository source files.
Added TokenizeServer.java to .\generic.tools\ repository source files.
Added Util.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added AdoptionTiming7_3.java to .\generic.tools\ repository source files.
Added Analysis.java to .\generic.tools\ repository source files.
Added AnalyzeAll.java to .\generic.tools\ repository source files.
Added AnnotationAnalysis.java to .\generic.tools\ repository source files.
Added BasicAnalysis.java to .\generic.tools\ repository source files.
Added BasicMetric.java to .\generic.tools\ repository source files.
Added CastAnalysis.java to .\generic.tools\ repository source files.
Added CastInvestigation.java to .\generic.tools\ repository source files.
Added DeveloperFeatureUsage.java to .\generic.tools\ repository source files.
Added GeneralFeatureUsage.java to .\generic.tools\ repository source files.
Added HalsteadAnalysis.java to .\generic.tools\ repository source files.
Added HalsteadMetric.java to .\generic.tools\ repository source files.
Added MethodClassFeatureUsage.java to .\generic.tools\ repository source files.
Added ParameterizedDeclarationAnalysis.java to .\generic.tools\ repository source files.
Added ParameterizedTypeAnalysis.java to .\generic.tools\ repository source files.
Added RawAnalysis.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added TestFile.java to .\generic.tools\ repository source files.
Added UniqueParamAnalysis.java to .\generic.tools\ repository source files.
Added ExtractMethodFinderPlugin.java to .\generic.tools\ repository source files.
Added FindHeteroAdds.java to .\generic.tools\ repository source files.
Added FindInterestingMethods.java to .\generic.tools\ repository source files.
Added HeteroVisitor.java to .\generic.tools\ repository source files.
Added Variable.java to .\generic.tools\ repository source files.
Added VariableReference.java to .\generic.tools\ repository source files.
Added SubtractFinder.java to .\generic.tools\ repository source files.
Added SuperTypeCollector.java to .\generic.tools\ repository source files.
Added FastRevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added FastRevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GitLogParser.java to .\generic.tools\ repository source files.
Added LogParser.java to .\generic.tools\ repository source files.
Added RevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added RevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GetTop100Projects.java to .\generic.tools\ repository source files.
Added Repo.java to .\generic.tools\ repository source files.
String project = args[0];
String module = args[1];
String jdbcUrl = args[2];
boolean doingGit=false;
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
results=stmt.getResultSet()
ResultSet results = stmt.getResultSet();
files=results.getString("filename")
String files = results.getString("filename");
transId=results.getInt("transactionId")
int transId = results.getInt("transactionId");
datetime=results.getString("datetimestr")
String datetime = results.getString("datetimestr");
state=results.getString("state")
String state = results.getString("state");
revision=results.getString("revision")
String revision = results.getString("revision");
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit)parser.createAST(new NullProgressMonitor());
GenericDeclVisitor v = new GenericDeclVisitor();
TestVisitor test = new TestVisitor();
SimpleType st = (SimpleType)t;
b=st.getName().resolveBinding()
IBinding b = st.getName().resolveBinding();
gb=computeDistanceToDecl(st.getName())
GenericBinding gb = computeDistanceToDecl(st.getName());
bound=((WildcardType)t).getBound()
Type bound = ((WildcardType) t).getBound();
ArrayType at = (ArrayType) t;
QualifiedType qt = (QualifiedType) t;
ASTNode node = sn;
int depth = 0;
targetName=sn.getFullyQualifiedName()
String targetName = sn.getFullyQualifiedName();
TypeParameter tp = (TypeParameter) o;
TypeParameter tp = (TypeParameter) o;
superclassType=td.getSuperclassType()
Type superclassType = td.getSuperclassType();
returnType=md.getReturnType2()
Type returnType = md.getReturnType2();
SingleVariableDeclaration sd = (SingleVariableDeclaration) o;
A a2;
M m2;
A a2;
M m2;
binding=st.resolveBinding()
IBinding binding = st.resolveBinding();
Set<Type> otherCopy = new HashSet<Type>(typesProducedByOtherVisitor);
Set<Type> thisCopy = new HashSet<Type>(found);
List<ProjectInterval> changes = new ArrayList<ProjectInterval>();
activeEditor=targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor()
IEditorPart activeEditor = targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor();
ITextSelection selection = (ITextSelection)((ITextEditor)activeEditor).getSelectionProvider().getSelection();
lines=selection.getText()
String lines = selection.getText();
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S");
str=line.replace("\r","").replace("\n","")
String str = line.replace("\r", "").replace("\n", "");
components=line.split(",")
String[] components = line.split(",");
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
IWorkbenchAdapter adapter = (IWorkbenchAdapter)firstElement;
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
l=((CVSTagElement)firstElement).getRoot()
ICVSRepositoryLocation l = ((CVSTagElement)firstElement).getRoot();
resources=getRemoteResource()
ICVSRemoteResource[] resources = getRemoteResource();
List<CheckoutSingleProjectOperation> checkouts = 
			new LinkedList<CheckoutSingleProjectOperation>();
Job job = new Job("Checking out..."){
			public IStatus run(IProgressMonitor mon){
				
				mon.beginTask("Checking out projects from CVS", checkouts.size());
				
				List<IStatus> status = new ArrayList<IStatus>();
				
				for(CheckoutSingleProjectOperation checkout : checkouts){
					try {
						checkout.execute(new SubProgressMonitor(mon,1));						
						checkForErrors(status,checkout);
					} catch (Exception e) {
						e.printStackTrace();
					}
					 if (mon.isCanceled()) return Status.CANCEL_STATUS;
				}
				
				mon.done();
				
				return new MultiStatus(	Activator.PLUGIN_ID, 
										IStatus.WARNING, 
										status.toArray(new IStatus[0]), 
										"Checkout Warnings", 
										new RuntimeException());
			}

			private void checkForErrors(List<IStatus> existing, CheckoutSingleProjectOperation checkout) throws Exception {
				Method m = CVSOperation.class.getDeclaredMethod("getErrors");
				m.setAccessible(true);
				IStatus[] status = (IStatus[]) m.invoke(checkout);
				for(IStatus s : status){
					existing.add(s);
				}
			}
		};
List<IStatus> status = new ArrayList<IStatus>();
m=CVSOperation.class.getDeclaredMethod("getErrors")
Method m = CVSOperation.class.getDeclaredMethod("getErrors");
IStatus[] status = (IStatus[]) m.invoke(checkout);
Calendar cal = new GregorianCalendar();
Timestamp timestamp = new Timestamp(timeInUTC.getTime()
				+ cal.get(Calendar.DST_OFFSET) + cal.get(Calendar.ZONE_OFFSET)
				+ offset);
projectBefore=remoteFolderAtTime(time)
RemoteFolder projectBefore = remoteFolderAtTime(time);
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss");
String projectName = this.projectName + " " + df.format(time) + " " + resource.getName() + " " + postfix;
newProject=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName)
IProject newProject = ResourcesPlugin.getWorkspace().getRoot().
						getProject(projectName);
Timestamp predaylightSavings = new Timestamp(1172625369000l);
int oneMonthInMillis = 1000*60*60*24*50000000;
Timestamp postDaylightSavings = new Timestamp(1172625369000l+oneMonthInMillis);
Timestamp old = new Timestamp(fromDb.getTime()-60*60*1000*8);
nu=localTime(fromDb)
Timestamp nu = localTime(fromDb);
Calendar cal = new GregorianCalendar();
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList newProps = new ArrayList();
ArrayList replaceProps = new ArrayList();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{new Integer(occurrences),
													          new Integer(occurrencesFound),
																 files[i].getPath() };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[]{new Integer(newProps.size()), new Integer(replaceProps.size()), i18nStringFile.getPath()};
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList linesToPrint = new ArrayList();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList<String> newProps = new ArrayList<String>();
ArrayList<String> replaceProps = new ArrayList<String>();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{
                                        Integer.valueOf(occurrences),
										Integer.valueOf(occurrencesFound),
										files[i].getPath() 
                                    };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[] {
                        Integer.valueOf(newProps.size()), 
                        Integer.valueOf(replaceProps.size()), 
                        i18nStringFile.getPath()
                };
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList<String> linesToPrint = new ArrayList<String>();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator<?> iter = s.iterator();
Iterator<?> iter = s.iterator();
StringBuffer s = new StringBuffer();
int bracketCount = 0;
chars=containerSignature.toCharArray()
char []chars = containerSignature.toCharArray();
parent=input.getParent()
ASTNode parent = input.getParent();
ArrayList<String> names = new ArrayList<String>();
SingleVariableDeclaration param = (SingleVariableDeclaration)method.parameters().get(i);
parent=GetEnclosingContainer(input)
ASTNode parent = GetEnclosingContainer(input);
String name = "ERROR";
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
List<String> values = new ArrayList<String>();
MemberValuePair pair = (MemberValuePair)obj;
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
MethodDeclaration meth = (MethodDeclaration)node;
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
lineNumber=Unit.getLineNumber(cast.getStartPosition())
int lineNumber = Unit.getLineNumber(cast.getStartPosition());
t=cast.getType()
Type t = cast.getType();
parent=GetEnclosingContainerName(cast)
String parent = GetEnclosingContainerName(cast);
lineNumber=Unit.getLineNumber(method.getStartPosition())
int lineNumber = Unit.getLineNumber(method.getStartPosition());
name=method.getName().getFullyQualifiedName()
String name = method.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
binding=type.resolveBinding()
ITypeBinding binding = type.resolveBinding();
ParameterizedType pt = (ParameterizedType) type;
lineNumber=Unit.getLineNumber(pt.getStartPosition())
int lineNumber = Unit.getLineNumber(pt.getStartPosition());
parent=GetEnclosingContainerName(pt)
String parent = GetEnclosingContainerName(pt);
StringBuffer typeArgs = new StringBuffer();
boolean first = true;
String rawTypesString = "BlockingQueue, List, Queue, Set, SortedSet, AbstractCollection, AbstractList, " +
				"AbstractQueue, AbstractSequentialList, AbstractSet, ArrayBlockingQueue, ArrayList, ConcurrentLinkedQueue, " +
				"CopyOnWriteArrayList, CopyOnWriteArraySet, DelayQueue, EnumSet, HashSet, LinkedBlockingQueue, LinkedHashSet, " +
				"LinkedList, PriorityBlockingQueue, PriorityQueue, Stack, SynchronousQueue, TreeSet, Vector, " + 
				"Map, ConcurrentMap, SortedMap, AbstractMap, ConcurrentHashMap, EnumMap, HashMap, Hashtable, IdentityHashMap, " +
				"LinkedHashMap, TreeMap, WeakHashMap";
ParameterizedType pt = (ParameterizedType) type;
o=type.getProperty("typeArguments")
Object o = type.getProperty("typeArguments");
parts=type.toString().split("\\.")
String[] parts = type.toString().split("\\.");
String simpleTypeName = parts[parts.length-1];
lineNumber=sourceNode.getStartPosition()
int lineNumber = sourceNode.getStartPosition();
parent=GetEnclosingContainerName(sourceNode)
String parent = GetEnclosingContainerName(sourceNode);
sp=type.structuralPropertiesForType()
List sp = type.structuralPropertiesForType();
type=node.getReturnType2()
Type type = node.getReturnType2();
SingleVariableDeclaration svd = (SingleVariableDeclaration) o;
type=node.getType()
Type type = node.getType();
String foo;
int a, b = 4, c;
List badList;
String bar = "fred";
List<String> l = new LinkedList<String>();
java.util.Map m;
options=ProcessCommandArgs()
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		int test,test1,test2;
String output = "output.txt";
TokenizeServer server = new TokenizeServer(this);
int port = 6000;
Writer outputWriter = new FileWriter(output);
File dir = new File(options.get("directory"));
path=javaFile.getAbsolutePath()
String path = javaFile.getAbsolutePath();
List<File> files = new LinkedList<File>();
args=Platform.getCommandLineArgs()
String[] args = Platform.getCommandLineArgs();
Hashtable<String,String> options = new Hashtable<String,String>();
String arg = args[i];
BufferedReader r=null;
StringBuffer buffer = new StringBuffer();
String line = null;
buffer=GetFileContents(file)
StringBuffer buffer = GetFileContents(file);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
node=parser.createAST(null)
ASTNode node = parser.createAST(null);
visitor=AbstractVisitor.getVisitor(pattern,output)
AbstractVisitor visitor = AbstractVisitor.getVisitor(pattern, output);
FileWriter writer = null;
int x = (int)3.0f;
T too = null;
T[] array = (T[]) new Object[3];
ArrayList<T> a = new ArrayList<T>();
List<Double> ints = new ArrayList<Double>();
List<Double> nums = ints;
List<Double> nums = ints;
x=ints.get(1)
Number x=ints.get(1);
lineNumber=Unit.getLineNumber(t.getStartPosition())
int lineNumber = Unit.getLineNumber(t.getStartPosition());
lineNumber=Unit.getLineNumber(p.getStartPosition())
int lineNumber = Unit.getLineNumber(p.getStartPosition());
scanner=ToolFactory.createScanner(true,true,false,true)
IScanner scanner = ToolFactory.createScanner(true, true, false, true);
int token = 0;
ServerSocket serverSocket = new ServerSocket(port);
BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
Writer out = new PrintWriter(clientSocket.getOutputStream(), true);
request=reader.readLine()
String request = reader.readLine();
parts[]=request.trim().split(":")
String parts[] = request.trim().split(":");
String filepath = parts[0];
String pattern = parts[1];
ContainerGranularity containerGranularity = ContainerGranularity.FULL;
String args = parts[2];
argParts[]=args.split("=")
String argParts[] = args.split("=");
gran=argParts[1].trim().toLowerCase()
String gran = argParts[1].trim().toLowerCase();
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator iter = s.iterator();
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						"DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
String annotationsQuery = new AnnotationAnalysis(null).query()+", revisions.DateTime";
String typesQuery = new ParameterizedTypeAnalysis(null).query()+", revisions.DateTime";
Hashtable<String,ProjectTiming> timing = new Hashtable<String,ProjectTiming>();
set=s.executeQuery(annotationsQuery)
ResultSet set = s.executeQuery(annotationsQuery);
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
Connection conn = null;
Statement statement = null;
ResultSet results = null;
results=statement.executeQuery(query())
ResultSet results = statement.executeQuery(query());
Map<String,Revision> mostRecentRevision = new HashMap<String, Revision>();
t=e.getKey()
Timestamp t = e.getKey();
String lastProjectName = null;
Revision rev = new Revision();
project=r.getString("revisions.project")
String project = r.getString("revisions.project");
project=projects.get(projectName)
Project project = projects.get(projectName);
revs=project.timeToRevs.get(time)
List<Revision> revs = project.timeToRevs.get(time);
List<Revision> revs = project.timeToRevs.get(time);
String url = "jdbc:mysql://<database>/generics?netTimeoutForStreamingResults=200000";
FileWriter writer = new FileWriter("output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("an_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
int total = 0;
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
revs=getRevisionsFor(timestamp,projectName)
List<Revision> revs = getRevisionsFor(timestamp,projectName);
List<Revision> revs = getRevisionsFor(timestamp,projectName);
int val = 0;
tg=gatherResults()
TimeGraph<CombinedMetric> tg = gatherResults();
TimeGraph<CombinedMetric> tg = gatherResults();
PrintWriter out = new PrintWriter(System.out);
CastReducer cr = new CastReducer(out);
GenericReducer gr = new GenericReducer(out);
HalsteadReducer hr = new HalsteadReducer(out);
TimeGraph<CombinedMetric> tg = new TimeGraph<CombinedMetric>();
project=e.getKey()
String project = e.getKey();
CombinedMetric cm = new CombinedMetric();
map=cr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
map2=gr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
CombinedMetric last = null;
map=totals.get(projectName)
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
castIncrease=subset(projectName,castIncreasePredicate)
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
Random r = new Random();
Set<Timestamp> stamps = new HashSet<Timestamp>();
rand=r.nextInt(castIncrease.size())
int rand = r.nextInt(castIncrease.size());
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
statement=conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?")
PreparedStatement statement = conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?");
rs=statement.executeQuery()
ResultSet rs = statement.executeQuery();
module=rs.getString(1)
String module = rs.getString(1);
next=values.next()
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
metrics=totals.get(projectName)
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
castIncrease=PredicatedSortedMap.decorate(new TreeMap<Timestamp,Metric>(),TruePredicate.INSTANCE,castIncreasePredicate)
@SuppressWarnings("unchecked")
		SortedMap<Timestamp, Metric> castIncrease = PredicatedSortedMap.decorate(new TreeMap<Timestamp, Metric>(), TruePredicate.INSTANCE, castIncreasePredicate);
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,DeveloperData> devInfo = new Hashtable<String,DeveloperData>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
kind=set.getString(paramDecs() + ".kind")
String kind = set.getString(paramDecs()+".kind");
num=set.getString("num")
String num = set.getString("num");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
num=set.getInt("num")
int num = set.getInt("num");
String key = project+"^_^"+userId;
devAnnotations=CalculateAnnotationsDeltas(s)
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
DeveloperData data = new DeveloperData();
Hashtable<String,Integer> developerCount = new Hashtable<String,Integer>();
set=s.executeQuery(annotationsQuery())
ResultSet set = s.executeQuery(annotationsQuery());
Hashtable<String,Integer> fileCount = new Hashtable<String,Integer>();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
module=set.getString("revisions.module")
String module = set.getString("revisions.module");
file=set.getString("revisions.filename")
String file = set.getString("revisions.filename");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
state=set.getString("revisions.state")
String state = set.getString("revisions.state");
String key = project + "." + module + "." + file;
int last = 0;
int delta =  set.getInt("num") - last;
int lastDev = 0;
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
sumMetric=metricFrom(mostRecentRevisions.values())
HalsteadMetric sumMetric = metricFrom(mostRecentRevisions.values());
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
HalsteadMetric m = new HalsteadMetric();
HalsteadMetric sumMetric = new HalsteadMetric();
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
module=set.getString("module")
String module = set.getString("module");
filename=set.getString("filename")
String filename = set.getString("filename");
kind=set.getString("kind")
String kind = set.getString("kind");
classType=set.getString("class_type")
String classType = set.getString("class_type");
typeArgs=set.getString("type_args")
String typeArgs = set.getString("type_args");
String key = module + "." + filename + "." + classType + "." + typeArgs;
FileWriter writer = new FileWriter("pt_output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("raw_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/schoolwork/activity/generics/working_database.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						//"DBQ=C:/Users/Adminuser/Documents/Database2.accdb");
						"DBQ=C:/schoolwork/activity/generics/working_database.accdb");
String url = "jdbc:mysql://<database>:4747/generics?netTimeoutForStreamingResults=200000";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
set=s.executeQuery("SELECT project,baseEncodedAttachment FROM table")
ResultSet set = s.executeQuery("SELECT project,baseEncodedAttachment FROM table");
project=set.getString("project")
String project = set.getString("project");
module=set.getString("baseEncodedAttachment")
String module = set.getString("baseEncodedAttachment");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("proj")
String project = set.getString("proj");
classType=set.getString("class")
String classType = set.getString("class");
HeteroVisitor visitor = new HeteroVisitor(u);
projectName=u.getJavaProject().getElementName()
String projectName = u.getJavaProject().getElementName();
path=u.getResource().getFullPath()
IPath path = u.getResource().getFullPath();
writer=getWriter()
FileWriter writer = getWriter();
superTypes=ref.superTypes()
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
JFileChooser fr = new JFileChooser();
fw=fr.getFileSystemView()
FileSystemView fw = fr.getFileSystemView();
dir=fw.getDefaultDirectory().toString()
String dir = fw.getDefaultDirectory().toString();
FileWriter writer = new FileWriter(dir + "/HeteroAdds.sql", true);
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
unit=unitsToInspect.get(i)
ICompilationUnit unit = unitsToInspect.get(i);
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit) parser
				.createAST(new NullProgressMonitor());
methodName=mi.getName().getIdentifier()
String methodName = mi.getName().getIdentifier();
expression=mi.getExpression()
Expression expression = mi.getExpression();
SimpleName sn = (SimpleName) expression;
binding=sn.resolveBinding()
IBinding binding = sn.resolveBinding();
IVariableBinding varBinding = (IVariableBinding) binding;
type=varBinding.getType()
ITypeBinding type = varBinding.getType();
decl=varBinding.getVariableDeclaration()
IVariableBinding decl = varBinding
								.getVariableDeclaration();
existingTypes=typeInserts.get(decl)
List<Expression> existingTypes = typeInserts.get(decl);
List<Expression> existingTypes = typeInserts.get(decl);
Expression expr = (Expression) mi.arguments().get(0);
List<Bag<String>> superClasses = new LinkedList<Bag<String>>();
Set<String> baseClasses = new HashSet<String>();
iterator=ref.superTypes().entrySet().iterator()
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
int i = 0;
pair=iterator.next()
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Bag<String> potentialsSoFar = new HashBag<String>();
HashMap<String, Integer> superTypes = new HashMap<String, Integer>();
expressionType=expression.resolveTypeBinding()
ITypeBinding expressionType = expression.resolveTypeBinding();
SuperTypeMapSort sortedSuperTypes = new SuperTypeMapSort(superTypes);
SortedMap<String, Integer> sortedMap = new TreeMap<String, Integer>(
				sortedSuperTypes);
binding=expression.resolveTypeBinding()
ITypeBinding binding = expression.resolveTypeBinding();
bindingName=typeBinding.getName()
String bindingName = typeBinding.getName();
List<ITypeBinding> directSupertypes = new ArrayList<ITypeBinding>(
				Arrays.asList(typeBinding.getInterfaces()));
superClass=typeBinding.getSuperclass()
ITypeBinding superClass = typeBinding.getSuperclass();
oldLevel=superTypes.get(bindingName)
Integer oldLevel = superTypes.get(bindingName);
int diff = sort.get(x) - sort.get(y);
ArrayList<String> subtracts = new ArrayList<String>();
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;")
PreparedStatement stmt = conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;");
rs=stmt.executeQuery()
ResultSet rs = stmt.executeQuery();
ArrayList<String> projects = new ArrayList<String>();
String count = "", previous = "";
rsRevisions=stmt.executeQuery()
ResultSet rsRevisions = stmt.executeQuery();
ArrayList<Integer> revisions = new ArrayList<Integer>();
r=rsRevisions.getInt(1)
Integer r = rsRevisions.getInt(1);
rsCount=stmt.executeQuery()
ResultSet rsCount = stmt.executeQuery();
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
ResultSet rs;
projectName=rs.getString("ProjectName")
String projectName = rs.getString("ProjectName");
declType=rs.getString("DeclType")
String declType = rs.getString("DeclType");
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
File dataFile = new File(project + "/" + module + ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(dataFile));
st=conn.createStatement()
Statement st = conn.createStatement();
List<Revision> revisions = new ArrayList<Revision>();
Revision revisionInst = new Revision();
BufferedReader reader = new BufferedReader(new FileReader(file));
String line, path;
String timestampStr;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
long timeWindow = 1000 * 60 * 15;
DateFormat CVSDateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
DateFormat otherCVSDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);", flags);
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
pattern=Pattern.compile("branches:\\s+[0-9.]+;")
Pattern pattern = Pattern.compile("branches:\\s+[0-9.]+;");
matcherLog=pattern.matcher(revisionInst.logMessage)
Matcher matcherLog = pattern.matcher(revisionInst.logMessage);
int transactionId = 1;
Revision r1, r2;
int j;
Hashtable<Integer, List<Revision>> trans = new Hashtable<Integer, List<Revision>>();
List<Transaction> transactions = new ArrayList<Transaction>();
Transaction t = new Transaction(trans.get(id));
int id = 0;
overlaps=FindOverlaps(transactions)
HashSet<Transaction> overlaps = FindOverlaps(transactions);
HashSet<Transaction> overlaps = FindOverlaps(transactions);
overlapSize=overlaps.size()
int overlapSize = overlaps.size();
tempPath=dataFile.getAbsolutePath()
String tempPath = dataFile.getAbsolutePath();
o=c.Parent.HasRevisionWithFile(r.filename)
Revision o = c.Parent.HasRevisionWithFile(r.filename);
oVersion=Integer.parseInt(o.revision.split("[.]")[1])
int oVersion = Integer.parseInt(o.revision.split("[.]")[1]);
rVersion=Integer.parseInt(r.revision.split("[.]")[1])
int rVersion = Integer.parseInt(r.revision.split("[.]")[1]);
HashSet<Transaction> overlaps = new HashSet<Transaction>();
boolean afterStart = t.First().date.compareTo(p.Last().date) < 0;
boolean overlapsStart = p.Last().date.compareTo(t.Last().date) < 0;
boolean beforeEnd = t.Last().date.compareTo(p.First().date) > 0;
boolean overlapsEnd = p.First().date.compareTo(t.First().date) > 0;
String info = t.First().date + " to " + t.Last().date + " overlaps with " + 
					              p.First().date + " to " + p.Last().date;
String nums = t.Id + " " + p.Id;
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
filename=parts[1].replace("/Attic","")
String filename = parts[1].replace("/Attic", "");
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path)
String fileName = formatFile(path);
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
FastRevisionCVSLogParser logParser = new FastRevisionCVSLogParser();
BufferedWriter sqlWriter = new BufferedWriter(new FileWriter(outputBase + ".sql"));
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(outputBase + ".data"));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
String project = args[0];
String logFilename = args[1];
String outputBase = args[2];
FastRevisionSVNLogParser logParser = new FastRevisionSVNLogParser(project);
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
BufferedReader logReader = new BufferedReader(new FileReader(file));
DateFormat gitDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
StringBuilder sb;
String line;
String revision, committer, parent, msg, status, path, diffUrl;
Date dateTime;
String[] parts;
int transaction = 1;
boolean validTransaction = false;
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String logCmd = "git log --reverse --full-history --all --date=iso --name-status -M -C --pretty=format:\"" +
    			"__START_GIT_COMMIT_LOG_MSG__%nrevision: %H%ncommitter: %cn%ndate: %ci%nparent: %P%n%s%n%b%n__END_GIT_COMMIT_LOG_MSG__\"";
String project = args[0];
String logFilename = args[1];
String jdbcUrl = args[2];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
GitLogParser logParser = new GitLogParser(project);
nodeList=node.getElementsByTagName(tag)
NodeList nodeList = node.getElementsByTagName(tag);
Element valueNode = (Element)nodeList.item(0);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
BufferedReader reader = new BufferedReader(new FileReader(file));
String line;
String filename, revision, author, timestampStr;
Timestamp timestamp;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);", flags);
statement=conn.createStatement()
Statement statement = conn.createStatement();
String insertPart = "insert into revisions (project, filename, datetime, revision, userid, logmessage, module, diffUrl) VALUES ";
insertStatement=conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)")
PreparedStatement insertStatement = conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)");
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
StringBuilder bigInsert = new StringBuilder(insertPart);
boolean first = true;
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
String filename = module + parts[1];
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path,project,module)
String fileName = formatFile( path, project, module);
StringBuilder sb = new StringBuilder("update revisions set transactionid = " + transaction + " where fileid in (");
boolean first = true;
st=conn.createStatement()
Statement st = conn.createStatement();
String sql = "select userid, datetime, fileID from revisions where project = '" 
    			+ project + "' and module = '" + module + "' order by userid, datetime asc";
st=conn.createStatement()
Statement st = conn.createStatement();
long timeWindow = 1000 * 60 * 60;
rs=st.getResultSet()
ResultSet rs = st.getResultSet();
String lastUser = null;
String currentUser;
Date lastCommitDate = new Date(0);
Date currentCommitDate;
int transaction = 1;
List<Integer> transactionFileIds = new LinkedList<Integer>();
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionCVSLogParser logParser = new RevisionCVSLogParser();
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
java.util.Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
diffUrl=formatRevisionLink(project,path,revision)
String diffUrl = formatRevisionLink(project, path, revision);
action=fileNode.getAttributes().getNamedItem("action").getTextContent()
String action = fileNode.getAttributes().getNamedItem("action").getTextContent();
String state = "";
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String baseUrl = "http://" + project + ".svn.sourceforge.net/viewvc/" + project;
a=Integer.parseInt(version)
int a = Integer.parseInt(version);
int b = a - 1;
String fileName = path;
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionSVNLogParser logParser = new RevisionSVNLogParser(project, module);
List<ProjectEntry> projects = new ArrayList<ProjectEntry>(100);
int pageNum = projects.size()/10+1;
doc=getDoc("p.xml?page=" + pageNum + "&q=language%3Ajava&sort=users&")
Document doc =getDoc("p.xml?page="+pageNum+"&q=language%3Ajava&sort=users&");
Element resultElement = (Element)element.getElementsByTagName("result").item(0);
projectId=elementIn(projectNode,"id")
String projectId = elementIn(projectNode, "id");
projectName=elementIn(projectNode,"name")
String projectName = elementIn(projectNode, "name");
ProjectEntry p = new ProjectEntry();
boolean complete = false;
int page = 0;
String pageString;
doc=getDoc("p/" + projectId + "/enlistments.xml"+ pageString)
Document doc = getDoc("p/" + projectId+ "/enlistments.xml"+pageString);
itemsReturned=Integer.parseInt(elementIn(response,"items_returned"))
int itemsReturned = Integer.parseInt(elementIn(response, "items_returned"));
itemsAvailable=Integer.parseInt(elementIn(response,"items_available"))
int itemsAvailable = Integer.parseInt(elementIn(response, "items_available"));
firstItemPosition=Integer.parseInt(elementIn(response,"first_item_position"))
int firstItemPosition = Integer.parseInt(elementIn(response, "first_item_position"));
Element resultElement = (Element)response.getElementsByTagName("result").item(0);
type=elementIn(repo,"type")
String type = elementIn(repo, "type");
repoURL=elementIn(repo,"url")
String repoURL = elementIn(repo, "url");
module=elementIn(repo,"module_name")
String module = elementIn(repo, "module_name");
username=elementIn(repo,"username")
String username = elementIn(repo, "username");
password=elementIn(repo,"password")
String password = elementIn(repo, "password");
status=elementIn(repo,"ohloh_job_status")
String status = elementIn(repo, "ohloh_job_status");
Repo r = new Repo(type,repoURL,module,username,password,status);
String pre = "https://www.ohloh.net/";
String post = "api_key=waDryU9cuiDEO64aJLYMA";
URL url = new URL(pre+string+post);
con=url.openConnection()
URLConnection con = url.openConnection();
builder=DocumentBuilderFactory.newInstance().newDocumentBuilder()
DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
doc=builder.parse(con.getInputStream())
Document doc = builder.parse(con.getInputStream());
elem=parent.getElementsByTagName(s)
NodeList elem = parent.getElementsByTagName(s);
StringBuilder sb = new StringBuilder();
Element temp = next;
item=coll.item(pointer++)
Node item = coll.item(pointer++);
wholeText=((Text)item).getWholeText()
String wholeText = ((Text)item).getWholeText();
Element elem = (Element) item;
statusList=element.getElementsByTagName("status")
NodeList statusList = element.getElementsByTagName("status");
statusNode=statusList.item(0)
Node statusNode = statusList.item(0);

Diff of 4adb0d3b0d9d23bfb322bc84ae9edb08ba6a6d9d and af9b4f0346a2349c2369cf16d51689ebf1eff3c2:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 4adb0d3b0d9d23bfb322bc84ae9edb08ba6a6d9d to af9b4f0346a2349c2369cf16d51689ebf1eff3c2


****Parsing for addition at revision af9b4f0346a2349c2369cf16d51689ebf1eff3c2****

Added GetTransactions.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added AnalyzeDeclarations.java to .\generic.tools\ repository source files.
Added GenericDeclVisitor.java to .\generic.tools\ repository source files.
Added Results.java to .\generic.tools\ repository source files.
Added TestVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added CheckoutAll.java to .\generic.tools\ repository source files.
Added TestTimezones.java to .\generic.tools\ repository source files.
Added DevelopersController.2890.java to .\generic.tools\ repository source files.
Added DevelopersController.3838.java to .\generic.tools\ repository source files.
Added AbstractVisitor.java to .\generic.tools\ repository source files.
Added AnnotationVisitor.java to .\generic.tools\ repository source files.
Added CastsVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersAndMethoParametersVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersVisitor.java to .\generic.tools\ repository source files.
Added ContainerGranularity.java to .\generic.tools\ repository source files.
Added HalsteadVisitor.java to .\generic.tools\ repository source files.
Added ParameterizedTypeVisitor.java to .\generic.tools\ repository source files.
Added RawTypesVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added Application.java to .\generic.tools\ repository source files.
Added MyAnnotation.java to .\generic.tools\ repository source files.
Added package-info.java to .\generic.tools\ repository source files.
Added TokenizeServer.java to .\generic.tools\ repository source files.
Added Util.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added AdoptionTiming7_3.java to .\generic.tools\ repository source files.
Added Analysis.java to .\generic.tools\ repository source files.
Added AnalyzeAll.java to .\generic.tools\ repository source files.
Added AnnotationAnalysis.java to .\generic.tools\ repository source files.
Added BasicAnalysis.java to .\generic.tools\ repository source files.
Added BasicMetric.java to .\generic.tools\ repository source files.
Added CastAnalysis.java to .\generic.tools\ repository source files.
Added CastInvestigation.java to .\generic.tools\ repository source files.
Added DeveloperFeatureUsage.java to .\generic.tools\ repository source files.
Added GeneralFeatureUsage.java to .\generic.tools\ repository source files.
Added HalsteadAnalysis.java to .\generic.tools\ repository source files.
Added HalsteadMetric.java to .\generic.tools\ repository source files.
Added MethodClassFeatureUsage.java to .\generic.tools\ repository source files.
Added ParameterizedDeclarationAnalysis.java to .\generic.tools\ repository source files.
Added ParameterizedTypeAnalysis.java to .\generic.tools\ repository source files.
Added RawAnalysis.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added TestFile.java to .\generic.tools\ repository source files.
Added UniqueParamAnalysis.java to .\generic.tools\ repository source files.
Added ExtractMethodFinderPlugin.java to .\generic.tools\ repository source files.
Added FindHeteroAdds.java to .\generic.tools\ repository source files.
Added FindInterestingMethods.java to .\generic.tools\ repository source files.
Added HeteroVisitor.java to .\generic.tools\ repository source files.
Added Variable.java to .\generic.tools\ repository source files.
Added VariableReference.java to .\generic.tools\ repository source files.
Added SubtractFinder.java to .\generic.tools\ repository source files.
Added SuperTypeCollector.java to .\generic.tools\ repository source files.
Added FastRevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added FastRevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GitLogParser.java to .\generic.tools\ repository source files.
Added LogParser.java to .\generic.tools\ repository source files.
Added RevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added RevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GetTop100Projects.java to .\generic.tools\ repository source files.
Added Repo.java to .\generic.tools\ repository source files.
String project = args[0];
String module = args[1];
String jdbcUrl = args[2];
boolean doingGit=false;
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
results=stmt.getResultSet()
ResultSet results = stmt.getResultSet();
files=results.getString("filename")
String files = results.getString("filename");
transId=results.getInt("transactionId")
int transId = results.getInt("transactionId");
datetime=results.getString("datetimestr")
String datetime = results.getString("datetimestr");
state=results.getString("state")
String state = results.getString("state");
revision=results.getString("revision")
String revision = results.getString("revision");
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit)parser.createAST(new NullProgressMonitor());
GenericDeclVisitor v = new GenericDeclVisitor();
TestVisitor test = new TestVisitor();
SimpleType st = (SimpleType)t;
b=st.getName().resolveBinding()
IBinding b = st.getName().resolveBinding();
gb=computeDistanceToDecl(st.getName())
GenericBinding gb = computeDistanceToDecl(st.getName());
bound=((WildcardType)t).getBound()
Type bound = ((WildcardType) t).getBound();
ArrayType at = (ArrayType) t;
QualifiedType qt = (QualifiedType) t;
ASTNode node = sn;
int depth = 0;
targetName=sn.getFullyQualifiedName()
String targetName = sn.getFullyQualifiedName();
TypeParameter tp = (TypeParameter) o;
TypeParameter tp = (TypeParameter) o;
superclassType=td.getSuperclassType()
Type superclassType = td.getSuperclassType();
returnType=md.getReturnType2()
Type returnType = md.getReturnType2();
SingleVariableDeclaration sd = (SingleVariableDeclaration) o;
A a2;
M m2;
A a2;
M m2;
binding=st.resolveBinding()
IBinding binding = st.resolveBinding();
Set<Type> otherCopy = new HashSet<Type>(typesProducedByOtherVisitor);
Set<Type> thisCopy = new HashSet<Type>(found);
List<ProjectInterval> changes = new ArrayList<ProjectInterval>();
activeEditor=targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor()
IEditorPart activeEditor = targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor();
ITextSelection selection = (ITextSelection)((ITextEditor)activeEditor).getSelectionProvider().getSelection();
lines=selection.getText()
String lines = selection.getText();
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S");
str=line.replace("\r","").replace("\n","")
String str = line.replace("\r", "").replace("\n", "");
components=line.split(",")
String[] components = line.split(",");
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
IWorkbenchAdapter adapter = (IWorkbenchAdapter)firstElement;
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
l=((CVSTagElement)firstElement).getRoot()
ICVSRepositoryLocation l = ((CVSTagElement)firstElement).getRoot();
resources=getRemoteResource()
ICVSRemoteResource[] resources = getRemoteResource();
List<CheckoutSingleProjectOperation> checkouts = 
			new LinkedList<CheckoutSingleProjectOperation>();
Job job = new Job("Checking out..."){
			public IStatus run(IProgressMonitor mon){
				
				mon.beginTask("Checking out projects from CVS", checkouts.size());
				
				List<IStatus> status = new ArrayList<IStatus>();
				
				for(CheckoutSingleProjectOperation checkout : checkouts){
					try {
						checkout.execute(new SubProgressMonitor(mon,1));						
						checkForErrors(status,checkout);
					} catch (Exception e) {
						e.printStackTrace();
					}
					 if (mon.isCanceled()) return Status.CANCEL_STATUS;
				}
				
				mon.done();
				
				return new MultiStatus(	Activator.PLUGIN_ID, 
										IStatus.WARNING, 
										status.toArray(new IStatus[0]), 
										"Checkout Warnings", 
										new RuntimeException());
			}

			private void checkForErrors(List<IStatus> existing, CheckoutSingleProjectOperation checkout) throws Exception {
				Method m = CVSOperation.class.getDeclaredMethod("getErrors");
				m.setAccessible(true);
				IStatus[] status = (IStatus[]) m.invoke(checkout);
				for(IStatus s : status){
					existing.add(s);
				}
			}
		};
List<IStatus> status = new ArrayList<IStatus>();
m=CVSOperation.class.getDeclaredMethod("getErrors")
Method m = CVSOperation.class.getDeclaredMethod("getErrors");
IStatus[] status = (IStatus[]) m.invoke(checkout);
Calendar cal = new GregorianCalendar();
Timestamp timestamp = new Timestamp(timeInUTC.getTime()
				+ cal.get(Calendar.DST_OFFSET) + cal.get(Calendar.ZONE_OFFSET)
				+ offset);
projectBefore=remoteFolderAtTime(time)
RemoteFolder projectBefore = remoteFolderAtTime(time);
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss");
String projectName = this.projectName + " " + df.format(time) + " " + resource.getName() + " " + postfix;
newProject=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName)
IProject newProject = ResourcesPlugin.getWorkspace().getRoot().
						getProject(projectName);
Timestamp predaylightSavings = new Timestamp(1172625369000l);
int oneMonthInMillis = 1000*60*60*24*50000000;
Timestamp postDaylightSavings = new Timestamp(1172625369000l+oneMonthInMillis);
Timestamp old = new Timestamp(fromDb.getTime()-60*60*1000*8);
nu=localTime(fromDb)
Timestamp nu = localTime(fromDb);
Calendar cal = new GregorianCalendar();
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList newProps = new ArrayList();
ArrayList replaceProps = new ArrayList();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{new Integer(occurrences),
													          new Integer(occurrencesFound),
																 files[i].getPath() };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[]{new Integer(newProps.size()), new Integer(replaceProps.size()), i18nStringFile.getPath()};
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList linesToPrint = new ArrayList();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList<String> newProps = new ArrayList<String>();
ArrayList<String> replaceProps = new ArrayList<String>();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{
                                        Integer.valueOf(occurrences),
										Integer.valueOf(occurrencesFound),
										files[i].getPath() 
                                    };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[] {
                        Integer.valueOf(newProps.size()), 
                        Integer.valueOf(replaceProps.size()), 
                        i18nStringFile.getPath()
                };
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList<String> linesToPrint = new ArrayList<String>();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator<?> iter = s.iterator();
Iterator<?> iter = s.iterator();
StringBuffer s = new StringBuffer();
int bracketCount = 0;
chars=containerSignature.toCharArray()
char []chars = containerSignature.toCharArray();
parent=input.getParent()
ASTNode parent = input.getParent();
ArrayList<String> names = new ArrayList<String>();
SingleVariableDeclaration param = (SingleVariableDeclaration)method.parameters().get(i);
parent=GetEnclosingContainer(input)
ASTNode parent = GetEnclosingContainer(input);
String name = "ERROR";
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
List<String> values = new ArrayList<String>();
MemberValuePair pair = (MemberValuePair)obj;
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
MethodDeclaration meth = (MethodDeclaration)node;
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
lineNumber=Unit.getLineNumber(cast.getStartPosition())
int lineNumber = Unit.getLineNumber(cast.getStartPosition());
t=cast.getType()
Type t = cast.getType();
parent=GetEnclosingContainerName(cast)
String parent = GetEnclosingContainerName(cast);
lineNumber=Unit.getLineNumber(method.getStartPosition())
int lineNumber = Unit.getLineNumber(method.getStartPosition());
name=method.getName().getFullyQualifiedName()
String name = method.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
binding=type.resolveBinding()
ITypeBinding binding = type.resolveBinding();
ParameterizedType pt = (ParameterizedType) type;
lineNumber=Unit.getLineNumber(pt.getStartPosition())
int lineNumber = Unit.getLineNumber(pt.getStartPosition());
parent=GetEnclosingContainerName(pt)
String parent = GetEnclosingContainerName(pt);
StringBuffer typeArgs = new StringBuffer();
boolean first = true;
String rawTypesString = "BlockingQueue, List, Queue, Set, SortedSet, AbstractCollection, AbstractList, " +
				"AbstractQueue, AbstractSequentialList, AbstractSet, ArrayBlockingQueue, ArrayList, ConcurrentLinkedQueue, " +
				"CopyOnWriteArrayList, CopyOnWriteArraySet, DelayQueue, EnumSet, HashSet, LinkedBlockingQueue, LinkedHashSet, " +
				"LinkedList, PriorityBlockingQueue, PriorityQueue, Stack, SynchronousQueue, TreeSet, Vector, " + 
				"Map, ConcurrentMap, SortedMap, AbstractMap, ConcurrentHashMap, EnumMap, HashMap, Hashtable, IdentityHashMap, " +
				"LinkedHashMap, TreeMap, WeakHashMap";
ParameterizedType pt = (ParameterizedType) type;
o=type.getProperty("typeArguments")
Object o = type.getProperty("typeArguments");
parts=type.toString().split("\\.")
String[] parts = type.toString().split("\\.");
String simpleTypeName = parts[parts.length-1];
lineNumber=sourceNode.getStartPosition()
int lineNumber = sourceNode.getStartPosition();
parent=GetEnclosingContainerName(sourceNode)
String parent = GetEnclosingContainerName(sourceNode);
sp=type.structuralPropertiesForType()
List sp = type.structuralPropertiesForType();
type=node.getReturnType2()
Type type = node.getReturnType2();
SingleVariableDeclaration svd = (SingleVariableDeclaration) o;
type=node.getType()
Type type = node.getType();
String foo;
int a, b = 4, c;
List badList;
String bar = "fred";
List<String> l = new LinkedList<String>();
java.util.Map m;
options=ProcessCommandArgs()
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		int test,test1,test2;
String output = "output.txt";
TokenizeServer server = new TokenizeServer(this);
int port = 6000;
Writer outputWriter = new FileWriter(output);
File dir = new File(options.get("directory"));
path=javaFile.getAbsolutePath()
String path = javaFile.getAbsolutePath();
List<File> files = new LinkedList<File>();
args=Platform.getCommandLineArgs()
String[] args = Platform.getCommandLineArgs();
Hashtable<String,String> options = new Hashtable<String,String>();
String arg = args[i];
BufferedReader r=null;
StringBuffer buffer = new StringBuffer();
String line = null;
buffer=GetFileContents(file)
StringBuffer buffer = GetFileContents(file);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
node=parser.createAST(null)
ASTNode node = parser.createAST(null);
visitor=AbstractVisitor.getVisitor(pattern,output)
AbstractVisitor visitor = AbstractVisitor.getVisitor(pattern, output);
FileWriter writer = null;
int x = (int)3.0f;
T too = null;
T[] array = (T[]) new Object[3];
ArrayList<T> a = new ArrayList<T>();
List<Double> ints = new ArrayList<Double>();
List<Double> nums = ints;
List<Double> nums = ints;
x=ints.get(1)
Number x=ints.get(1);
lineNumber=Unit.getLineNumber(t.getStartPosition())
int lineNumber = Unit.getLineNumber(t.getStartPosition());
lineNumber=Unit.getLineNumber(p.getStartPosition())
int lineNumber = Unit.getLineNumber(p.getStartPosition());
scanner=ToolFactory.createScanner(true,true,false,true)
IScanner scanner = ToolFactory.createScanner(true, true, false, true);
int token = 0;
ServerSocket serverSocket = new ServerSocket(port);
BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
Writer out = new PrintWriter(clientSocket.getOutputStream(), true);
request=reader.readLine()
String request = reader.readLine();
parts[]=request.trim().split(":")
String parts[] = request.trim().split(":");
String filepath = parts[0];
String pattern = parts[1];
ContainerGranularity containerGranularity = ContainerGranularity.FULL;
String args = parts[2];
argParts[]=args.split("=")
String argParts[] = args.split("=");
gran=argParts[1].trim().toLowerCase()
String gran = argParts[1].trim().toLowerCase();
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator iter = s.iterator();
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						"DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
String annotationsQuery = new AnnotationAnalysis(null).query()+", revisions.DateTime";
String typesQuery = new ParameterizedTypeAnalysis(null).query()+", revisions.DateTime";
Hashtable<String,ProjectTiming> timing = new Hashtable<String,ProjectTiming>();
set=s.executeQuery(annotationsQuery)
ResultSet set = s.executeQuery(annotationsQuery);
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
Connection conn = null;
Statement statement = null;
ResultSet results = null;
results=statement.executeQuery(query())
ResultSet results = statement.executeQuery(query());
Map<String,Revision> mostRecentRevision = new HashMap<String, Revision>();
t=e.getKey()
Timestamp t = e.getKey();
String lastProjectName = null;
Revision rev = new Revision();
project=r.getString("revisions.project")
String project = r.getString("revisions.project");
project=projects.get(projectName)
Project project = projects.get(projectName);
revs=project.timeToRevs.get(time)
List<Revision> revs = project.timeToRevs.get(time);
List<Revision> revs = project.timeToRevs.get(time);
String url = "jdbc:mysql://<database>/generics?netTimeoutForStreamingResults=200000";
FileWriter writer = new FileWriter("output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("an_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
int total = 0;
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
revs=getRevisionsFor(timestamp,projectName)
List<Revision> revs = getRevisionsFor(timestamp,projectName);
List<Revision> revs = getRevisionsFor(timestamp,projectName);
int val = 0;
tg=gatherResults()
TimeGraph<CombinedMetric> tg = gatherResults();
TimeGraph<CombinedMetric> tg = gatherResults();
PrintWriter out = new PrintWriter(System.out);
CastReducer cr = new CastReducer(out);
GenericReducer gr = new GenericReducer(out);
HalsteadReducer hr = new HalsteadReducer(out);
TimeGraph<CombinedMetric> tg = new TimeGraph<CombinedMetric>();
project=e.getKey()
String project = e.getKey();
CombinedMetric cm = new CombinedMetric();
map=cr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
map2=gr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
CombinedMetric last = null;
map=totals.get(projectName)
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
castIncrease=subset(projectName,castIncreasePredicate)
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
Random r = new Random();
Set<Timestamp> stamps = new HashSet<Timestamp>();
rand=r.nextInt(castIncrease.size())
int rand = r.nextInt(castIncrease.size());
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
statement=conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?")
PreparedStatement statement = conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?");
rs=statement.executeQuery()
ResultSet rs = statement.executeQuery();
module=rs.getString(1)
String module = rs.getString(1);
next=values.next()
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
metrics=totals.get(projectName)
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
castIncrease=PredicatedSortedMap.decorate(new TreeMap<Timestamp,Metric>(),TruePredicate.INSTANCE,castIncreasePredicate)
@SuppressWarnings("unchecked")
		SortedMap<Timestamp, Metric> castIncrease = PredicatedSortedMap.decorate(new TreeMap<Timestamp, Metric>(), TruePredicate.INSTANCE, castIncreasePredicate);
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,DeveloperData> devInfo = new Hashtable<String,DeveloperData>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
kind=set.getString(paramDecs() + ".kind")
String kind = set.getString(paramDecs()+".kind");
num=set.getString("num")
String num = set.getString("num");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
num=set.getInt("num")
int num = set.getInt("num");
String key = project+"^_^"+userId;
devAnnotations=CalculateAnnotationsDeltas(s)
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
DeveloperData data = new DeveloperData();
Hashtable<String,Integer> developerCount = new Hashtable<String,Integer>();
set=s.executeQuery(annotationsQuery())
ResultSet set = s.executeQuery(annotationsQuery());
Hashtable<String,Integer> fileCount = new Hashtable<String,Integer>();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
module=set.getString("revisions.module")
String module = set.getString("revisions.module");
file=set.getString("revisions.filename")
String file = set.getString("revisions.filename");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
state=set.getString("revisions.state")
String state = set.getString("revisions.state");
String key = project + "." + module + "." + file;
int last = 0;
int delta =  set.getInt("num") - last;
int lastDev = 0;
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
sumMetric=metricFrom(mostRecentRevisions.values())
HalsteadMetric sumMetric = metricFrom(mostRecentRevisions.values());
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
HalsteadMetric m = new HalsteadMetric();
HalsteadMetric sumMetric = new HalsteadMetric();
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
module=set.getString("module")
String module = set.getString("module");
filename=set.getString("filename")
String filename = set.getString("filename");
kind=set.getString("kind")
String kind = set.getString("kind");
classType=set.getString("class_type")
String classType = set.getString("class_type");
typeArgs=set.getString("type_args")
String typeArgs = set.getString("type_args");
String key = module + "." + filename + "." + classType + "." + typeArgs;
FileWriter writer = new FileWriter("pt_output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("raw_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/schoolwork/activity/generics/working_database.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						//"DBQ=C:/Users/Adminuser/Documents/Database2.accdb");
						"DBQ=C:/schoolwork/activity/generics/working_database.accdb");
String url = "jdbc:mysql://<database>:4747/generics?netTimeoutForStreamingResults=200000";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
set=s.executeQuery("SELECT project,baseEncodedAttachment FROM table")
ResultSet set = s.executeQuery("SELECT project,baseEncodedAttachment FROM table");
project=set.getString("project")
String project = set.getString("project");
module=set.getString("baseEncodedAttachment")
String module = set.getString("baseEncodedAttachment");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("proj")
String project = set.getString("proj");
classType=set.getString("class")
String classType = set.getString("class");
HeteroVisitor visitor = new HeteroVisitor(u);
projectName=u.getJavaProject().getElementName()
String projectName = u.getJavaProject().getElementName();
path=u.getResource().getFullPath()
IPath path = u.getResource().getFullPath();
writer=getWriter()
FileWriter writer = getWriter();
superTypes=ref.superTypes()
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
JFileChooser fr = new JFileChooser();
fw=fr.getFileSystemView()
FileSystemView fw = fr.getFileSystemView();
dir=fw.getDefaultDirectory().toString()
String dir = fw.getDefaultDirectory().toString();
FileWriter writer = new FileWriter(dir + "/HeteroAdds.sql", true);
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
unit=unitsToInspect.get(i)
ICompilationUnit unit = unitsToInspect.get(i);
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit) parser
				.createAST(new NullProgressMonitor());
methodName=mi.getName().getIdentifier()
String methodName = mi.getName().getIdentifier();
expression=mi.getExpression()
Expression expression = mi.getExpression();
SimpleName sn = (SimpleName) expression;
binding=sn.resolveBinding()
IBinding binding = sn.resolveBinding();
IVariableBinding varBinding = (IVariableBinding) binding;
type=varBinding.getType()
ITypeBinding type = varBinding.getType();
decl=varBinding.getVariableDeclaration()
IVariableBinding decl = varBinding
								.getVariableDeclaration();
existingTypes=typeInserts.get(decl)
List<Expression> existingTypes = typeInserts.get(decl);
List<Expression> existingTypes = typeInserts.get(decl);
Expression expr = (Expression) mi.arguments().get(0);
List<Bag<String>> superClasses = new LinkedList<Bag<String>>();
Set<String> baseClasses = new HashSet<String>();
iterator=ref.superTypes().entrySet().iterator()
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
int i = 0;
pair=iterator.next()
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Bag<String> potentialsSoFar = new HashBag<String>();
HashMap<String, Integer> superTypes = new HashMap<String, Integer>();
expressionType=expression.resolveTypeBinding()
ITypeBinding expressionType = expression.resolveTypeBinding();
SuperTypeMapSort sortedSuperTypes = new SuperTypeMapSort(superTypes);
SortedMap<String, Integer> sortedMap = new TreeMap<String, Integer>(
				sortedSuperTypes);
binding=expression.resolveTypeBinding()
ITypeBinding binding = expression.resolveTypeBinding();
bindingName=typeBinding.getName()
String bindingName = typeBinding.getName();
List<ITypeBinding> directSupertypes = new ArrayList<ITypeBinding>(
				Arrays.asList(typeBinding.getInterfaces()));
superClass=typeBinding.getSuperclass()
ITypeBinding superClass = typeBinding.getSuperclass();
oldLevel=superTypes.get(bindingName)
Integer oldLevel = superTypes.get(bindingName);
int diff = sort.get(x) - sort.get(y);
ArrayList<String> subtracts = new ArrayList<String>();
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;")
PreparedStatement stmt = conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;");
rs=stmt.executeQuery()
ResultSet rs = stmt.executeQuery();
ArrayList<String> projects = new ArrayList<String>();
String count = "", previous = "";
rsRevisions=stmt.executeQuery()
ResultSet rsRevisions = stmt.executeQuery();
ArrayList<Integer> revisions = new ArrayList<Integer>();
r=rsRevisions.getInt(1)
Integer r = rsRevisions.getInt(1);
rsCount=stmt.executeQuery()
ResultSet rsCount = stmt.executeQuery();
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
ResultSet rs;
projectName=rs.getString("ProjectName")
String projectName = rs.getString("ProjectName");
declType=rs.getString("DeclType")
String declType = rs.getString("DeclType");
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
File dataFile = new File(project + "/" + module + ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(dataFile));
st=conn.createStatement()
Statement st = conn.createStatement();
List<Revision> revisions = new ArrayList<Revision>();
Revision revisionInst = new Revision();
BufferedReader reader = new BufferedReader(new FileReader(file));
String line, path;
String timestampStr;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
long timeWindow = 1000 * 60 * 15;
DateFormat CVSDateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
DateFormat otherCVSDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);", flags);
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
pattern=Pattern.compile("branches:\\s+[0-9.]+;")
Pattern pattern = Pattern.compile("branches:\\s+[0-9.]+;");
matcherLog=pattern.matcher(revisionInst.logMessage)
Matcher matcherLog = pattern.matcher(revisionInst.logMessage);
int transactionId = 1;
Revision r1, r2;
int j;
Hashtable<Integer, List<Revision>> trans = new Hashtable<Integer, List<Revision>>();
List<Transaction> transactions = new ArrayList<Transaction>();
Transaction t = new Transaction(trans.get(id));
int id = 0;
overlaps=FindOverlaps(transactions)
HashSet<Transaction> overlaps = FindOverlaps(transactions);
HashSet<Transaction> overlaps = FindOverlaps(transactions);
overlapSize=overlaps.size()
int overlapSize = overlaps.size();
tempPath=dataFile.getAbsolutePath()
String tempPath = dataFile.getAbsolutePath();
o=c.Parent.HasRevisionWithFile(r.filename)
Revision o = c.Parent.HasRevisionWithFile(r.filename);
oVersion=Integer.parseInt(o.revision.split("[.]")[1])
int oVersion = Integer.parseInt(o.revision.split("[.]")[1]);
rVersion=Integer.parseInt(r.revision.split("[.]")[1])
int rVersion = Integer.parseInt(r.revision.split("[.]")[1]);
HashSet<Transaction> overlaps = new HashSet<Transaction>();
boolean afterStart = t.First().date.compareTo(p.Last().date) < 0;
boolean overlapsStart = p.Last().date.compareTo(t.Last().date) < 0;
boolean beforeEnd = t.Last().date.compareTo(p.First().date) > 0;
boolean overlapsEnd = p.First().date.compareTo(t.First().date) > 0;
String info = t.First().date + " to " + t.Last().date + " overlaps with " + 
					              p.First().date + " to " + p.Last().date;
String nums = t.Id + " " + p.Id;
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
filename=parts[1].replace("/Attic","")
String filename = parts[1].replace("/Attic", "");
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path)
String fileName = formatFile(path);
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
FastRevisionCVSLogParser logParser = new FastRevisionCVSLogParser();
BufferedWriter sqlWriter = new BufferedWriter(new FileWriter(outputBase + ".sql"));
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(outputBase + ".data"));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
String project = args[0];
String logFilename = args[1];
String outputBase = args[2];
FastRevisionSVNLogParser logParser = new FastRevisionSVNLogParser(project);
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
BufferedReader logReader = new BufferedReader(new FileReader(file));
DateFormat gitDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
StringBuilder sb;
String line;
String revision, committer, parent, msg, status, path, diffUrl;
Date dateTime;
String[] parts;
int transaction = 1;
boolean validTransaction = false;
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String logCmd = "git log --reverse --full-history --all --date=iso --name-status -M -C --pretty=format:\"" +
    			"__START_GIT_COMMIT_LOG_MSG__%nrevision: %H%ncommitter: %cn%ndate: %ci%nparent: %P%n%s%n%b%n__END_GIT_COMMIT_LOG_MSG__\"";
String project = args[0];
String logFilename = args[1];
String jdbcUrl = args[2];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
GitLogParser logParser = new GitLogParser(project);
nodeList=node.getElementsByTagName(tag)
NodeList nodeList = node.getElementsByTagName(tag);
Element valueNode = (Element)nodeList.item(0);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
BufferedReader reader = new BufferedReader(new FileReader(file));
String line;
String filename, revision, author, timestampStr;
Timestamp timestamp;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);", flags);
statement=conn.createStatement()
Statement statement = conn.createStatement();
String insertPart = "insert into revisions (project, filename, datetime, revision, userid, logmessage, module, diffUrl) VALUES ";
insertStatement=conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)")
PreparedStatement insertStatement = conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)");
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
StringBuilder bigInsert = new StringBuilder(insertPart);
boolean first = true;
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
String filename = module + parts[1];
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path,project,module)
String fileName = formatFile( path, project, module);
StringBuilder sb = new StringBuilder("update revisions set transactionid = " + transaction + " where fileid in (");
boolean first = true;
st=conn.createStatement()
Statement st = conn.createStatement();
String sql = "select userid, datetime, fileID from revisions where project = '" 
    			+ project + "' and module = '" + module + "' order by userid, datetime asc";
st=conn.createStatement()
Statement st = conn.createStatement();
long timeWindow = 1000 * 60 * 60;
rs=st.getResultSet()
ResultSet rs = st.getResultSet();
String lastUser = null;
String currentUser;
Date lastCommitDate = new Date(0);
Date currentCommitDate;
int transaction = 1;
List<Integer> transactionFileIds = new LinkedList<Integer>();
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionCVSLogParser logParser = new RevisionCVSLogParser();
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
java.util.Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
diffUrl=formatRevisionLink(project,path,revision)
String diffUrl = formatRevisionLink(project, path, revision);
action=fileNode.getAttributes().getNamedItem("action").getTextContent()
String action = fileNode.getAttributes().getNamedItem("action").getTextContent();
String state = "";
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String baseUrl = "http://" + project + ".svn.sourceforge.net/viewvc/" + project;
a=Integer.parseInt(version)
int a = Integer.parseInt(version);
int b = a - 1;
String fileName = path;
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionSVNLogParser logParser = new RevisionSVNLogParser(project, module);
List<ProjectEntry> projects = new ArrayList<ProjectEntry>(100);
int pageNum = projects.size()/10+1;
doc=getDoc("p.xml?page=" + pageNum + "&q=language%3Ajava&sort=users&")
Document doc =getDoc("p.xml?page="+pageNum+"&q=language%3Ajava&sort=users&");
Element resultElement = (Element)element.getElementsByTagName("result").item(0);
projectId=elementIn(projectNode,"id")
String projectId = elementIn(projectNode, "id");
projectName=elementIn(projectNode,"name")
String projectName = elementIn(projectNode, "name");
ProjectEntry p = new ProjectEntry();
boolean complete = false;
int page = 0;
String pageString;
doc=getDoc("p/" + projectId + "/enlistments.xml"+ pageString)
Document doc = getDoc("p/" + projectId+ "/enlistments.xml"+pageString);
itemsReturned=Integer.parseInt(elementIn(response,"items_returned"))
int itemsReturned = Integer.parseInt(elementIn(response, "items_returned"));
itemsAvailable=Integer.parseInt(elementIn(response,"items_available"))
int itemsAvailable = Integer.parseInt(elementIn(response, "items_available"));
firstItemPosition=Integer.parseInt(elementIn(response,"first_item_position"))
int firstItemPosition = Integer.parseInt(elementIn(response, "first_item_position"));
Element resultElement = (Element)response.getElementsByTagName("result").item(0);
type=elementIn(repo,"type")
String type = elementIn(repo, "type");
repoURL=elementIn(repo,"url")
String repoURL = elementIn(repo, "url");
module=elementIn(repo,"module_name")
String module = elementIn(repo, "module_name");
username=elementIn(repo,"username")
String username = elementIn(repo, "username");
password=elementIn(repo,"password")
String password = elementIn(repo, "password");
status=elementIn(repo,"ohloh_job_status")
String status = elementIn(repo, "ohloh_job_status");
Repo r = new Repo(type,repoURL,module,username,password,status);
String pre = "https://www.ohloh.net/";
String post = "api_key=waDryU9cuiDEO64aJLYMA";
URL url = new URL(pre+string+post);
con=url.openConnection()
URLConnection con = url.openConnection();
builder=DocumentBuilderFactory.newInstance().newDocumentBuilder()
DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
doc=builder.parse(con.getInputStream())
Document doc = builder.parse(con.getInputStream());
elem=parent.getElementsByTagName(s)
NodeList elem = parent.getElementsByTagName(s);
StringBuilder sb = new StringBuilder();
Element temp = next;
item=coll.item(pointer++)
Node item = coll.item(pointer++);
wholeText=((Text)item).getWholeText()
String wholeText = ((Text)item).getWholeText();
Element elem = (Element) item;
statusList=element.getElementsByTagName("status")
NodeList statusList = element.getElementsByTagName("status");
statusNode=statusList.item(0)
Node statusNode = statusList.item(0);

Diff of af9b4f0346a2349c2369cf16d51689ebf1eff3c2 and 74523cd98997cbf3bfc95208bee6679d700f7100:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision af9b4f0346a2349c2369cf16d51689ebf1eff3c2 to 74523cd98997cbf3bfc95208bee6679d700f7100


****Parsing for addition at revision 74523cd98997cbf3bfc95208bee6679d700f7100****

Added GetTransactions.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added AnalyzeDeclarations.java to .\generic.tools\ repository source files.
Added GenericDeclVisitor.java to .\generic.tools\ repository source files.
Added Results.java to .\generic.tools\ repository source files.
Added TestVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added CheckoutAll.java to .\generic.tools\ repository source files.
Added TestTimezones.java to .\generic.tools\ repository source files.
Added DevelopersController.2890.java to .\generic.tools\ repository source files.
Added DevelopersController.3838.java to .\generic.tools\ repository source files.
Added AbstractVisitor.java to .\generic.tools\ repository source files.
Added AnnotationVisitor.java to .\generic.tools\ repository source files.
Added CastsVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersAndMethoParametersVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersVisitor.java to .\generic.tools\ repository source files.
Added ContainerGranularity.java to .\generic.tools\ repository source files.
Added HalsteadVisitor.java to .\generic.tools\ repository source files.
Added ParameterizedTypeVisitor.java to .\generic.tools\ repository source files.
Added RawTypesVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added Application.java to .\generic.tools\ repository source files.
Added MyAnnotation.java to .\generic.tools\ repository source files.
Added package-info.java to .\generic.tools\ repository source files.
Added TokenizeServer.java to .\generic.tools\ repository source files.
Added Util.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added AdoptionTiming7_3.java to .\generic.tools\ repository source files.
Added Analysis.java to .\generic.tools\ repository source files.
Added AnalyzeAll.java to .\generic.tools\ repository source files.
Added AnnotationAnalysis.java to .\generic.tools\ repository source files.
Added BasicAnalysis.java to .\generic.tools\ repository source files.
Added BasicMetric.java to .\generic.tools\ repository source files.
Added CastAnalysis.java to .\generic.tools\ repository source files.
Added CastInvestigation.java to .\generic.tools\ repository source files.
Added DeveloperFeatureUsage.java to .\generic.tools\ repository source files.
Added GeneralFeatureUsage.java to .\generic.tools\ repository source files.
Added HalsteadAnalysis.java to .\generic.tools\ repository source files.
Added HalsteadMetric.java to .\generic.tools\ repository source files.
Added MethodClassFeatureUsage.java to .\generic.tools\ repository source files.
Added ParameterizedDeclarationAnalysis.java to .\generic.tools\ repository source files.
Added ParameterizedTypeAnalysis.java to .\generic.tools\ repository source files.
Added RawAnalysis.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added TestFile.java to .\generic.tools\ repository source files.
Added UniqueParamAnalysis.java to .\generic.tools\ repository source files.
Added ExtractMethodFinderPlugin.java to .\generic.tools\ repository source files.
Added FindHeteroAdds.java to .\generic.tools\ repository source files.
Added FindInterestingMethods.java to .\generic.tools\ repository source files.
Added HeteroVisitor.java to .\generic.tools\ repository source files.
Added Variable.java to .\generic.tools\ repository source files.
Added VariableReference.java to .\generic.tools\ repository source files.
Added SubtractFinder.java to .\generic.tools\ repository source files.
Added SuperTypeCollector.java to .\generic.tools\ repository source files.
Added FastRevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added FastRevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GitLogParser.java to .\generic.tools\ repository source files.
Added LogParser.java to .\generic.tools\ repository source files.
Added RevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added RevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GetTop100Projects.java to .\generic.tools\ repository source files.
Added Repo.java to .\generic.tools\ repository source files.
String project = args[0];
String module = args[1];
String jdbcUrl = args[2];
boolean doingGit=false;
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
results=stmt.getResultSet()
ResultSet results = stmt.getResultSet();
files=results.getString("filename")
String files = results.getString("filename");
transId=results.getInt("transactionId")
int transId = results.getInt("transactionId");
datetime=results.getString("datetimestr")
String datetime = results.getString("datetimestr");
state=results.getString("state")
String state = results.getString("state");
revision=results.getString("revision")
String revision = results.getString("revision");
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit)parser.createAST(new NullProgressMonitor());
GenericDeclVisitor v = new GenericDeclVisitor();
TestVisitor test = new TestVisitor();
SimpleType st = (SimpleType)t;
b=st.getName().resolveBinding()
IBinding b = st.getName().resolveBinding();
gb=computeDistanceToDecl(st.getName())
GenericBinding gb = computeDistanceToDecl(st.getName());
bound=((WildcardType)t).getBound()
Type bound = ((WildcardType) t).getBound();
ArrayType at = (ArrayType) t;
QualifiedType qt = (QualifiedType) t;
ASTNode node = sn;
int depth = 0;
targetName=sn.getFullyQualifiedName()
String targetName = sn.getFullyQualifiedName();
TypeParameter tp = (TypeParameter) o;
TypeParameter tp = (TypeParameter) o;
superclassType=td.getSuperclassType()
Type superclassType = td.getSuperclassType();
returnType=md.getReturnType2()
Type returnType = md.getReturnType2();
SingleVariableDeclaration sd = (SingleVariableDeclaration) o;
A a2;
M m2;
A a2;
M m2;
binding=st.resolveBinding()
IBinding binding = st.resolveBinding();
Set<Type> otherCopy = new HashSet<Type>(typesProducedByOtherVisitor);
Set<Type> thisCopy = new HashSet<Type>(found);
List<ProjectInterval> changes = new ArrayList<ProjectInterval>();
activeEditor=targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor()
IEditorPart activeEditor = targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor();
ITextSelection selection = (ITextSelection)((ITextEditor)activeEditor).getSelectionProvider().getSelection();
lines=selection.getText()
String lines = selection.getText();
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S");
str=line.replace("\r","").replace("\n","")
String str = line.replace("\r", "").replace("\n", "");
components=line.split(",")
String[] components = line.split(",");
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
IWorkbenchAdapter adapter = (IWorkbenchAdapter)firstElement;
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
l=((CVSTagElement)firstElement).getRoot()
ICVSRepositoryLocation l = ((CVSTagElement)firstElement).getRoot();
resources=getRemoteResource()
ICVSRemoteResource[] resources = getRemoteResource();
List<CheckoutSingleProjectOperation> checkouts = 
			new LinkedList<CheckoutSingleProjectOperation>();
Job job = new Job("Checking out..."){
			public IStatus run(IProgressMonitor mon){
				
				mon.beginTask("Checking out projects from CVS", checkouts.size());
				
				List<IStatus> status = new ArrayList<IStatus>();
				
				for(CheckoutSingleProjectOperation checkout : checkouts){
					try {
						checkout.execute(new SubProgressMonitor(mon,1));						
						checkForErrors(status,checkout);
					} catch (Exception e) {
						e.printStackTrace();
					}
					 if (mon.isCanceled()) return Status.CANCEL_STATUS;
				}
				
				mon.done();
				
				return new MultiStatus(	Activator.PLUGIN_ID, 
										IStatus.WARNING, 
										status.toArray(new IStatus[0]), 
										"Checkout Warnings", 
										new RuntimeException());
			}

			private void checkForErrors(List<IStatus> existing, CheckoutSingleProjectOperation checkout) throws Exception {
				Method m = CVSOperation.class.getDeclaredMethod("getErrors");
				m.setAccessible(true);
				IStatus[] status = (IStatus[]) m.invoke(checkout);
				for(IStatus s : status){
					existing.add(s);
				}
			}
		};
List<IStatus> status = new ArrayList<IStatus>();
m=CVSOperation.class.getDeclaredMethod("getErrors")
Method m = CVSOperation.class.getDeclaredMethod("getErrors");
IStatus[] status = (IStatus[]) m.invoke(checkout);
Calendar cal = new GregorianCalendar();
Timestamp timestamp = new Timestamp(timeInUTC.getTime()
				+ cal.get(Calendar.DST_OFFSET) + cal.get(Calendar.ZONE_OFFSET)
				+ offset);
projectBefore=remoteFolderAtTime(time)
RemoteFolder projectBefore = remoteFolderAtTime(time);
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss");
String projectName = this.projectName + " " + df.format(time) + " " + resource.getName() + " " + postfix;
newProject=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName)
IProject newProject = ResourcesPlugin.getWorkspace().getRoot().
						getProject(projectName);
Timestamp predaylightSavings = new Timestamp(1172625369000l);
int oneMonthInMillis = 1000*60*60*24*50000000;
Timestamp postDaylightSavings = new Timestamp(1172625369000l+oneMonthInMillis);
Timestamp old = new Timestamp(fromDb.getTime()-60*60*1000*8);
nu=localTime(fromDb)
Timestamp nu = localTime(fromDb);
Calendar cal = new GregorianCalendar();
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList newProps = new ArrayList();
ArrayList replaceProps = new ArrayList();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{new Integer(occurrences),
													          new Integer(occurrencesFound),
																 files[i].getPath() };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[]{new Integer(newProps.size()), new Integer(replaceProps.size()), i18nStringFile.getPath()};
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList linesToPrint = new ArrayList();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList<String> newProps = new ArrayList<String>();
ArrayList<String> replaceProps = new ArrayList<String>();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{
                                        Integer.valueOf(occurrences),
										Integer.valueOf(occurrencesFound),
										files[i].getPath() 
                                    };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[] {
                        Integer.valueOf(newProps.size()), 
                        Integer.valueOf(replaceProps.size()), 
                        i18nStringFile.getPath()
                };
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList<String> linesToPrint = new ArrayList<String>();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator<?> iter = s.iterator();
Iterator<?> iter = s.iterator();
StringBuffer s = new StringBuffer();
int bracketCount = 0;
chars=containerSignature.toCharArray()
char []chars = containerSignature.toCharArray();
parent=input.getParent()
ASTNode parent = input.getParent();
ArrayList<String> names = new ArrayList<String>();
SingleVariableDeclaration param = (SingleVariableDeclaration)method.parameters().get(i);
parent=GetEnclosingContainer(input)
ASTNode parent = GetEnclosingContainer(input);
String name = "ERROR";
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
List<String> values = new ArrayList<String>();
MemberValuePair pair = (MemberValuePair)obj;
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
MethodDeclaration meth = (MethodDeclaration)node;
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
lineNumber=Unit.getLineNumber(cast.getStartPosition())
int lineNumber = Unit.getLineNumber(cast.getStartPosition());
t=cast.getType()
Type t = cast.getType();
parent=GetEnclosingContainerName(cast)
String parent = GetEnclosingContainerName(cast);
lineNumber=Unit.getLineNumber(method.getStartPosition())
int lineNumber = Unit.getLineNumber(method.getStartPosition());
name=method.getName().getFullyQualifiedName()
String name = method.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
binding=type.resolveBinding()
ITypeBinding binding = type.resolveBinding();
ParameterizedType pt = (ParameterizedType) type;
lineNumber=Unit.getLineNumber(pt.getStartPosition())
int lineNumber = Unit.getLineNumber(pt.getStartPosition());
parent=GetEnclosingContainerName(pt)
String parent = GetEnclosingContainerName(pt);
StringBuffer typeArgs = new StringBuffer();
boolean first = true;
String rawTypesString = "BlockingQueue, List, Queue, Set, SortedSet, AbstractCollection, AbstractList, " +
				"AbstractQueue, AbstractSequentialList, AbstractSet, ArrayBlockingQueue, ArrayList, ConcurrentLinkedQueue, " +
				"CopyOnWriteArrayList, CopyOnWriteArraySet, DelayQueue, EnumSet, HashSet, LinkedBlockingQueue, LinkedHashSet, " +
				"LinkedList, PriorityBlockingQueue, PriorityQueue, Stack, SynchronousQueue, TreeSet, Vector, " + 
				"Map, ConcurrentMap, SortedMap, AbstractMap, ConcurrentHashMap, EnumMap, HashMap, Hashtable, IdentityHashMap, " +
				"LinkedHashMap, TreeMap, WeakHashMap";
ParameterizedType pt = (ParameterizedType) type;
o=type.getProperty("typeArguments")
Object o = type.getProperty("typeArguments");
parts=type.toString().split("\\.")
String[] parts = type.toString().split("\\.");
String simpleTypeName = parts[parts.length-1];
lineNumber=sourceNode.getStartPosition()
int lineNumber = sourceNode.getStartPosition();
parent=GetEnclosingContainerName(sourceNode)
String parent = GetEnclosingContainerName(sourceNode);
sp=type.structuralPropertiesForType()
List sp = type.structuralPropertiesForType();
type=node.getReturnType2()
Type type = node.getReturnType2();
SingleVariableDeclaration svd = (SingleVariableDeclaration) o;
type=node.getType()
Type type = node.getType();
String foo;
int a, b = 4, c;
List badList;
String bar = "fred";
List<String> l = new LinkedList<String>();
java.util.Map m;
options=ProcessCommandArgs()
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		int test,test1,test2;
String output = "output.txt";
TokenizeServer server = new TokenizeServer(this);
int port = 6000;
Writer outputWriter = new FileWriter(output);
File dir = new File(options.get("directory"));
path=javaFile.getAbsolutePath()
String path = javaFile.getAbsolutePath();
List<File> files = new LinkedList<File>();
args=Platform.getCommandLineArgs()
String[] args = Platform.getCommandLineArgs();
Hashtable<String,String> options = new Hashtable<String,String>();
String arg = args[i];
BufferedReader r=null;
StringBuffer buffer = new StringBuffer();
String line = null;
buffer=GetFileContents(file)
StringBuffer buffer = GetFileContents(file);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
node=parser.createAST(null)
ASTNode node = parser.createAST(null);
visitor=AbstractVisitor.getVisitor(pattern,output)
AbstractVisitor visitor = AbstractVisitor.getVisitor(pattern, output);
FileWriter writer = null;
int x = (int)3.0f;
T too = null;
T[] array = (T[]) new Object[3];
ArrayList<T> a = new ArrayList<T>();
List<Double> ints = new ArrayList<Double>();
List<Double> nums = ints;
List<Double> nums = ints;
x=ints.get(1)
Number x=ints.get(1);
lineNumber=Unit.getLineNumber(t.getStartPosition())
int lineNumber = Unit.getLineNumber(t.getStartPosition());
lineNumber=Unit.getLineNumber(p.getStartPosition())
int lineNumber = Unit.getLineNumber(p.getStartPosition());
scanner=ToolFactory.createScanner(true,true,false,true)
IScanner scanner = ToolFactory.createScanner(true, true, false, true);
int token = 0;
ServerSocket serverSocket = new ServerSocket(port);
BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
Writer out = new PrintWriter(clientSocket.getOutputStream(), true);
request=reader.readLine()
String request = reader.readLine();
parts[]=request.trim().split(":")
String parts[] = request.trim().split(":");
String filepath = parts[0];
String pattern = parts[1];
ContainerGranularity containerGranularity = ContainerGranularity.FULL;
String args = parts[2];
argParts[]=args.split("=")
String argParts[] = args.split("=");
gran=argParts[1].trim().toLowerCase()
String gran = argParts[1].trim().toLowerCase();
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator iter = s.iterator();
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						"DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
String annotationsQuery = new AnnotationAnalysis(null).query()+", revisions.DateTime";
String typesQuery = new ParameterizedTypeAnalysis(null).query()+", revisions.DateTime";
Hashtable<String,ProjectTiming> timing = new Hashtable<String,ProjectTiming>();
set=s.executeQuery(annotationsQuery)
ResultSet set = s.executeQuery(annotationsQuery);
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
Connection conn = null;
Statement statement = null;
ResultSet results = null;
results=statement.executeQuery(query())
ResultSet results = statement.executeQuery(query());
Map<String,Revision> mostRecentRevision = new HashMap<String, Revision>();
t=e.getKey()
Timestamp t = e.getKey();
String lastProjectName = null;
Revision rev = new Revision();
project=r.getString("revisions.project")
String project = r.getString("revisions.project");
project=projects.get(projectName)
Project project = projects.get(projectName);
revs=project.timeToRevs.get(time)
List<Revision> revs = project.timeToRevs.get(time);
List<Revision> revs = project.timeToRevs.get(time);
String url = "jdbc:mysql://<database>/generics?netTimeoutForStreamingResults=200000";
FileWriter writer = new FileWriter("output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("an_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
int total = 0;
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
revs=getRevisionsFor(timestamp,projectName)
List<Revision> revs = getRevisionsFor(timestamp,projectName);
List<Revision> revs = getRevisionsFor(timestamp,projectName);
int val = 0;
tg=gatherResults()
TimeGraph<CombinedMetric> tg = gatherResults();
TimeGraph<CombinedMetric> tg = gatherResults();
PrintWriter out = new PrintWriter(System.out);
CastReducer cr = new CastReducer(out);
GenericReducer gr = new GenericReducer(out);
HalsteadReducer hr = new HalsteadReducer(out);
TimeGraph<CombinedMetric> tg = new TimeGraph<CombinedMetric>();
project=e.getKey()
String project = e.getKey();
CombinedMetric cm = new CombinedMetric();
map=cr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
map2=gr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
CombinedMetric last = null;
map=totals.get(projectName)
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
castIncrease=subset(projectName,castIncreasePredicate)
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
Random r = new Random();
Set<Timestamp> stamps = new HashSet<Timestamp>();
rand=r.nextInt(castIncrease.size())
int rand = r.nextInt(castIncrease.size());
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
statement=conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?")
PreparedStatement statement = conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?");
rs=statement.executeQuery()
ResultSet rs = statement.executeQuery();
module=rs.getString(1)
String module = rs.getString(1);
next=values.next()
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
metrics=totals.get(projectName)
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
castIncrease=PredicatedSortedMap.decorate(new TreeMap<Timestamp,Metric>(),TruePredicate.INSTANCE,castIncreasePredicate)
@SuppressWarnings("unchecked")
		SortedMap<Timestamp, Metric> castIncrease = PredicatedSortedMap.decorate(new TreeMap<Timestamp, Metric>(), TruePredicate.INSTANCE, castIncreasePredicate);
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,DeveloperData> devInfo = new Hashtable<String,DeveloperData>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
kind=set.getString(paramDecs() + ".kind")
String kind = set.getString(paramDecs()+".kind");
num=set.getString("num")
String num = set.getString("num");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
num=set.getInt("num")
int num = set.getInt("num");
String key = project+"^_^"+userId;
devAnnotations=CalculateAnnotationsDeltas(s)
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
DeveloperData data = new DeveloperData();
Hashtable<String,Integer> developerCount = new Hashtable<String,Integer>();
set=s.executeQuery(annotationsQuery())
ResultSet set = s.executeQuery(annotationsQuery());
Hashtable<String,Integer> fileCount = new Hashtable<String,Integer>();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
module=set.getString("revisions.module")
String module = set.getString("revisions.module");
file=set.getString("revisions.filename")
String file = set.getString("revisions.filename");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
state=set.getString("revisions.state")
String state = set.getString("revisions.state");
String key = project + "." + module + "." + file;
int last = 0;
int delta =  set.getInt("num") - last;
int lastDev = 0;
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
sumMetric=metricFrom(mostRecentRevisions.values())
HalsteadMetric sumMetric = metricFrom(mostRecentRevisions.values());
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
HalsteadMetric m = new HalsteadMetric();
HalsteadMetric sumMetric = new HalsteadMetric();
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
module=set.getString("module")
String module = set.getString("module");
filename=set.getString("filename")
String filename = set.getString("filename");
kind=set.getString("kind")
String kind = set.getString("kind");
classType=set.getString("class_type")
String classType = set.getString("class_type");
typeArgs=set.getString("type_args")
String typeArgs = set.getString("type_args");
String key = module + "." + filename + "." + classType + "." + typeArgs;
FileWriter writer = new FileWriter("pt_output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("raw_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/schoolwork/activity/generics/working_database.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						//"DBQ=C:/Users/Adminuser/Documents/Database2.accdb");
						"DBQ=C:/schoolwork/activity/generics/working_database.accdb");
String url = "jdbc:mysql://<database>:4747/generics?netTimeoutForStreamingResults=200000";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
set=s.executeQuery("SELECT project,baseEncodedAttachment FROM table")
ResultSet set = s.executeQuery("SELECT project,baseEncodedAttachment FROM table");
project=set.getString("project")
String project = set.getString("project");
module=set.getString("baseEncodedAttachment")
String module = set.getString("baseEncodedAttachment");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("proj")
String project = set.getString("proj");
classType=set.getString("class")
String classType = set.getString("class");
HeteroVisitor visitor = new HeteroVisitor(u);
projectName=u.getJavaProject().getElementName()
String projectName = u.getJavaProject().getElementName();
path=u.getResource().getFullPath()
IPath path = u.getResource().getFullPath();
writer=getWriter()
FileWriter writer = getWriter();
superTypes=ref.superTypes()
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
JFileChooser fr = new JFileChooser();
fw=fr.getFileSystemView()
FileSystemView fw = fr.getFileSystemView();
dir=fw.getDefaultDirectory().toString()
String dir = fw.getDefaultDirectory().toString();
FileWriter writer = new FileWriter(dir + "/HeteroAdds.sql", true);
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
unit=unitsToInspect.get(i)
ICompilationUnit unit = unitsToInspect.get(i);
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit) parser
				.createAST(new NullProgressMonitor());
methodName=mi.getName().getIdentifier()
String methodName = mi.getName().getIdentifier();
expression=mi.getExpression()
Expression expression = mi.getExpression();
SimpleName sn = (SimpleName) expression;
binding=sn.resolveBinding()
IBinding binding = sn.resolveBinding();
IVariableBinding varBinding = (IVariableBinding) binding;
type=varBinding.getType()
ITypeBinding type = varBinding.getType();
decl=varBinding.getVariableDeclaration()
IVariableBinding decl = varBinding
								.getVariableDeclaration();
existingTypes=typeInserts.get(decl)
List<Expression> existingTypes = typeInserts.get(decl);
List<Expression> existingTypes = typeInserts.get(decl);
Expression expr = (Expression) mi.arguments().get(0);
List<Bag<String>> superClasses = new LinkedList<Bag<String>>();
Set<String> baseClasses = new HashSet<String>();
iterator=ref.superTypes().entrySet().iterator()
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
int i = 0;
pair=iterator.next()
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Bag<String> potentialsSoFar = new HashBag<String>();
HashMap<String, Integer> superTypes = new HashMap<String, Integer>();
expressionType=expression.resolveTypeBinding()
ITypeBinding expressionType = expression.resolveTypeBinding();
SuperTypeMapSort sortedSuperTypes = new SuperTypeMapSort(superTypes);
SortedMap<String, Integer> sortedMap = new TreeMap<String, Integer>(
				sortedSuperTypes);
binding=expression.resolveTypeBinding()
ITypeBinding binding = expression.resolveTypeBinding();
bindingName=typeBinding.getName()
String bindingName = typeBinding.getName();
List<ITypeBinding> directSupertypes = new ArrayList<ITypeBinding>(
				Arrays.asList(typeBinding.getInterfaces()));
superClass=typeBinding.getSuperclass()
ITypeBinding superClass = typeBinding.getSuperclass();
oldLevel=superTypes.get(bindingName)
Integer oldLevel = superTypes.get(bindingName);
int diff = sort.get(x) - sort.get(y);
ArrayList<String> subtracts = new ArrayList<String>();
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;")
PreparedStatement stmt = conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;");
rs=stmt.executeQuery()
ResultSet rs = stmt.executeQuery();
ArrayList<String> projects = new ArrayList<String>();
String count = "", previous = "";
rsRevisions=stmt.executeQuery()
ResultSet rsRevisions = stmt.executeQuery();
ArrayList<Integer> revisions = new ArrayList<Integer>();
r=rsRevisions.getInt(1)
Integer r = rsRevisions.getInt(1);
rsCount=stmt.executeQuery()
ResultSet rsCount = stmt.executeQuery();
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
ResultSet rs;
projectName=rs.getString("ProjectName")
String projectName = rs.getString("ProjectName");
declType=rs.getString("DeclType")
String declType = rs.getString("DeclType");
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
File dataFile = new File(project + "/" + module + ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(dataFile));
st=conn.createStatement()
Statement st = conn.createStatement();
List<Revision> revisions = new ArrayList<Revision>();
Revision revisionInst = new Revision();
BufferedReader reader = new BufferedReader(new FileReader(file));
String line, path;
String timestampStr;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
long timeWindow = 1000 * 60 * 15;
DateFormat CVSDateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
DateFormat otherCVSDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);", flags);
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
pattern=Pattern.compile("branches:\\s+[0-9.]+;")
Pattern pattern = Pattern.compile("branches:\\s+[0-9.]+;");
matcherLog=pattern.matcher(revisionInst.logMessage)
Matcher matcherLog = pattern.matcher(revisionInst.logMessage);
int transactionId = 1;
Revision r1, r2;
int j;
Hashtable<Integer, List<Revision>> trans = new Hashtable<Integer, List<Revision>>();
List<Transaction> transactions = new ArrayList<Transaction>();
Transaction t = new Transaction(trans.get(id));
int id = 0;
overlaps=FindOverlaps(transactions)
HashSet<Transaction> overlaps = FindOverlaps(transactions);
HashSet<Transaction> overlaps = FindOverlaps(transactions);
overlapSize=overlaps.size()
int overlapSize = overlaps.size();
tempPath=dataFile.getAbsolutePath()
String tempPath = dataFile.getAbsolutePath();
o=c.Parent.HasRevisionWithFile(r.filename)
Revision o = c.Parent.HasRevisionWithFile(r.filename);
oVersion=Integer.parseInt(o.revision.split("[.]")[1])
int oVersion = Integer.parseInt(o.revision.split("[.]")[1]);
rVersion=Integer.parseInt(r.revision.split("[.]")[1])
int rVersion = Integer.parseInt(r.revision.split("[.]")[1]);
HashSet<Transaction> overlaps = new HashSet<Transaction>();
boolean afterStart = t.First().date.compareTo(p.Last().date) < 0;
boolean overlapsStart = p.Last().date.compareTo(t.Last().date) < 0;
boolean beforeEnd = t.Last().date.compareTo(p.First().date) > 0;
boolean overlapsEnd = p.First().date.compareTo(t.First().date) > 0;
String info = t.First().date + " to " + t.Last().date + " overlaps with " + 
					              p.First().date + " to " + p.Last().date;
String nums = t.Id + " " + p.Id;
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
filename=parts[1].replace("/Attic","")
String filename = parts[1].replace("/Attic", "");
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path)
String fileName = formatFile(path);
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
FastRevisionCVSLogParser logParser = new FastRevisionCVSLogParser();
BufferedWriter sqlWriter = new BufferedWriter(new FileWriter(outputBase + ".sql"));
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(outputBase + ".data"));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
String project = args[0];
String logFilename = args[1];
String outputBase = args[2];
FastRevisionSVNLogParser logParser = new FastRevisionSVNLogParser(project);
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
BufferedReader logReader = new BufferedReader(new FileReader(file));
DateFormat gitDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
StringBuilder sb;
String line;
String revision, committer, parent, msg, status, path, diffUrl;
Date dateTime;
String[] parts;
int transaction = 1;
boolean validTransaction = false;
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String logCmd = "git log --reverse --full-history --all --date=iso --name-status -M -C --pretty=format:\"" +
    			"__START_GIT_COMMIT_LOG_MSG__%nrevision: %H%ncommitter: %cn%ndate: %ci%nparent: %P%n%s%n%b%n__END_GIT_COMMIT_LOG_MSG__\"";
String project = args[0];
String logFilename = args[1];
String jdbcUrl = args[2];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
GitLogParser logParser = new GitLogParser(project);
nodeList=node.getElementsByTagName(tag)
NodeList nodeList = node.getElementsByTagName(tag);
Element valueNode = (Element)nodeList.item(0);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
BufferedReader reader = new BufferedReader(new FileReader(file));
String line;
String filename, revision, author, timestampStr;
Timestamp timestamp;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);", flags);
statement=conn.createStatement()
Statement statement = conn.createStatement();
String insertPart = "insert into revisions (project, filename, datetime, revision, userid, logmessage, module, diffUrl) VALUES ";
insertStatement=conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)")
PreparedStatement insertStatement = conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)");
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
StringBuilder bigInsert = new StringBuilder(insertPart);
boolean first = true;
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
String filename = module + parts[1];
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path,project,module)
String fileName = formatFile( path, project, module);
StringBuilder sb = new StringBuilder("update revisions set transactionid = " + transaction + " where fileid in (");
boolean first = true;
st=conn.createStatement()
Statement st = conn.createStatement();
String sql = "select userid, datetime, fileID from revisions where project = '" 
    			+ project + "' and module = '" + module + "' order by userid, datetime asc";
st=conn.createStatement()
Statement st = conn.createStatement();
long timeWindow = 1000 * 60 * 60;
rs=st.getResultSet()
ResultSet rs = st.getResultSet();
String lastUser = null;
String currentUser;
Date lastCommitDate = new Date(0);
Date currentCommitDate;
int transaction = 1;
List<Integer> transactionFileIds = new LinkedList<Integer>();
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionCVSLogParser logParser = new RevisionCVSLogParser();
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
java.util.Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
diffUrl=formatRevisionLink(project,path,revision)
String diffUrl = formatRevisionLink(project, path, revision);
action=fileNode.getAttributes().getNamedItem("action").getTextContent()
String action = fileNode.getAttributes().getNamedItem("action").getTextContent();
String state = "";
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String baseUrl = "http://" + project + ".svn.sourceforge.net/viewvc/" + project;
a=Integer.parseInt(version)
int a = Integer.parseInt(version);
int b = a - 1;
String fileName = path;
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionSVNLogParser logParser = new RevisionSVNLogParser(project, module);
List<ProjectEntry> projects = new ArrayList<ProjectEntry>(100);
int pageNum = projects.size()/10+1;
doc=getDoc("p.xml?page=" + pageNum + "&q=language%3Ajava&sort=users&")
Document doc =getDoc("p.xml?page="+pageNum+"&q=language%3Ajava&sort=users&");
Element resultElement = (Element)element.getElementsByTagName("result").item(0);
projectId=elementIn(projectNode,"id")
String projectId = elementIn(projectNode, "id");
projectName=elementIn(projectNode,"name")
String projectName = elementIn(projectNode, "name");
ProjectEntry p = new ProjectEntry();
boolean complete = false;
int page = 0;
String pageString;
doc=getDoc("p/" + projectId + "/enlistments.xml"+ pageString)
Document doc = getDoc("p/" + projectId+ "/enlistments.xml"+pageString);
itemsReturned=Integer.parseInt(elementIn(response,"items_returned"))
int itemsReturned = Integer.parseInt(elementIn(response, "items_returned"));
itemsAvailable=Integer.parseInt(elementIn(response,"items_available"))
int itemsAvailable = Integer.parseInt(elementIn(response, "items_available"));
firstItemPosition=Integer.parseInt(elementIn(response,"first_item_position"))
int firstItemPosition = Integer.parseInt(elementIn(response, "first_item_position"));
Element resultElement = (Element)response.getElementsByTagName("result").item(0);
type=elementIn(repo,"type")
String type = elementIn(repo, "type");
repoURL=elementIn(repo,"url")
String repoURL = elementIn(repo, "url");
module=elementIn(repo,"module_name")
String module = elementIn(repo, "module_name");
username=elementIn(repo,"username")
String username = elementIn(repo, "username");
password=elementIn(repo,"password")
String password = elementIn(repo, "password");
status=elementIn(repo,"ohloh_job_status")
String status = elementIn(repo, "ohloh_job_status");
Repo r = new Repo(type,repoURL,module,username,password,status);
String pre = "https://www.ohloh.net/";
String post = "api_key=waDryU9cuiDEO64aJLYMA";
URL url = new URL(pre+string+post);
con=url.openConnection()
URLConnection con = url.openConnection();
builder=DocumentBuilderFactory.newInstance().newDocumentBuilder()
DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
doc=builder.parse(con.getInputStream())
Document doc = builder.parse(con.getInputStream());
elem=parent.getElementsByTagName(s)
NodeList elem = parent.getElementsByTagName(s);
StringBuilder sb = new StringBuilder();
Element temp = next;
item=coll.item(pointer++)
Node item = coll.item(pointer++);
wholeText=((Text)item).getWholeText()
String wholeText = ((Text)item).getWholeText();
Element elem = (Element) item;
statusList=element.getElementsByTagName("status")
NodeList statusList = element.getElementsByTagName("status");
statusNode=statusList.item(0)
Node statusNode = statusList.item(0);

Diff of 74523cd98997cbf3bfc95208bee6679d700f7100 and 4d51040f764a85fd22c9477b48373f3ebd4d6609:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 74523cd98997cbf3bfc95208bee6679d700f7100 to 4d51040f764a85fd22c9477b48373f3ebd4d6609


****Parsing for addition at revision 4d51040f764a85fd22c9477b48373f3ebd4d6609****

Added GetTransactions.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added AnalyzeDeclarations.java to .\generic.tools\ repository source files.
Added GenericDeclVisitor.java to .\generic.tools\ repository source files.
Added Results.java to .\generic.tools\ repository source files.
Added TestVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added CheckoutAll.java to .\generic.tools\ repository source files.
Added TestTimezones.java to .\generic.tools\ repository source files.
Added DevelopersController.2890.java to .\generic.tools\ repository source files.
Added DevelopersController.3838.java to .\generic.tools\ repository source files.
Added AbstractVisitor.java to .\generic.tools\ repository source files.
Added AnnotationVisitor.java to .\generic.tools\ repository source files.
Added CastsVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersAndMethoParametersVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersVisitor.java to .\generic.tools\ repository source files.
Added ContainerGranularity.java to .\generic.tools\ repository source files.
Added HalsteadVisitor.java to .\generic.tools\ repository source files.
Added ParameterizedTypeVisitor.java to .\generic.tools\ repository source files.
Added RawTypesVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added Application.java to .\generic.tools\ repository source files.
Added MyAnnotation.java to .\generic.tools\ repository source files.
Added package-info.java to .\generic.tools\ repository source files.
Added TokenizeServer.java to .\generic.tools\ repository source files.
Added Util.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added AdoptionTiming7_3.java to .\generic.tools\ repository source files.
Added Analysis.java to .\generic.tools\ repository source files.
Added AnalyzeAll.java to .\generic.tools\ repository source files.
Added AnnotationAnalysis.java to .\generic.tools\ repository source files.
Added BasicAnalysis.java to .\generic.tools\ repository source files.
Added BasicMetric.java to .\generic.tools\ repository source files.
Added CastAnalysis.java to .\generic.tools\ repository source files.
Added CastInvestigation.java to .\generic.tools\ repository source files.
Added DeveloperFeatureUsage.java to .\generic.tools\ repository source files.
Added GeneralFeatureUsage.java to .\generic.tools\ repository source files.
Added HalsteadAnalysis.java to .\generic.tools\ repository source files.
Added HalsteadMetric.java to .\generic.tools\ repository source files.
Added MethodClassFeatureUsage.java to .\generic.tools\ repository source files.
Added ParameterizedDeclarationAnalysis.java to .\generic.tools\ repository source files.
Added ParameterizedTypeAnalysis.java to .\generic.tools\ repository source files.
Added RawAnalysis.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added TestFile.java to .\generic.tools\ repository source files.
Added UniqueParamAnalysis.java to .\generic.tools\ repository source files.
Added ExtractMethodFinderPlugin.java to .\generic.tools\ repository source files.
Added FindHeteroAdds.java to .\generic.tools\ repository source files.
Added FindInterestingMethods.java to .\generic.tools\ repository source files.
Added HeteroVisitor.java to .\generic.tools\ repository source files.
Added Variable.java to .\generic.tools\ repository source files.
Added VariableReference.java to .\generic.tools\ repository source files.
Added SubtractFinder.java to .\generic.tools\ repository source files.
Added SuperTypeCollector.java to .\generic.tools\ repository source files.
Added FastRevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added FastRevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GitLogParser.java to .\generic.tools\ repository source files.
Added LogParser.java to .\generic.tools\ repository source files.
Added RevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added RevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GetTop100Projects.java to .\generic.tools\ repository source files.
Added Repo.java to .\generic.tools\ repository source files.
String project = args[0];
String module = args[1];
String jdbcUrl = args[2];
boolean doingGit=false;
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
results=stmt.getResultSet()
ResultSet results = stmt.getResultSet();
files=results.getString("filename")
String files = results.getString("filename");
transId=results.getInt("transactionId")
int transId = results.getInt("transactionId");
datetime=results.getString("datetimestr")
String datetime = results.getString("datetimestr");
state=results.getString("state")
String state = results.getString("state");
revision=results.getString("revision")
String revision = results.getString("revision");
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit)parser.createAST(new NullProgressMonitor());
GenericDeclVisitor v = new GenericDeclVisitor();
TestVisitor test = new TestVisitor();
SimpleType st = (SimpleType)t;
b=st.getName().resolveBinding()
IBinding b = st.getName().resolveBinding();
gb=computeDistanceToDecl(st.getName())
GenericBinding gb = computeDistanceToDecl(st.getName());
bound=((WildcardType)t).getBound()
Type bound = ((WildcardType) t).getBound();
ArrayType at = (ArrayType) t;
QualifiedType qt = (QualifiedType) t;
ASTNode node = sn;
int depth = 0;
targetName=sn.getFullyQualifiedName()
String targetName = sn.getFullyQualifiedName();
TypeParameter tp = (TypeParameter) o;
TypeParameter tp = (TypeParameter) o;
superclassType=td.getSuperclassType()
Type superclassType = td.getSuperclassType();
returnType=md.getReturnType2()
Type returnType = md.getReturnType2();
SingleVariableDeclaration sd = (SingleVariableDeclaration) o;
A a2;
M m2;
A a2;
M m2;
binding=st.resolveBinding()
IBinding binding = st.resolveBinding();
Set<Type> otherCopy = new HashSet<Type>(typesProducedByOtherVisitor);
Set<Type> thisCopy = new HashSet<Type>(found);
List<ProjectInterval> changes = new ArrayList<ProjectInterval>();
activeEditor=targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor()
IEditorPart activeEditor = targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor();
ITextSelection selection = (ITextSelection)((ITextEditor)activeEditor).getSelectionProvider().getSelection();
lines=selection.getText()
String lines = selection.getText();
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S");
str=line.replace("\r","").replace("\n","")
String str = line.replace("\r", "").replace("\n", "");
components=line.split(",")
String[] components = line.split(",");
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
IWorkbenchAdapter adapter = (IWorkbenchAdapter)firstElement;
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
l=((CVSTagElement)firstElement).getRoot()
ICVSRepositoryLocation l = ((CVSTagElement)firstElement).getRoot();
resources=getRemoteResource()
ICVSRemoteResource[] resources = getRemoteResource();
List<CheckoutSingleProjectOperation> checkouts = 
			new LinkedList<CheckoutSingleProjectOperation>();
Job job = new Job("Checking out..."){
			public IStatus run(IProgressMonitor mon){
				
				mon.beginTask("Checking out projects from CVS", checkouts.size());
				
				List<IStatus> status = new ArrayList<IStatus>();
				
				for(CheckoutSingleProjectOperation checkout : checkouts){
					try {
						checkout.execute(new SubProgressMonitor(mon,1));						
						checkForErrors(status,checkout);
					} catch (Exception e) {
						e.printStackTrace();
					}
					 if (mon.isCanceled()) return Status.CANCEL_STATUS;
				}
				
				mon.done();
				
				return new MultiStatus(	Activator.PLUGIN_ID, 
										IStatus.WARNING, 
										status.toArray(new IStatus[0]), 
										"Checkout Warnings", 
										new RuntimeException());
			}

			private void checkForErrors(List<IStatus> existing, CheckoutSingleProjectOperation checkout) throws Exception {
				Method m = CVSOperation.class.getDeclaredMethod("getErrors");
				m.setAccessible(true);
				IStatus[] status = (IStatus[]) m.invoke(checkout);
				for(IStatus s : status){
					existing.add(s);
				}
			}
		};
List<IStatus> status = new ArrayList<IStatus>();
m=CVSOperation.class.getDeclaredMethod("getErrors")
Method m = CVSOperation.class.getDeclaredMethod("getErrors");
IStatus[] status = (IStatus[]) m.invoke(checkout);
Calendar cal = new GregorianCalendar();
Timestamp timestamp = new Timestamp(timeInUTC.getTime()
				+ cal.get(Calendar.DST_OFFSET) + cal.get(Calendar.ZONE_OFFSET)
				+ offset);
projectBefore=remoteFolderAtTime(time)
RemoteFolder projectBefore = remoteFolderAtTime(time);
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss");
String projectName = this.projectName + " " + df.format(time) + " " + resource.getName() + " " + postfix;
newProject=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName)
IProject newProject = ResourcesPlugin.getWorkspace().getRoot().
						getProject(projectName);
Timestamp predaylightSavings = new Timestamp(1172625369000l);
int oneMonthInMillis = 1000*60*60*24*50000000;
Timestamp postDaylightSavings = new Timestamp(1172625369000l+oneMonthInMillis);
Timestamp old = new Timestamp(fromDb.getTime()-60*60*1000*8);
nu=localTime(fromDb)
Timestamp nu = localTime(fromDb);
Calendar cal = new GregorianCalendar();
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList newProps = new ArrayList();
ArrayList replaceProps = new ArrayList();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{new Integer(occurrences),
													          new Integer(occurrencesFound),
																 files[i].getPath() };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[]{new Integer(newProps.size()), new Integer(replaceProps.size()), i18nStringFile.getPath()};
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList linesToPrint = new ArrayList();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList<String> newProps = new ArrayList<String>();
ArrayList<String> replaceProps = new ArrayList<String>();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{
                                        Integer.valueOf(occurrences),
										Integer.valueOf(occurrencesFound),
										files[i].getPath() 
                                    };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[] {
                        Integer.valueOf(newProps.size()), 
                        Integer.valueOf(replaceProps.size()), 
                        i18nStringFile.getPath()
                };
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList<String> linesToPrint = new ArrayList<String>();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator<?> iter = s.iterator();
Iterator<?> iter = s.iterator();
StringBuffer s = new StringBuffer();
int bracketCount = 0;
chars=containerSignature.toCharArray()
char []chars = containerSignature.toCharArray();
parent=input.getParent()
ASTNode parent = input.getParent();
ArrayList<String> names = new ArrayList<String>();
SingleVariableDeclaration param = (SingleVariableDeclaration)method.parameters().get(i);
parent=GetEnclosingContainer(input)
ASTNode parent = GetEnclosingContainer(input);
String name = "ERROR";
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
List<String> values = new ArrayList<String>();
MemberValuePair pair = (MemberValuePair)obj;
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
MethodDeclaration meth = (MethodDeclaration)node;
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
lineNumber=Unit.getLineNumber(cast.getStartPosition())
int lineNumber = Unit.getLineNumber(cast.getStartPosition());
t=cast.getType()
Type t = cast.getType();
parent=GetEnclosingContainerName(cast)
String parent = GetEnclosingContainerName(cast);
lineNumber=Unit.getLineNumber(method.getStartPosition())
int lineNumber = Unit.getLineNumber(method.getStartPosition());
name=method.getName().getFullyQualifiedName()
String name = method.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
binding=type.resolveBinding()
ITypeBinding binding = type.resolveBinding();
ParameterizedType pt = (ParameterizedType) type;
lineNumber=Unit.getLineNumber(pt.getStartPosition())
int lineNumber = Unit.getLineNumber(pt.getStartPosition());
parent=GetEnclosingContainerName(pt)
String parent = GetEnclosingContainerName(pt);
StringBuffer typeArgs = new StringBuffer();
boolean first = true;
String rawTypesString = "BlockingQueue, List, Queue, Set, SortedSet, AbstractCollection, AbstractList, " +
				"AbstractQueue, AbstractSequentialList, AbstractSet, ArrayBlockingQueue, ArrayList, ConcurrentLinkedQueue, " +
				"CopyOnWriteArrayList, CopyOnWriteArraySet, DelayQueue, EnumSet, HashSet, LinkedBlockingQueue, LinkedHashSet, " +
				"LinkedList, PriorityBlockingQueue, PriorityQueue, Stack, SynchronousQueue, TreeSet, Vector, " + 
				"Map, ConcurrentMap, SortedMap, AbstractMap, ConcurrentHashMap, EnumMap, HashMap, Hashtable, IdentityHashMap, " +
				"LinkedHashMap, TreeMap, WeakHashMap";
ParameterizedType pt = (ParameterizedType) type;
o=type.getProperty("typeArguments")
Object o = type.getProperty("typeArguments");
parts=type.toString().split("\\.")
String[] parts = type.toString().split("\\.");
String simpleTypeName = parts[parts.length-1];
lineNumber=sourceNode.getStartPosition()
int lineNumber = sourceNode.getStartPosition();
parent=GetEnclosingContainerName(sourceNode)
String parent = GetEnclosingContainerName(sourceNode);
sp=type.structuralPropertiesForType()
List sp = type.structuralPropertiesForType();
type=node.getReturnType2()
Type type = node.getReturnType2();
SingleVariableDeclaration svd = (SingleVariableDeclaration) o;
type=node.getType()
Type type = node.getType();
String foo;
int a, b = 4, c;
List badList;
String bar = "fred";
List<String> l = new LinkedList<String>();
java.util.Map m;
options=ProcessCommandArgs()
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		int test,test1,test2;
String output = "output.txt";
TokenizeServer server = new TokenizeServer(this);
int port = 6000;
Writer outputWriter = new FileWriter(output);
File dir = new File(options.get("directory"));
path=javaFile.getAbsolutePath()
String path = javaFile.getAbsolutePath();
List<File> files = new LinkedList<File>();
args=Platform.getCommandLineArgs()
String[] args = Platform.getCommandLineArgs();
Hashtable<String,String> options = new Hashtable<String,String>();
String arg = args[i];
BufferedReader r=null;
StringBuffer buffer = new StringBuffer();
String line = null;
buffer=GetFileContents(file)
StringBuffer buffer = GetFileContents(file);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
node=parser.createAST(null)
ASTNode node = parser.createAST(null);
visitor=AbstractVisitor.getVisitor(pattern,output)
AbstractVisitor visitor = AbstractVisitor.getVisitor(pattern, output);
FileWriter writer = null;
int x = (int)3.0f;
T too = null;
T[] array = (T[]) new Object[3];
ArrayList<T> a = new ArrayList<T>();
List<Double> ints = new ArrayList<Double>();
List<Double> nums = ints;
List<Double> nums = ints;
x=ints.get(1)
Number x=ints.get(1);
lineNumber=Unit.getLineNumber(t.getStartPosition())
int lineNumber = Unit.getLineNumber(t.getStartPosition());
lineNumber=Unit.getLineNumber(p.getStartPosition())
int lineNumber = Unit.getLineNumber(p.getStartPosition());
scanner=ToolFactory.createScanner(true,true,false,true)
IScanner scanner = ToolFactory.createScanner(true, true, false, true);
int token = 0;
ServerSocket serverSocket = new ServerSocket(port);
BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
Writer out = new PrintWriter(clientSocket.getOutputStream(), true);
request=reader.readLine()
String request = reader.readLine();
parts[]=request.trim().split(":")
String parts[] = request.trim().split(":");
String filepath = parts[0];
String pattern = parts[1];
ContainerGranularity containerGranularity = ContainerGranularity.FULL;
String args = parts[2];
argParts[]=args.split("=")
String argParts[] = args.split("=");
gran=argParts[1].trim().toLowerCase()
String gran = argParts[1].trim().toLowerCase();
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator iter = s.iterator();
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						"DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
String annotationsQuery = new AnnotationAnalysis(null).query()+", revisions.DateTime";
String typesQuery = new ParameterizedTypeAnalysis(null).query()+", revisions.DateTime";
Hashtable<String,ProjectTiming> timing = new Hashtable<String,ProjectTiming>();
set=s.executeQuery(annotationsQuery)
ResultSet set = s.executeQuery(annotationsQuery);
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
Connection conn = null;
Statement statement = null;
ResultSet results = null;
results=statement.executeQuery(query())
ResultSet results = statement.executeQuery(query());
Map<String,Revision> mostRecentRevision = new HashMap<String, Revision>();
t=e.getKey()
Timestamp t = e.getKey();
String lastProjectName = null;
Revision rev = new Revision();
project=r.getString("revisions.project")
String project = r.getString("revisions.project");
project=projects.get(projectName)
Project project = projects.get(projectName);
revs=project.timeToRevs.get(time)
List<Revision> revs = project.timeToRevs.get(time);
List<Revision> revs = project.timeToRevs.get(time);
String url = "jdbc:mysql://<database>/generics?netTimeoutForStreamingResults=200000";
FileWriter writer = new FileWriter("output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("an_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
int total = 0;
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
revs=getRevisionsFor(timestamp,projectName)
List<Revision> revs = getRevisionsFor(timestamp,projectName);
List<Revision> revs = getRevisionsFor(timestamp,projectName);
int val = 0;
tg=gatherResults()
TimeGraph<CombinedMetric> tg = gatherResults();
TimeGraph<CombinedMetric> tg = gatherResults();
PrintWriter out = new PrintWriter(System.out);
CastReducer cr = new CastReducer(out);
GenericReducer gr = new GenericReducer(out);
HalsteadReducer hr = new HalsteadReducer(out);
TimeGraph<CombinedMetric> tg = new TimeGraph<CombinedMetric>();
project=e.getKey()
String project = e.getKey();
CombinedMetric cm = new CombinedMetric();
map=cr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
map2=gr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
CombinedMetric last = null;
map=totals.get(projectName)
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
castIncrease=subset(projectName,castIncreasePredicate)
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
Random r = new Random();
Set<Timestamp> stamps = new HashSet<Timestamp>();
rand=r.nextInt(castIncrease.size())
int rand = r.nextInt(castIncrease.size());
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
statement=conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?")
PreparedStatement statement = conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?");
rs=statement.executeQuery()
ResultSet rs = statement.executeQuery();
module=rs.getString(1)
String module = rs.getString(1);
next=values.next()
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
metrics=totals.get(projectName)
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
castIncrease=PredicatedSortedMap.decorate(new TreeMap<Timestamp,Metric>(),TruePredicate.INSTANCE,castIncreasePredicate)
@SuppressWarnings("unchecked")
		SortedMap<Timestamp, Metric> castIncrease = PredicatedSortedMap.decorate(new TreeMap<Timestamp, Metric>(), TruePredicate.INSTANCE, castIncreasePredicate);
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,DeveloperData> devInfo = new Hashtable<String,DeveloperData>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
kind=set.getString(paramDecs() + ".kind")
String kind = set.getString(paramDecs()+".kind");
num=set.getString("num")
String num = set.getString("num");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
num=set.getInt("num")
int num = set.getInt("num");
String key = project+"^_^"+userId;
devAnnotations=CalculateAnnotationsDeltas(s)
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
DeveloperData data = new DeveloperData();
Hashtable<String,Integer> developerCount = new Hashtable<String,Integer>();
set=s.executeQuery(annotationsQuery())
ResultSet set = s.executeQuery(annotationsQuery());
Hashtable<String,Integer> fileCount = new Hashtable<String,Integer>();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
module=set.getString("revisions.module")
String module = set.getString("revisions.module");
file=set.getString("revisions.filename")
String file = set.getString("revisions.filename");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
state=set.getString("revisions.state")
String state = set.getString("revisions.state");
String key = project + "." + module + "." + file;
int last = 0;
int delta =  set.getInt("num") - last;
int lastDev = 0;
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
sumMetric=metricFrom(mostRecentRevisions.values())
HalsteadMetric sumMetric = metricFrom(mostRecentRevisions.values());
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
HalsteadMetric m = new HalsteadMetric();
HalsteadMetric sumMetric = new HalsteadMetric();
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
module=set.getString("module")
String module = set.getString("module");
filename=set.getString("filename")
String filename = set.getString("filename");
kind=set.getString("kind")
String kind = set.getString("kind");
classType=set.getString("class_type")
String classType = set.getString("class_type");
typeArgs=set.getString("type_args")
String typeArgs = set.getString("type_args");
String key = module + "." + filename + "." + classType + "." + typeArgs;
FileWriter writer = new FileWriter("pt_output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("raw_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/schoolwork/activity/generics/working_database.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						//"DBQ=C:/Users/Adminuser/Documents/Database2.accdb");
						"DBQ=C:/schoolwork/activity/generics/working_database.accdb");
String url = "jdbc:mysql://<database>:4747/generics?netTimeoutForStreamingResults=200000";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
set=s.executeQuery("SELECT project,baseEncodedAttachment FROM table")
ResultSet set = s.executeQuery("SELECT project,baseEncodedAttachment FROM table");
project=set.getString("project")
String project = set.getString("project");
module=set.getString("baseEncodedAttachment")
String module = set.getString("baseEncodedAttachment");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("proj")
String project = set.getString("proj");
classType=set.getString("class")
String classType = set.getString("class");
HeteroVisitor visitor = new HeteroVisitor(u);
projectName=u.getJavaProject().getElementName()
String projectName = u.getJavaProject().getElementName();
path=u.getResource().getFullPath()
IPath path = u.getResource().getFullPath();
writer=getWriter()
FileWriter writer = getWriter();
superTypes=ref.superTypes()
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
JFileChooser fr = new JFileChooser();
fw=fr.getFileSystemView()
FileSystemView fw = fr.getFileSystemView();
dir=fw.getDefaultDirectory().toString()
String dir = fw.getDefaultDirectory().toString();
FileWriter writer = new FileWriter(dir + "/HeteroAdds.sql", true);
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
unit=unitsToInspect.get(i)
ICompilationUnit unit = unitsToInspect.get(i);
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit) parser
				.createAST(new NullProgressMonitor());
methodName=mi.getName().getIdentifier()
String methodName = mi.getName().getIdentifier();
expression=mi.getExpression()
Expression expression = mi.getExpression();
SimpleName sn = (SimpleName) expression;
binding=sn.resolveBinding()
IBinding binding = sn.resolveBinding();
IVariableBinding varBinding = (IVariableBinding) binding;
type=varBinding.getType()
ITypeBinding type = varBinding.getType();
decl=varBinding.getVariableDeclaration()
IVariableBinding decl = varBinding
								.getVariableDeclaration();
existingTypes=typeInserts.get(decl)
List<Expression> existingTypes = typeInserts.get(decl);
List<Expression> existingTypes = typeInserts.get(decl);
Expression expr = (Expression) mi.arguments().get(0);
List<Bag<String>> superClasses = new LinkedList<Bag<String>>();
Set<String> baseClasses = new HashSet<String>();
iterator=ref.superTypes().entrySet().iterator()
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
int i = 0;
pair=iterator.next()
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Bag<String> potentialsSoFar = new HashBag<String>();
HashMap<String, Integer> superTypes = new HashMap<String, Integer>();
expressionType=expression.resolveTypeBinding()
ITypeBinding expressionType = expression.resolveTypeBinding();
SuperTypeMapSort sortedSuperTypes = new SuperTypeMapSort(superTypes);
SortedMap<String, Integer> sortedMap = new TreeMap<String, Integer>(
				sortedSuperTypes);
binding=expression.resolveTypeBinding()
ITypeBinding binding = expression.resolveTypeBinding();
bindingName=typeBinding.getName()
String bindingName = typeBinding.getName();
List<ITypeBinding> directSupertypes = new ArrayList<ITypeBinding>(
				Arrays.asList(typeBinding.getInterfaces()));
superClass=typeBinding.getSuperclass()
ITypeBinding superClass = typeBinding.getSuperclass();
oldLevel=superTypes.get(bindingName)
Integer oldLevel = superTypes.get(bindingName);
int diff = sort.get(x) - sort.get(y);
ArrayList<String> subtracts = new ArrayList<String>();
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;")
PreparedStatement stmt = conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;");
rs=stmt.executeQuery()
ResultSet rs = stmt.executeQuery();
ArrayList<String> projects = new ArrayList<String>();
String count = "", previous = "";
rsRevisions=stmt.executeQuery()
ResultSet rsRevisions = stmt.executeQuery();
ArrayList<Integer> revisions = new ArrayList<Integer>();
r=rsRevisions.getInt(1)
Integer r = rsRevisions.getInt(1);
rsCount=stmt.executeQuery()
ResultSet rsCount = stmt.executeQuery();
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
ResultSet rs;
projectName=rs.getString("ProjectName")
String projectName = rs.getString("ProjectName");
declType=rs.getString("DeclType")
String declType = rs.getString("DeclType");
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
File dataFile = new File(project + "/" + module + ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(dataFile));
st=conn.createStatement()
Statement st = conn.createStatement();
List<Revision> revisions = new ArrayList<Revision>();
Revision revisionInst = new Revision();
BufferedReader reader = new BufferedReader(new FileReader(file));
String line, path;
String timestampStr;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
long timeWindow = 1000 * 60 * 15;
DateFormat CVSDateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
DateFormat otherCVSDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);", flags);
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
pattern=Pattern.compile("branches:\\s+[0-9.]+;")
Pattern pattern = Pattern.compile("branches:\\s+[0-9.]+;");
matcherLog=pattern.matcher(revisionInst.logMessage)
Matcher matcherLog = pattern.matcher(revisionInst.logMessage);
int transactionId = 1;
Revision r1, r2;
int j;
Hashtable<Integer, List<Revision>> trans = new Hashtable<Integer, List<Revision>>();
List<Transaction> transactions = new ArrayList<Transaction>();
Transaction t = new Transaction(trans.get(id));
int id = 0;
overlaps=FindOverlaps(transactions)
HashSet<Transaction> overlaps = FindOverlaps(transactions);
HashSet<Transaction> overlaps = FindOverlaps(transactions);
overlapSize=overlaps.size()
int overlapSize = overlaps.size();
tempPath=dataFile.getAbsolutePath()
String tempPath = dataFile.getAbsolutePath();
o=c.Parent.HasRevisionWithFile(r.filename)
Revision o = c.Parent.HasRevisionWithFile(r.filename);
oVersion=Integer.parseInt(o.revision.split("[.]")[1])
int oVersion = Integer.parseInt(o.revision.split("[.]")[1]);
rVersion=Integer.parseInt(r.revision.split("[.]")[1])
int rVersion = Integer.parseInt(r.revision.split("[.]")[1]);
HashSet<Transaction> overlaps = new HashSet<Transaction>();
boolean afterStart = t.First().date.compareTo(p.Last().date) < 0;
boolean overlapsStart = p.Last().date.compareTo(t.Last().date) < 0;
boolean beforeEnd = t.Last().date.compareTo(p.First().date) > 0;
boolean overlapsEnd = p.First().date.compareTo(t.First().date) > 0;
String info = t.First().date + " to " + t.Last().date + " overlaps with " + 
					              p.First().date + " to " + p.Last().date;
String nums = t.Id + " " + p.Id;
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
filename=parts[1].replace("/Attic","")
String filename = parts[1].replace("/Attic", "");
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path)
String fileName = formatFile(path);
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
FastRevisionCVSLogParser logParser = new FastRevisionCVSLogParser();
BufferedWriter sqlWriter = new BufferedWriter(new FileWriter(outputBase + ".sql"));
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(outputBase + ".data"));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
String project = args[0];
String logFilename = args[1];
String outputBase = args[2];
FastRevisionSVNLogParser logParser = new FastRevisionSVNLogParser(project);
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
BufferedReader logReader = new BufferedReader(new FileReader(file));
DateFormat gitDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
StringBuilder sb;
String line;
String revision, committer, parent, msg, status, path, diffUrl;
Date dateTime;
String[] parts;
int transaction = 1;
boolean validTransaction = false;
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String logCmd = "git log --reverse --full-history --all --date=iso --name-status -M -C --pretty=format:\"" +
    			"__START_GIT_COMMIT_LOG_MSG__%nrevision: %H%ncommitter: %cn%ndate: %ci%nparent: %P%n%s%n%b%n__END_GIT_COMMIT_LOG_MSG__\"";
String project = args[0];
String logFilename = args[1];
String jdbcUrl = args[2];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
GitLogParser logParser = new GitLogParser(project);
nodeList=node.getElementsByTagName(tag)
NodeList nodeList = node.getElementsByTagName(tag);
Element valueNode = (Element)nodeList.item(0);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
BufferedReader reader = new BufferedReader(new FileReader(file));
String line;
String filename, revision, author, timestampStr;
Timestamp timestamp;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);", flags);
statement=conn.createStatement()
Statement statement = conn.createStatement();
String insertPart = "insert into revisions (project, filename, datetime, revision, userid, logmessage, module, diffUrl) VALUES ";
insertStatement=conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)")
PreparedStatement insertStatement = conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)");
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
StringBuilder bigInsert = new StringBuilder(insertPart);
boolean first = true;
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
String filename = module + parts[1];
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path,project,module)
String fileName = formatFile( path, project, module);
StringBuilder sb = new StringBuilder("update revisions set transactionid = " + transaction + " where fileid in (");
boolean first = true;
st=conn.createStatement()
Statement st = conn.createStatement();
String sql = "select userid, datetime, fileID from revisions where project = '" 
    			+ project + "' and module = '" + module + "' order by userid, datetime asc";
st=conn.createStatement()
Statement st = conn.createStatement();
long timeWindow = 1000 * 60 * 60;
rs=st.getResultSet()
ResultSet rs = st.getResultSet();
String lastUser = null;
String currentUser;
Date lastCommitDate = new Date(0);
Date currentCommitDate;
int transaction = 1;
List<Integer> transactionFileIds = new LinkedList<Integer>();
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionCVSLogParser logParser = new RevisionCVSLogParser();
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
java.util.Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
diffUrl=formatRevisionLink(project,path,revision)
String diffUrl = formatRevisionLink(project, path, revision);
action=fileNode.getAttributes().getNamedItem("action").getTextContent()
String action = fileNode.getAttributes().getNamedItem("action").getTextContent();
String state = "";
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String baseUrl = "http://" + project + ".svn.sourceforge.net/viewvc/" + project;
a=Integer.parseInt(version)
int a = Integer.parseInt(version);
int b = a - 1;
String fileName = path;
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionSVNLogParser logParser = new RevisionSVNLogParser(project, module);
List<ProjectEntry> projects = new ArrayList<ProjectEntry>(100);
int pageNum = projects.size()/10+1;
doc=getDoc("p.xml?page=" + pageNum + "&q=language%3Ajava&sort=users&")
Document doc =getDoc("p.xml?page="+pageNum+"&q=language%3Ajava&sort=users&");
Element resultElement = (Element)element.getElementsByTagName("result").item(0);
projectId=elementIn(projectNode,"id")
String projectId = elementIn(projectNode, "id");
projectName=elementIn(projectNode,"name")
String projectName = elementIn(projectNode, "name");
ProjectEntry p = new ProjectEntry();
boolean complete = false;
int page = 0;
String pageString;
doc=getDoc("p/" + projectId + "/enlistments.xml"+ pageString)
Document doc = getDoc("p/" + projectId+ "/enlistments.xml"+pageString);
itemsReturned=Integer.parseInt(elementIn(response,"items_returned"))
int itemsReturned = Integer.parseInt(elementIn(response, "items_returned"));
itemsAvailable=Integer.parseInt(elementIn(response,"items_available"))
int itemsAvailable = Integer.parseInt(elementIn(response, "items_available"));
firstItemPosition=Integer.parseInt(elementIn(response,"first_item_position"))
int firstItemPosition = Integer.parseInt(elementIn(response, "first_item_position"));
Element resultElement = (Element)response.getElementsByTagName("result").item(0);
type=elementIn(repo,"type")
String type = elementIn(repo, "type");
repoURL=elementIn(repo,"url")
String repoURL = elementIn(repo, "url");
module=elementIn(repo,"module_name")
String module = elementIn(repo, "module_name");
username=elementIn(repo,"username")
String username = elementIn(repo, "username");
password=elementIn(repo,"password")
String password = elementIn(repo, "password");
status=elementIn(repo,"ohloh_job_status")
String status = elementIn(repo, "ohloh_job_status");
Repo r = new Repo(type,repoURL,module,username,password,status);
String pre = "https://www.ohloh.net/";
String post = "api_key=waDryU9cuiDEO64aJLYMA";
URL url = new URL(pre+string+post);
con=url.openConnection()
URLConnection con = url.openConnection();
builder=DocumentBuilderFactory.newInstance().newDocumentBuilder()
DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
doc=builder.parse(con.getInputStream())
Document doc = builder.parse(con.getInputStream());
elem=parent.getElementsByTagName(s)
NodeList elem = parent.getElementsByTagName(s);
StringBuilder sb = new StringBuilder();
Element temp = next;
item=coll.item(pointer++)
Node item = coll.item(pointer++);
wholeText=((Text)item).getWholeText()
String wholeText = ((Text)item).getWholeText();
Element elem = (Element) item;
statusList=element.getElementsByTagName("status")
NodeList statusList = element.getElementsByTagName("status");
statusNode=statusList.item(0)
Node statusNode = statusList.item(0);

Diff of 4d51040f764a85fd22c9477b48373f3ebd4d6609 and 873112ed1310d709618bdc808c0496cefc485dd0:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 4d51040f764a85fd22c9477b48373f3ebd4d6609 to 873112ed1310d709618bdc808c0496cefc485dd0


****Parsing for addition at revision 873112ed1310d709618bdc808c0496cefc485dd0****

Added GetTransactions.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added AnalyzeDeclarations.java to .\generic.tools\ repository source files.
Added GenericDeclVisitor.java to .\generic.tools\ repository source files.
Added Results.java to .\generic.tools\ repository source files.
Added TestVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added CheckoutAll.java to .\generic.tools\ repository source files.
Added TestTimezones.java to .\generic.tools\ repository source files.
Added DevelopersController.2890.java to .\generic.tools\ repository source files.
Added DevelopersController.3838.java to .\generic.tools\ repository source files.
Added AbstractVisitor.java to .\generic.tools\ repository source files.
Added AnnotationVisitor.java to .\generic.tools\ repository source files.
Added CastsVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersAndMethoParametersVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersVisitor.java to .\generic.tools\ repository source files.
Added ContainerGranularity.java to .\generic.tools\ repository source files.
Added HalsteadVisitor.java to .\generic.tools\ repository source files.
Added ParameterizedTypeVisitor.java to .\generic.tools\ repository source files.
Added RawTypesVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added Application.java to .\generic.tools\ repository source files.
Added MyAnnotation.java to .\generic.tools\ repository source files.
Added package-info.java to .\generic.tools\ repository source files.
Added TokenizeServer.java to .\generic.tools\ repository source files.
Added Util.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added AdoptionTiming7_3.java to .\generic.tools\ repository source files.
Added Analysis.java to .\generic.tools\ repository source files.
Added AnalyzeAll.java to .\generic.tools\ repository source files.
Added AnnotationAnalysis.java to .\generic.tools\ repository source files.
Added BasicAnalysis.java to .\generic.tools\ repository source files.
Added BasicMetric.java to .\generic.tools\ repository source files.
Added CastAnalysis.java to .\generic.tools\ repository source files.
Added CastInvestigation.java to .\generic.tools\ repository source files.
Added DeveloperFeatureUsage.java to .\generic.tools\ repository source files.
Added GeneralFeatureUsage.java to .\generic.tools\ repository source files.
Added HalsteadAnalysis.java to .\generic.tools\ repository source files.
Added HalsteadMetric.java to .\generic.tools\ repository source files.
Added MethodClassFeatureUsage.java to .\generic.tools\ repository source files.
Added ParameterizedDeclarationAnalysis.java to .\generic.tools\ repository source files.
Added ParameterizedTypeAnalysis.java to .\generic.tools\ repository source files.
Added RawAnalysis.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added TestFile.java to .\generic.tools\ repository source files.
Added UniqueParamAnalysis.java to .\generic.tools\ repository source files.
Added ExtractMethodFinderPlugin.java to .\generic.tools\ repository source files.
Added FindHeteroAdds.java to .\generic.tools\ repository source files.
Added FindInterestingMethods.java to .\generic.tools\ repository source files.
Added HeteroVisitor.java to .\generic.tools\ repository source files.
Added Variable.java to .\generic.tools\ repository source files.
Added VariableReference.java to .\generic.tools\ repository source files.
Added SubtractFinder.java to .\generic.tools\ repository source files.
Added SuperTypeCollector.java to .\generic.tools\ repository source files.
Added FastRevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added FastRevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GitLogParser.java to .\generic.tools\ repository source files.
Added LogParser.java to .\generic.tools\ repository source files.
Added RevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added RevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GetTop100Projects.java to .\generic.tools\ repository source files.
Added Repo.java to .\generic.tools\ repository source files.
String project = args[0];
String module = args[1];
String jdbcUrl = args[2];
boolean doingGit=false;
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
results=stmt.getResultSet()
ResultSet results = stmt.getResultSet();
files=results.getString("filename")
String files = results.getString("filename");
transId=results.getInt("transactionId")
int transId = results.getInt("transactionId");
datetime=results.getString("datetimestr")
String datetime = results.getString("datetimestr");
state=results.getString("state")
String state = results.getString("state");
revision=results.getString("revision")
String revision = results.getString("revision");
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit)parser.createAST(new NullProgressMonitor());
GenericDeclVisitor v = new GenericDeclVisitor();
TestVisitor test = new TestVisitor();
SimpleType st = (SimpleType)t;
b=st.getName().resolveBinding()
IBinding b = st.getName().resolveBinding();
gb=computeDistanceToDecl(st.getName())
GenericBinding gb = computeDistanceToDecl(st.getName());
bound=((WildcardType)t).getBound()
Type bound = ((WildcardType) t).getBound();
ArrayType at = (ArrayType) t;
QualifiedType qt = (QualifiedType) t;
ASTNode node = sn;
int depth = 0;
targetName=sn.getFullyQualifiedName()
String targetName = sn.getFullyQualifiedName();
TypeParameter tp = (TypeParameter) o;
TypeParameter tp = (TypeParameter) o;
superclassType=td.getSuperclassType()
Type superclassType = td.getSuperclassType();
returnType=md.getReturnType2()
Type returnType = md.getReturnType2();
SingleVariableDeclaration sd = (SingleVariableDeclaration) o;
A a2;
M m2;
A a2;
M m2;
binding=st.resolveBinding()
IBinding binding = st.resolveBinding();
Set<Type> otherCopy = new HashSet<Type>(typesProducedByOtherVisitor);
Set<Type> thisCopy = new HashSet<Type>(found);
List<ProjectInterval> changes = new ArrayList<ProjectInterval>();
activeEditor=targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor()
IEditorPart activeEditor = targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor();
ITextSelection selection = (ITextSelection)((ITextEditor)activeEditor).getSelectionProvider().getSelection();
lines=selection.getText()
String lines = selection.getText();
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S");
str=line.replace("\r","").replace("\n","")
String str = line.replace("\r", "").replace("\n", "");
components=line.split(",")
String[] components = line.split(",");
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
IWorkbenchAdapter adapter = (IWorkbenchAdapter)firstElement;
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
l=((CVSTagElement)firstElement).getRoot()
ICVSRepositoryLocation l = ((CVSTagElement)firstElement).getRoot();
resources=getRemoteResource()
ICVSRemoteResource[] resources = getRemoteResource();
List<CheckoutSingleProjectOperation> checkouts = 
			new LinkedList<CheckoutSingleProjectOperation>();
Job job = new Job("Checking out..."){
			public IStatus run(IProgressMonitor mon){
				
				mon.beginTask("Checking out projects from CVS", checkouts.size());
				
				List<IStatus> status = new ArrayList<IStatus>();
				
				for(CheckoutSingleProjectOperation checkout : checkouts){
					try {
						checkout.execute(new SubProgressMonitor(mon,1));						
						checkForErrors(status,checkout);
					} catch (Exception e) {
						e.printStackTrace();
					}
					 if (mon.isCanceled()) return Status.CANCEL_STATUS;
				}
				
				mon.done();
				
				return new MultiStatus(	Activator.PLUGIN_ID, 
										IStatus.WARNING, 
										status.toArray(new IStatus[0]), 
										"Checkout Warnings", 
										new RuntimeException());
			}

			private void checkForErrors(List<IStatus> existing, CheckoutSingleProjectOperation checkout) throws Exception {
				Method m = CVSOperation.class.getDeclaredMethod("getErrors");
				m.setAccessible(true);
				IStatus[] status = (IStatus[]) m.invoke(checkout);
				for(IStatus s : status){
					existing.add(s);
				}
			}
		};
List<IStatus> status = new ArrayList<IStatus>();
m=CVSOperation.class.getDeclaredMethod("getErrors")
Method m = CVSOperation.class.getDeclaredMethod("getErrors");
IStatus[] status = (IStatus[]) m.invoke(checkout);
Calendar cal = new GregorianCalendar();
Timestamp timestamp = new Timestamp(timeInUTC.getTime()
				+ cal.get(Calendar.DST_OFFSET) + cal.get(Calendar.ZONE_OFFSET)
				+ offset);
projectBefore=remoteFolderAtTime(time)
RemoteFolder projectBefore = remoteFolderAtTime(time);
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss");
String projectName = this.projectName + " " + df.format(time) + " " + resource.getName() + " " + postfix;
newProject=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName)
IProject newProject = ResourcesPlugin.getWorkspace().getRoot().
						getProject(projectName);
Timestamp predaylightSavings = new Timestamp(1172625369000l);
int oneMonthInMillis = 1000*60*60*24*50000000;
Timestamp postDaylightSavings = new Timestamp(1172625369000l+oneMonthInMillis);
Timestamp old = new Timestamp(fromDb.getTime()-60*60*1000*8);
nu=localTime(fromDb)
Timestamp nu = localTime(fromDb);
Calendar cal = new GregorianCalendar();
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList newProps = new ArrayList();
ArrayList replaceProps = new ArrayList();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{new Integer(occurrences),
													          new Integer(occurrencesFound),
																 files[i].getPath() };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[]{new Integer(newProps.size()), new Integer(replaceProps.size()), i18nStringFile.getPath()};
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList linesToPrint = new ArrayList();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList<String> newProps = new ArrayList<String>();
ArrayList<String> replaceProps = new ArrayList<String>();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{
                                        Integer.valueOf(occurrences),
										Integer.valueOf(occurrencesFound),
										files[i].getPath() 
                                    };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[] {
                        Integer.valueOf(newProps.size()), 
                        Integer.valueOf(replaceProps.size()), 
                        i18nStringFile.getPath()
                };
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList<String> linesToPrint = new ArrayList<String>();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator<?> iter = s.iterator();
Iterator<?> iter = s.iterator();
StringBuffer s = new StringBuffer();
int bracketCount = 0;
chars=containerSignature.toCharArray()
char []chars = containerSignature.toCharArray();
parent=input.getParent()
ASTNode parent = input.getParent();
ArrayList<String> names = new ArrayList<String>();
SingleVariableDeclaration param = (SingleVariableDeclaration)method.parameters().get(i);
parent=GetEnclosingContainer(input)
ASTNode parent = GetEnclosingContainer(input);
String name = "ERROR";
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
List<String> values = new ArrayList<String>();
MemberValuePair pair = (MemberValuePair)obj;
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
MethodDeclaration meth = (MethodDeclaration)node;
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
lineNumber=Unit.getLineNumber(cast.getStartPosition())
int lineNumber = Unit.getLineNumber(cast.getStartPosition());
t=cast.getType()
Type t = cast.getType();
parent=GetEnclosingContainerName(cast)
String parent = GetEnclosingContainerName(cast);
lineNumber=Unit.getLineNumber(method.getStartPosition())
int lineNumber = Unit.getLineNumber(method.getStartPosition());
name=method.getName().getFullyQualifiedName()
String name = method.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
binding=type.resolveBinding()
ITypeBinding binding = type.resolveBinding();
ParameterizedType pt = (ParameterizedType) type;
lineNumber=Unit.getLineNumber(pt.getStartPosition())
int lineNumber = Unit.getLineNumber(pt.getStartPosition());
parent=GetEnclosingContainerName(pt)
String parent = GetEnclosingContainerName(pt);
StringBuffer typeArgs = new StringBuffer();
boolean first = true;
String rawTypesString = "BlockingQueue, List, Queue, Set, SortedSet, AbstractCollection, AbstractList, " +
				"AbstractQueue, AbstractSequentialList, AbstractSet, ArrayBlockingQueue, ArrayList, ConcurrentLinkedQueue, " +
				"CopyOnWriteArrayList, CopyOnWriteArraySet, DelayQueue, EnumSet, HashSet, LinkedBlockingQueue, LinkedHashSet, " +
				"LinkedList, PriorityBlockingQueue, PriorityQueue, Stack, SynchronousQueue, TreeSet, Vector, " + 
				"Map, ConcurrentMap, SortedMap, AbstractMap, ConcurrentHashMap, EnumMap, HashMap, Hashtable, IdentityHashMap, " +
				"LinkedHashMap, TreeMap, WeakHashMap";
ParameterizedType pt = (ParameterizedType) type;
o=type.getProperty("typeArguments")
Object o = type.getProperty("typeArguments");
parts=type.toString().split("\\.")
String[] parts = type.toString().split("\\.");
String simpleTypeName = parts[parts.length-1];
lineNumber=sourceNode.getStartPosition()
int lineNumber = sourceNode.getStartPosition();
parent=GetEnclosingContainerName(sourceNode)
String parent = GetEnclosingContainerName(sourceNode);
sp=type.structuralPropertiesForType()
List sp = type.structuralPropertiesForType();
type=node.getReturnType2()
Type type = node.getReturnType2();
SingleVariableDeclaration svd = (SingleVariableDeclaration) o;
type=node.getType()
Type type = node.getType();
String foo;
int a, b = 4, c;
List badList;
String bar = "fred";
List<String> l = new LinkedList<String>();
java.util.Map m;
options=ProcessCommandArgs()
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		int test,test1,test2;
String output = "output.txt";
TokenizeServer server = new TokenizeServer(this);
int port = 6000;
Writer outputWriter = new FileWriter(output);
File dir = new File(options.get("directory"));
path=javaFile.getAbsolutePath()
String path = javaFile.getAbsolutePath();
List<File> files = new LinkedList<File>();
args=Platform.getCommandLineArgs()
String[] args = Platform.getCommandLineArgs();
Hashtable<String,String> options = new Hashtable<String,String>();
String arg = args[i];
BufferedReader r=null;
StringBuffer buffer = new StringBuffer();
String line = null;
buffer=GetFileContents(file)
StringBuffer buffer = GetFileContents(file);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
node=parser.createAST(null)
ASTNode node = parser.createAST(null);
visitor=AbstractVisitor.getVisitor(pattern,output)
AbstractVisitor visitor = AbstractVisitor.getVisitor(pattern, output);
FileWriter writer = null;
int x = (int)3.0f;
T too = null;
T[] array = (T[]) new Object[3];
ArrayList<T> a = new ArrayList<T>();
List<Double> ints = new ArrayList<Double>();
List<Double> nums = ints;
List<Double> nums = ints;
x=ints.get(1)
Number x=ints.get(1);
lineNumber=Unit.getLineNumber(t.getStartPosition())
int lineNumber = Unit.getLineNumber(t.getStartPosition());
lineNumber=Unit.getLineNumber(p.getStartPosition())
int lineNumber = Unit.getLineNumber(p.getStartPosition());
scanner=ToolFactory.createScanner(true,true,false,true)
IScanner scanner = ToolFactory.createScanner(true, true, false, true);
int token = 0;
ServerSocket serverSocket = new ServerSocket(port);
BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
Writer out = new PrintWriter(clientSocket.getOutputStream(), true);
request=reader.readLine()
String request = reader.readLine();
parts[]=request.trim().split(":")
String parts[] = request.trim().split(":");
String filepath = parts[0];
String pattern = parts[1];
ContainerGranularity containerGranularity = ContainerGranularity.FULL;
String args = parts[2];
argParts[]=args.split("=")
String argParts[] = args.split("=");
gran=argParts[1].trim().toLowerCase()
String gran = argParts[1].trim().toLowerCase();
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator iter = s.iterator();
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						"DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
String annotationsQuery = new AnnotationAnalysis(null).query()+", revisions.DateTime";
String typesQuery = new ParameterizedTypeAnalysis(null).query()+", revisions.DateTime";
Hashtable<String,ProjectTiming> timing = new Hashtable<String,ProjectTiming>();
set=s.executeQuery(annotationsQuery)
ResultSet set = s.executeQuery(annotationsQuery);
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
Connection conn = null;
Statement statement = null;
ResultSet results = null;
results=statement.executeQuery(query())
ResultSet results = statement.executeQuery(query());
Map<String,Revision> mostRecentRevision = new HashMap<String, Revision>();
t=e.getKey()
Timestamp t = e.getKey();
String lastProjectName = null;
Revision rev = new Revision();
project=r.getString("revisions.project")
String project = r.getString("revisions.project");
project=projects.get(projectName)
Project project = projects.get(projectName);
revs=project.timeToRevs.get(time)
List<Revision> revs = project.timeToRevs.get(time);
List<Revision> revs = project.timeToRevs.get(time);
String url = "jdbc:mysql://<database>/generics?netTimeoutForStreamingResults=200000";
FileWriter writer = new FileWriter("output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("an_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
int total = 0;
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
revs=getRevisionsFor(timestamp,projectName)
List<Revision> revs = getRevisionsFor(timestamp,projectName);
List<Revision> revs = getRevisionsFor(timestamp,projectName);
int val = 0;
tg=gatherResults()
TimeGraph<CombinedMetric> tg = gatherResults();
TimeGraph<CombinedMetric> tg = gatherResults();
PrintWriter out = new PrintWriter(System.out);
CastReducer cr = new CastReducer(out);
GenericReducer gr = new GenericReducer(out);
HalsteadReducer hr = new HalsteadReducer(out);
TimeGraph<CombinedMetric> tg = new TimeGraph<CombinedMetric>();
project=e.getKey()
String project = e.getKey();
CombinedMetric cm = new CombinedMetric();
map=cr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
map2=gr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
CombinedMetric last = null;
map=totals.get(projectName)
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
castIncrease=subset(projectName,castIncreasePredicate)
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
Random r = new Random();
Set<Timestamp> stamps = new HashSet<Timestamp>();
rand=r.nextInt(castIncrease.size())
int rand = r.nextInt(castIncrease.size());
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
statement=conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?")
PreparedStatement statement = conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?");
rs=statement.executeQuery()
ResultSet rs = statement.executeQuery();
module=rs.getString(1)
String module = rs.getString(1);
next=values.next()
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
metrics=totals.get(projectName)
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
castIncrease=PredicatedSortedMap.decorate(new TreeMap<Timestamp,Metric>(),TruePredicate.INSTANCE,castIncreasePredicate)
@SuppressWarnings("unchecked")
		SortedMap<Timestamp, Metric> castIncrease = PredicatedSortedMap.decorate(new TreeMap<Timestamp, Metric>(), TruePredicate.INSTANCE, castIncreasePredicate);
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,DeveloperData> devInfo = new Hashtable<String,DeveloperData>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
kind=set.getString(paramDecs() + ".kind")
String kind = set.getString(paramDecs()+".kind");
num=set.getString("num")
String num = set.getString("num");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
num=set.getInt("num")
int num = set.getInt("num");
String key = project+"^_^"+userId;
devAnnotations=CalculateAnnotationsDeltas(s)
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
DeveloperData data = new DeveloperData();
Hashtable<String,Integer> developerCount = new Hashtable<String,Integer>();
set=s.executeQuery(annotationsQuery())
ResultSet set = s.executeQuery(annotationsQuery());
Hashtable<String,Integer> fileCount = new Hashtable<String,Integer>();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
module=set.getString("revisions.module")
String module = set.getString("revisions.module");
file=set.getString("revisions.filename")
String file = set.getString("revisions.filename");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
state=set.getString("revisions.state")
String state = set.getString("revisions.state");
String key = project + "." + module + "." + file;
int last = 0;
int delta =  set.getInt("num") - last;
int lastDev = 0;
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
sumMetric=metricFrom(mostRecentRevisions.values())
HalsteadMetric sumMetric = metricFrom(mostRecentRevisions.values());
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
HalsteadMetric m = new HalsteadMetric();
HalsteadMetric sumMetric = new HalsteadMetric();
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
module=set.getString("module")
String module = set.getString("module");
filename=set.getString("filename")
String filename = set.getString("filename");
kind=set.getString("kind")
String kind = set.getString("kind");
classType=set.getString("class_type")
String classType = set.getString("class_type");
typeArgs=set.getString("type_args")
String typeArgs = set.getString("type_args");
String key = module + "." + filename + "." + classType + "." + typeArgs;
FileWriter writer = new FileWriter("pt_output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("raw_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/schoolwork/activity/generics/working_database.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						//"DBQ=C:/Users/Adminuser/Documents/Database2.accdb");
						"DBQ=C:/schoolwork/activity/generics/working_database.accdb");
String url = "jdbc:mysql://<database>:4747/generics?netTimeoutForStreamingResults=200000";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
set=s.executeQuery("SELECT project,baseEncodedAttachment FROM table")
ResultSet set = s.executeQuery("SELECT project,baseEncodedAttachment FROM table");
project=set.getString("project")
String project = set.getString("project");
module=set.getString("baseEncodedAttachment")
String module = set.getString("baseEncodedAttachment");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("proj")
String project = set.getString("proj");
classType=set.getString("class")
String classType = set.getString("class");
HeteroVisitor visitor = new HeteroVisitor(u);
projectName=u.getJavaProject().getElementName()
String projectName = u.getJavaProject().getElementName();
path=u.getResource().getFullPath()
IPath path = u.getResource().getFullPath();
writer=getWriter()
FileWriter writer = getWriter();
superTypes=ref.superTypes()
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
JFileChooser fr = new JFileChooser();
fw=fr.getFileSystemView()
FileSystemView fw = fr.getFileSystemView();
dir=fw.getDefaultDirectory().toString()
String dir = fw.getDefaultDirectory().toString();
FileWriter writer = new FileWriter(dir + "/HeteroAdds.sql", true);
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
unit=unitsToInspect.get(i)
ICompilationUnit unit = unitsToInspect.get(i);
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit) parser
				.createAST(new NullProgressMonitor());
methodName=mi.getName().getIdentifier()
String methodName = mi.getName().getIdentifier();
expression=mi.getExpression()
Expression expression = mi.getExpression();
SimpleName sn = (SimpleName) expression;
binding=sn.resolveBinding()
IBinding binding = sn.resolveBinding();
IVariableBinding varBinding = (IVariableBinding) binding;
type=varBinding.getType()
ITypeBinding type = varBinding.getType();
decl=varBinding.getVariableDeclaration()
IVariableBinding decl = varBinding
								.getVariableDeclaration();
existingTypes=typeInserts.get(decl)
List<Expression> existingTypes = typeInserts.get(decl);
List<Expression> existingTypes = typeInserts.get(decl);
Expression expr = (Expression) mi.arguments().get(0);
List<Bag<String>> superClasses = new LinkedList<Bag<String>>();
Set<String> baseClasses = new HashSet<String>();
iterator=ref.superTypes().entrySet().iterator()
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
int i = 0;
pair=iterator.next()
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Bag<String> potentialsSoFar = new HashBag<String>();
HashMap<String, Integer> superTypes = new HashMap<String, Integer>();
expressionType=expression.resolveTypeBinding()
ITypeBinding expressionType = expression.resolveTypeBinding();
SuperTypeMapSort sortedSuperTypes = new SuperTypeMapSort(superTypes);
SortedMap<String, Integer> sortedMap = new TreeMap<String, Integer>(
				sortedSuperTypes);
binding=expression.resolveTypeBinding()
ITypeBinding binding = expression.resolveTypeBinding();
bindingName=typeBinding.getName()
String bindingName = typeBinding.getName();
List<ITypeBinding> directSupertypes = new ArrayList<ITypeBinding>(
				Arrays.asList(typeBinding.getInterfaces()));
superClass=typeBinding.getSuperclass()
ITypeBinding superClass = typeBinding.getSuperclass();
oldLevel=superTypes.get(bindingName)
Integer oldLevel = superTypes.get(bindingName);
int diff = sort.get(x) - sort.get(y);
ArrayList<String> subtracts = new ArrayList<String>();
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;")
PreparedStatement stmt = conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;");
rs=stmt.executeQuery()
ResultSet rs = stmt.executeQuery();
ArrayList<String> projects = new ArrayList<String>();
String count = "", previous = "";
rsRevisions=stmt.executeQuery()
ResultSet rsRevisions = stmt.executeQuery();
ArrayList<Integer> revisions = new ArrayList<Integer>();
r=rsRevisions.getInt(1)
Integer r = rsRevisions.getInt(1);
rsCount=stmt.executeQuery()
ResultSet rsCount = stmt.executeQuery();
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
ResultSet rs;
projectName=rs.getString("ProjectName")
String projectName = rs.getString("ProjectName");
declType=rs.getString("DeclType")
String declType = rs.getString("DeclType");
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
File dataFile = new File(project + "/" + module + ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(dataFile));
st=conn.createStatement()
Statement st = conn.createStatement();
List<Revision> revisions = new ArrayList<Revision>();
Revision revisionInst = new Revision();
BufferedReader reader = new BufferedReader(new FileReader(file));
String line, path;
String timestampStr;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
long timeWindow = 1000 * 60 * 15;
DateFormat CVSDateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
DateFormat otherCVSDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);", flags);
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
pattern=Pattern.compile("branches:\\s+[0-9.]+;")
Pattern pattern = Pattern.compile("branches:\\s+[0-9.]+;");
matcherLog=pattern.matcher(revisionInst.logMessage)
Matcher matcherLog = pattern.matcher(revisionInst.logMessage);
int transactionId = 1;
Revision r1, r2;
int j;
Hashtable<Integer, List<Revision>> trans = new Hashtable<Integer, List<Revision>>();
List<Transaction> transactions = new ArrayList<Transaction>();
Transaction t = new Transaction(trans.get(id));
int id = 0;
overlaps=FindOverlaps(transactions)
HashSet<Transaction> overlaps = FindOverlaps(transactions);
HashSet<Transaction> overlaps = FindOverlaps(transactions);
overlapSize=overlaps.size()
int overlapSize = overlaps.size();
tempPath=dataFile.getAbsolutePath()
String tempPath = dataFile.getAbsolutePath();
o=c.Parent.HasRevisionWithFile(r.filename)
Revision o = c.Parent.HasRevisionWithFile(r.filename);
oVersion=Integer.parseInt(o.revision.split("[.]")[1])
int oVersion = Integer.parseInt(o.revision.split("[.]")[1]);
rVersion=Integer.parseInt(r.revision.split("[.]")[1])
int rVersion = Integer.parseInt(r.revision.split("[.]")[1]);
HashSet<Transaction> overlaps = new HashSet<Transaction>();
boolean afterStart = t.First().date.compareTo(p.Last().date) < 0;
boolean overlapsStart = p.Last().date.compareTo(t.Last().date) < 0;
boolean beforeEnd = t.Last().date.compareTo(p.First().date) > 0;
boolean overlapsEnd = p.First().date.compareTo(t.First().date) > 0;
String info = t.First().date + " to " + t.Last().date + " overlaps with " + 
					              p.First().date + " to " + p.Last().date;
String nums = t.Id + " " + p.Id;
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
filename=parts[1].replace("/Attic","")
String filename = parts[1].replace("/Attic", "");
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path)
String fileName = formatFile(path);
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
FastRevisionCVSLogParser logParser = new FastRevisionCVSLogParser();
BufferedWriter sqlWriter = new BufferedWriter(new FileWriter(outputBase + ".sql"));
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(outputBase + ".data"));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
String project = args[0];
String logFilename = args[1];
String outputBase = args[2];
FastRevisionSVNLogParser logParser = new FastRevisionSVNLogParser(project);
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
BufferedReader logReader = new BufferedReader(new FileReader(file));
DateFormat gitDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
StringBuilder sb;
String line;
String revision, committer, parent, msg, status, path, diffUrl;
Date dateTime;
String[] parts;
int transaction = 1;
boolean validTransaction = false;
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String logCmd = "git log --reverse --full-history --all --date=iso --name-status -M -C --pretty=format:\"" +
    			"__START_GIT_COMMIT_LOG_MSG__%nrevision: %H%ncommitter: %cn%ndate: %ci%nparent: %P%n%s%n%b%n__END_GIT_COMMIT_LOG_MSG__\"";
String project = args[0];
String logFilename = args[1];
String jdbcUrl = args[2];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
GitLogParser logParser = new GitLogParser(project);
nodeList=node.getElementsByTagName(tag)
NodeList nodeList = node.getElementsByTagName(tag);
Element valueNode = (Element)nodeList.item(0);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
BufferedReader reader = new BufferedReader(new FileReader(file));
String line;
String filename, revision, author, timestampStr;
Timestamp timestamp;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);", flags);
statement=conn.createStatement()
Statement statement = conn.createStatement();
String insertPart = "insert into revisions (project, filename, datetime, revision, userid, logmessage, module, diffUrl) VALUES ";
insertStatement=conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)")
PreparedStatement insertStatement = conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)");
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
StringBuilder bigInsert = new StringBuilder(insertPart);
boolean first = true;
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
String filename = module + parts[1];
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path,project,module)
String fileName = formatFile( path, project, module);
StringBuilder sb = new StringBuilder("update revisions set transactionid = " + transaction + " where fileid in (");
boolean first = true;
st=conn.createStatement()
Statement st = conn.createStatement();
String sql = "select userid, datetime, fileID from revisions where project = '" 
    			+ project + "' and module = '" + module + "' order by userid, datetime asc";
st=conn.createStatement()
Statement st = conn.createStatement();
long timeWindow = 1000 * 60 * 60;
rs=st.getResultSet()
ResultSet rs = st.getResultSet();
String lastUser = null;
String currentUser;
Date lastCommitDate = new Date(0);
Date currentCommitDate;
int transaction = 1;
List<Integer> transactionFileIds = new LinkedList<Integer>();
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionCVSLogParser logParser = new RevisionCVSLogParser();
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
java.util.Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
diffUrl=formatRevisionLink(project,path,revision)
String diffUrl = formatRevisionLink(project, path, revision);
action=fileNode.getAttributes().getNamedItem("action").getTextContent()
String action = fileNode.getAttributes().getNamedItem("action").getTextContent();
String state = "";
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String baseUrl = "http://" + project + ".svn.sourceforge.net/viewvc/" + project;
a=Integer.parseInt(version)
int a = Integer.parseInt(version);
int b = a - 1;
String fileName = path;
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionSVNLogParser logParser = new RevisionSVNLogParser(project, module);
List<ProjectEntry> projects = new ArrayList<ProjectEntry>(100);
int pageNum = projects.size()/10+1;
doc=getDoc("p.xml?page=" + pageNum + "&q=language%3Ajava&sort=users&")
Document doc =getDoc("p.xml?page="+pageNum+"&q=language%3Ajava&sort=users&");
Element resultElement = (Element)element.getElementsByTagName("result").item(0);
projectId=elementIn(projectNode,"id")
String projectId = elementIn(projectNode, "id");
projectName=elementIn(projectNode,"name")
String projectName = elementIn(projectNode, "name");
ProjectEntry p = new ProjectEntry();
boolean complete = false;
int page = 0;
String pageString;
doc=getDoc("p/" + projectId + "/enlistments.xml"+ pageString)
Document doc = getDoc("p/" + projectId+ "/enlistments.xml"+pageString);
itemsReturned=Integer.parseInt(elementIn(response,"items_returned"))
int itemsReturned = Integer.parseInt(elementIn(response, "items_returned"));
itemsAvailable=Integer.parseInt(elementIn(response,"items_available"))
int itemsAvailable = Integer.parseInt(elementIn(response, "items_available"));
firstItemPosition=Integer.parseInt(elementIn(response,"first_item_position"))
int firstItemPosition = Integer.parseInt(elementIn(response, "first_item_position"));
Element resultElement = (Element)response.getElementsByTagName("result").item(0);
type=elementIn(repo,"type")
String type = elementIn(repo, "type");
repoURL=elementIn(repo,"url")
String repoURL = elementIn(repo, "url");
module=elementIn(repo,"module_name")
String module = elementIn(repo, "module_name");
username=elementIn(repo,"username")
String username = elementIn(repo, "username");
password=elementIn(repo,"password")
String password = elementIn(repo, "password");
status=elementIn(repo,"ohloh_job_status")
String status = elementIn(repo, "ohloh_job_status");
Repo r = new Repo(type,repoURL,module,username,password,status);
String pre = "https://www.ohloh.net/";
String post = "api_key=waDryU9cuiDEO64aJLYMA";
URL url = new URL(pre+string+post);
con=url.openConnection()
URLConnection con = url.openConnection();
builder=DocumentBuilderFactory.newInstance().newDocumentBuilder()
DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
doc=builder.parse(con.getInputStream())
Document doc = builder.parse(con.getInputStream());
elem=parent.getElementsByTagName(s)
NodeList elem = parent.getElementsByTagName(s);
StringBuilder sb = new StringBuilder();
Element temp = next;
item=coll.item(pointer++)
Node item = coll.item(pointer++);
wholeText=((Text)item).getWholeText()
String wholeText = ((Text)item).getWholeText();
Element elem = (Element) item;
statusList=element.getElementsByTagName("status")
NodeList statusList = element.getElementsByTagName("status");
statusNode=statusList.item(0)
Node statusNode = statusList.item(0);

Diff of 873112ed1310d709618bdc808c0496cefc485dd0 and 294ae1129618f7dccc9f5f558ee633c40e8f8e45:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 873112ed1310d709618bdc808c0496cefc485dd0 to 294ae1129618f7dccc9f5f558ee633c40e8f8e45


****Parsing for addition at revision 294ae1129618f7dccc9f5f558ee633c40e8f8e45****

Added GetTransactions.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added AnalyzeDeclarations.java to .\generic.tools\ repository source files.
Added GenericDeclVisitor.java to .\generic.tools\ repository source files.
Added Results.java to .\generic.tools\ repository source files.
Added TestVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added CheckoutAll.java to .\generic.tools\ repository source files.
Added TestTimezones.java to .\generic.tools\ repository source files.
Added DevelopersController.2890.java to .\generic.tools\ repository source files.
Added DevelopersController.3838.java to .\generic.tools\ repository source files.
Added AbstractVisitor.java to .\generic.tools\ repository source files.
Added AnnotationVisitor.java to .\generic.tools\ repository source files.
Added CastsVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersAndMethoParametersVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersVisitor.java to .\generic.tools\ repository source files.
Added ContainerGranularity.java to .\generic.tools\ repository source files.
Added HalsteadVisitor.java to .\generic.tools\ repository source files.
Added ParameterizedTypeVisitor.java to .\generic.tools\ repository source files.
Added RawTypesVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added Application.java to .\generic.tools\ repository source files.
Added MyAnnotation.java to .\generic.tools\ repository source files.
Added package-info.java to .\generic.tools\ repository source files.
Added TokenizeServer.java to .\generic.tools\ repository source files.
Added Util.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added AdoptionTiming7_3.java to .\generic.tools\ repository source files.
Added Analysis.java to .\generic.tools\ repository source files.
Added AnalyzeAll.java to .\generic.tools\ repository source files.
Added AnnotationAnalysis.java to .\generic.tools\ repository source files.
Added BasicAnalysis.java to .\generic.tools\ repository source files.
Added BasicMetric.java to .\generic.tools\ repository source files.
Added CastAnalysis.java to .\generic.tools\ repository source files.
Added CastInvestigation.java to .\generic.tools\ repository source files.
Added DeveloperFeatureUsage.java to .\generic.tools\ repository source files.
Added GeneralFeatureUsage.java to .\generic.tools\ repository source files.
Added HalsteadAnalysis.java to .\generic.tools\ repository source files.
Added HalsteadMetric.java to .\generic.tools\ repository source files.
Added MethodClassFeatureUsage.java to .\generic.tools\ repository source files.
Added ParameterizedDeclarationAnalysis.java to .\generic.tools\ repository source files.
Added ParameterizedTypeAnalysis.java to .\generic.tools\ repository source files.
Added RawAnalysis.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added TestFile.java to .\generic.tools\ repository source files.
Added UniqueParamAnalysis.java to .\generic.tools\ repository source files.
Added ExtractMethodFinderPlugin.java to .\generic.tools\ repository source files.
Added FindHeteroAdds.java to .\generic.tools\ repository source files.
Added FindInterestingMethods.java to .\generic.tools\ repository source files.
Added HeteroVisitor.java to .\generic.tools\ repository source files.
Added Variable.java to .\generic.tools\ repository source files.
Added VariableReference.java to .\generic.tools\ repository source files.
Added SubtractFinder.java to .\generic.tools\ repository source files.
Added SuperTypeCollector.java to .\generic.tools\ repository source files.
Added FastRevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added FastRevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GitLogParser.java to .\generic.tools\ repository source files.
Added LogParser.java to .\generic.tools\ repository source files.
Added RevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added RevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GetTop100Projects.java to .\generic.tools\ repository source files.
Added Repo.java to .\generic.tools\ repository source files.
String project = args[0];
String module = args[1];
String jdbcUrl = args[2];
boolean doingGit=false;
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
results=stmt.getResultSet()
ResultSet results = stmt.getResultSet();
files=results.getString("filename")
String files = results.getString("filename");
transId=results.getInt("transactionId")
int transId = results.getInt("transactionId");
datetime=results.getString("datetimestr")
String datetime = results.getString("datetimestr");
state=results.getString("state")
String state = results.getString("state");
revision=results.getString("revision")
String revision = results.getString("revision");
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit)parser.createAST(new NullProgressMonitor());
GenericDeclVisitor v = new GenericDeclVisitor();
TestVisitor test = new TestVisitor();
SimpleType st = (SimpleType)t;
b=st.getName().resolveBinding()
IBinding b = st.getName().resolveBinding();
gb=computeDistanceToDecl(st.getName())
GenericBinding gb = computeDistanceToDecl(st.getName());
bound=((WildcardType)t).getBound()
Type bound = ((WildcardType) t).getBound();
ArrayType at = (ArrayType) t;
QualifiedType qt = (QualifiedType) t;
ASTNode node = sn;
int depth = 0;
targetName=sn.getFullyQualifiedName()
String targetName = sn.getFullyQualifiedName();
TypeParameter tp = (TypeParameter) o;
TypeParameter tp = (TypeParameter) o;
superclassType=td.getSuperclassType()
Type superclassType = td.getSuperclassType();
returnType=md.getReturnType2()
Type returnType = md.getReturnType2();
SingleVariableDeclaration sd = (SingleVariableDeclaration) o;
A a2;
M m2;
A a2;
M m2;
binding=st.resolveBinding()
IBinding binding = st.resolveBinding();
Set<Type> otherCopy = new HashSet<Type>(typesProducedByOtherVisitor);
Set<Type> thisCopy = new HashSet<Type>(found);
List<ProjectInterval> changes = new ArrayList<ProjectInterval>();
activeEditor=targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor()
IEditorPart activeEditor = targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor();
ITextSelection selection = (ITextSelection)((ITextEditor)activeEditor).getSelectionProvider().getSelection();
lines=selection.getText()
String lines = selection.getText();
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S");
str=line.replace("\r","").replace("\n","")
String str = line.replace("\r", "").replace("\n", "");
components=line.split(",")
String[] components = line.split(",");
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
IWorkbenchAdapter adapter = (IWorkbenchAdapter)firstElement;
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
l=((CVSTagElement)firstElement).getRoot()
ICVSRepositoryLocation l = ((CVSTagElement)firstElement).getRoot();
resources=getRemoteResource()
ICVSRemoteResource[] resources = getRemoteResource();
List<CheckoutSingleProjectOperation> checkouts = 
			new LinkedList<CheckoutSingleProjectOperation>();
Job job = new Job("Checking out..."){
			public IStatus run(IProgressMonitor mon){
				
				mon.beginTask("Checking out projects from CVS", checkouts.size());
				
				List<IStatus> status = new ArrayList<IStatus>();
				
				for(CheckoutSingleProjectOperation checkout : checkouts){
					try {
						checkout.execute(new SubProgressMonitor(mon,1));						
						checkForErrors(status,checkout);
					} catch (Exception e) {
						e.printStackTrace();
					}
					 if (mon.isCanceled()) return Status.CANCEL_STATUS;
				}
				
				mon.done();
				
				return new MultiStatus(	Activator.PLUGIN_ID, 
										IStatus.WARNING, 
										status.toArray(new IStatus[0]), 
										"Checkout Warnings", 
										new RuntimeException());
			}

			private void checkForErrors(List<IStatus> existing, CheckoutSingleProjectOperation checkout) throws Exception {
				Method m = CVSOperation.class.getDeclaredMethod("getErrors");
				m.setAccessible(true);
				IStatus[] status = (IStatus[]) m.invoke(checkout);
				for(IStatus s : status){
					existing.add(s);
				}
			}
		};
List<IStatus> status = new ArrayList<IStatus>();
m=CVSOperation.class.getDeclaredMethod("getErrors")
Method m = CVSOperation.class.getDeclaredMethod("getErrors");
IStatus[] status = (IStatus[]) m.invoke(checkout);
Calendar cal = new GregorianCalendar();
Timestamp timestamp = new Timestamp(timeInUTC.getTime()
				+ cal.get(Calendar.DST_OFFSET) + cal.get(Calendar.ZONE_OFFSET)
				+ offset);
projectBefore=remoteFolderAtTime(time)
RemoteFolder projectBefore = remoteFolderAtTime(time);
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss");
String projectName = this.projectName + " " + df.format(time) + " " + resource.getName() + " " + postfix;
newProject=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName)
IProject newProject = ResourcesPlugin.getWorkspace().getRoot().
						getProject(projectName);
Timestamp predaylightSavings = new Timestamp(1172625369000l);
int oneMonthInMillis = 1000*60*60*24*50000000;
Timestamp postDaylightSavings = new Timestamp(1172625369000l+oneMonthInMillis);
Timestamp old = new Timestamp(fromDb.getTime()-60*60*1000*8);
nu=localTime(fromDb)
Timestamp nu = localTime(fromDb);
Calendar cal = new GregorianCalendar();
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList newProps = new ArrayList();
ArrayList replaceProps = new ArrayList();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{new Integer(occurrences),
													          new Integer(occurrencesFound),
																 files[i].getPath() };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[]{new Integer(newProps.size()), new Integer(replaceProps.size()), i18nStringFile.getPath()};
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList linesToPrint = new ArrayList();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList<String> newProps = new ArrayList<String>();
ArrayList<String> replaceProps = new ArrayList<String>();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{
                                        Integer.valueOf(occurrences),
										Integer.valueOf(occurrencesFound),
										files[i].getPath() 
                                    };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[] {
                        Integer.valueOf(newProps.size()), 
                        Integer.valueOf(replaceProps.size()), 
                        i18nStringFile.getPath()
                };
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList<String> linesToPrint = new ArrayList<String>();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator<?> iter = s.iterator();
Iterator<?> iter = s.iterator();
StringBuffer s = new StringBuffer();
int bracketCount = 0;
chars=containerSignature.toCharArray()
char []chars = containerSignature.toCharArray();
parent=input.getParent()
ASTNode parent = input.getParent();
ArrayList<String> names = new ArrayList<String>();
SingleVariableDeclaration param = (SingleVariableDeclaration)method.parameters().get(i);
parent=GetEnclosingContainer(input)
ASTNode parent = GetEnclosingContainer(input);
String name = "ERROR";
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
List<String> values = new ArrayList<String>();
MemberValuePair pair = (MemberValuePair)obj;
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
MethodDeclaration meth = (MethodDeclaration)node;
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
lineNumber=Unit.getLineNumber(cast.getStartPosition())
int lineNumber = Unit.getLineNumber(cast.getStartPosition());
t=cast.getType()
Type t = cast.getType();
parent=GetEnclosingContainerName(cast)
String parent = GetEnclosingContainerName(cast);
lineNumber=Unit.getLineNumber(method.getStartPosition())
int lineNumber = Unit.getLineNumber(method.getStartPosition());
name=method.getName().getFullyQualifiedName()
String name = method.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
binding=type.resolveBinding()
ITypeBinding binding = type.resolveBinding();
ParameterizedType pt = (ParameterizedType) type;
lineNumber=Unit.getLineNumber(pt.getStartPosition())
int lineNumber = Unit.getLineNumber(pt.getStartPosition());
parent=GetEnclosingContainerName(pt)
String parent = GetEnclosingContainerName(pt);
StringBuffer typeArgs = new StringBuffer();
boolean first = true;
String rawTypesString = "BlockingQueue, List, Queue, Set, SortedSet, AbstractCollection, AbstractList, " +
				"AbstractQueue, AbstractSequentialList, AbstractSet, ArrayBlockingQueue, ArrayList, ConcurrentLinkedQueue, " +
				"CopyOnWriteArrayList, CopyOnWriteArraySet, DelayQueue, EnumSet, HashSet, LinkedBlockingQueue, LinkedHashSet, " +
				"LinkedList, PriorityBlockingQueue, PriorityQueue, Stack, SynchronousQueue, TreeSet, Vector, " + 
				"Map, ConcurrentMap, SortedMap, AbstractMap, ConcurrentHashMap, EnumMap, HashMap, Hashtable, IdentityHashMap, " +
				"LinkedHashMap, TreeMap, WeakHashMap";
ParameterizedType pt = (ParameterizedType) type;
o=type.getProperty("typeArguments")
Object o = type.getProperty("typeArguments");
parts=type.toString().split("\\.")
String[] parts = type.toString().split("\\.");
String simpleTypeName = parts[parts.length-1];
lineNumber=sourceNode.getStartPosition()
int lineNumber = sourceNode.getStartPosition();
parent=GetEnclosingContainerName(sourceNode)
String parent = GetEnclosingContainerName(sourceNode);
sp=type.structuralPropertiesForType()
List sp = type.structuralPropertiesForType();
type=node.getReturnType2()
Type type = node.getReturnType2();
SingleVariableDeclaration svd = (SingleVariableDeclaration) o;
type=node.getType()
Type type = node.getType();
String foo;
int a, b = 4, c;
List badList;
String bar = "fred";
List<String> l = new LinkedList<String>();
java.util.Map m;
options=ProcessCommandArgs()
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		int test,test1,test2;
String output = "output.txt";
TokenizeServer server = new TokenizeServer(this);
int port = 6000;
Writer outputWriter = new FileWriter(output);
File dir = new File(options.get("directory"));
path=javaFile.getAbsolutePath()
String path = javaFile.getAbsolutePath();
List<File> files = new LinkedList<File>();
args=Platform.getCommandLineArgs()
String[] args = Platform.getCommandLineArgs();
Hashtable<String,String> options = new Hashtable<String,String>();
String arg = args[i];
BufferedReader r=null;
StringBuffer buffer = new StringBuffer();
String line = null;
buffer=GetFileContents(file)
StringBuffer buffer = GetFileContents(file);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
node=parser.createAST(null)
ASTNode node = parser.createAST(null);
visitor=AbstractVisitor.getVisitor(pattern,output)
AbstractVisitor visitor = AbstractVisitor.getVisitor(pattern, output);
FileWriter writer = null;
int x = (int)3.0f;
T too = null;
T[] array = (T[]) new Object[3];
ArrayList<T> a = new ArrayList<T>();
List<Double> ints = new ArrayList<Double>();
List<Double> nums = ints;
List<Double> nums = ints;
x=ints.get(1)
Number x=ints.get(1);
lineNumber=Unit.getLineNumber(t.getStartPosition())
int lineNumber = Unit.getLineNumber(t.getStartPosition());
lineNumber=Unit.getLineNumber(p.getStartPosition())
int lineNumber = Unit.getLineNumber(p.getStartPosition());
scanner=ToolFactory.createScanner(true,true,false,true)
IScanner scanner = ToolFactory.createScanner(true, true, false, true);
int token = 0;
ServerSocket serverSocket = new ServerSocket(port);
BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
Writer out = new PrintWriter(clientSocket.getOutputStream(), true);
request=reader.readLine()
String request = reader.readLine();
parts[]=request.trim().split(":")
String parts[] = request.trim().split(":");
String filepath = parts[0];
String pattern = parts[1];
ContainerGranularity containerGranularity = ContainerGranularity.FULL;
String args = parts[2];
argParts[]=args.split("=")
String argParts[] = args.split("=");
gran=argParts[1].trim().toLowerCase()
String gran = argParts[1].trim().toLowerCase();
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator iter = s.iterator();
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						"DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
String annotationsQuery = new AnnotationAnalysis(null).query()+", revisions.DateTime";
String typesQuery = new ParameterizedTypeAnalysis(null).query()+", revisions.DateTime";
Hashtable<String,ProjectTiming> timing = new Hashtable<String,ProjectTiming>();
set=s.executeQuery(annotationsQuery)
ResultSet set = s.executeQuery(annotationsQuery);
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
Connection conn = null;
Statement statement = null;
ResultSet results = null;
results=statement.executeQuery(query())
ResultSet results = statement.executeQuery(query());
Map<String,Revision> mostRecentRevision = new HashMap<String, Revision>();
t=e.getKey()
Timestamp t = e.getKey();
String lastProjectName = null;
Revision rev = new Revision();
project=r.getString("revisions.project")
String project = r.getString("revisions.project");
project=projects.get(projectName)
Project project = projects.get(projectName);
revs=project.timeToRevs.get(time)
List<Revision> revs = project.timeToRevs.get(time);
List<Revision> revs = project.timeToRevs.get(time);
String url = "jdbc:mysql://<database>/generics?netTimeoutForStreamingResults=200000";
FileWriter writer = new FileWriter("output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("an_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
int total = 0;
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
revs=getRevisionsFor(timestamp,projectName)
List<Revision> revs = getRevisionsFor(timestamp,projectName);
List<Revision> revs = getRevisionsFor(timestamp,projectName);
int val = 0;
tg=gatherResults()
TimeGraph<CombinedMetric> tg = gatherResults();
TimeGraph<CombinedMetric> tg = gatherResults();
PrintWriter out = new PrintWriter(System.out);
CastReducer cr = new CastReducer(out);
GenericReducer gr = new GenericReducer(out);
HalsteadReducer hr = new HalsteadReducer(out);
TimeGraph<CombinedMetric> tg = new TimeGraph<CombinedMetric>();
project=e.getKey()
String project = e.getKey();
CombinedMetric cm = new CombinedMetric();
map=cr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
map2=gr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
CombinedMetric last = null;
map=totals.get(projectName)
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
castIncrease=subset(projectName,castIncreasePredicate)
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
Random r = new Random();
Set<Timestamp> stamps = new HashSet<Timestamp>();
rand=r.nextInt(castIncrease.size())
int rand = r.nextInt(castIncrease.size());
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
statement=conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?")
PreparedStatement statement = conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?");
rs=statement.executeQuery()
ResultSet rs = statement.executeQuery();
module=rs.getString(1)
String module = rs.getString(1);
next=values.next()
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
metrics=totals.get(projectName)
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
castIncrease=PredicatedSortedMap.decorate(new TreeMap<Timestamp,Metric>(),TruePredicate.INSTANCE,castIncreasePredicate)
@SuppressWarnings("unchecked")
		SortedMap<Timestamp, Metric> castIncrease = PredicatedSortedMap.decorate(new TreeMap<Timestamp, Metric>(), TruePredicate.INSTANCE, castIncreasePredicate);
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,DeveloperData> devInfo = new Hashtable<String,DeveloperData>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
kind=set.getString(paramDecs() + ".kind")
String kind = set.getString(paramDecs()+".kind");
num=set.getString("num")
String num = set.getString("num");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
num=set.getInt("num")
int num = set.getInt("num");
String key = project+"^_^"+userId;
devAnnotations=CalculateAnnotationsDeltas(s)
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
DeveloperData data = new DeveloperData();
Hashtable<String,Integer> developerCount = new Hashtable<String,Integer>();
set=s.executeQuery(annotationsQuery())
ResultSet set = s.executeQuery(annotationsQuery());
Hashtable<String,Integer> fileCount = new Hashtable<String,Integer>();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
module=set.getString("revisions.module")
String module = set.getString("revisions.module");
file=set.getString("revisions.filename")
String file = set.getString("revisions.filename");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
state=set.getString("revisions.state")
String state = set.getString("revisions.state");
String key = project + "." + module + "." + file;
int last = 0;
int delta =  set.getInt("num") - last;
int lastDev = 0;
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
sumMetric=metricFrom(mostRecentRevisions.values())
HalsteadMetric sumMetric = metricFrom(mostRecentRevisions.values());
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
HalsteadMetric m = new HalsteadMetric();
HalsteadMetric sumMetric = new HalsteadMetric();
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
module=set.getString("module")
String module = set.getString("module");
filename=set.getString("filename")
String filename = set.getString("filename");
kind=set.getString("kind")
String kind = set.getString("kind");
classType=set.getString("class_type")
String classType = set.getString("class_type");
typeArgs=set.getString("type_args")
String typeArgs = set.getString("type_args");
String key = module + "." + filename + "." + classType + "." + typeArgs;
FileWriter writer = new FileWriter("pt_output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("raw_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/schoolwork/activity/generics/working_database.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						//"DBQ=C:/Users/Adminuser/Documents/Database2.accdb");
						"DBQ=C:/schoolwork/activity/generics/working_database.accdb");
String url = "jdbc:mysql://<database>:4747/generics?netTimeoutForStreamingResults=200000";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
set=s.executeQuery("SELECT project,baseEncodedAttachment FROM table")
ResultSet set = s.executeQuery("SELECT project,baseEncodedAttachment FROM table");
project=set.getString("project")
String project = set.getString("project");
module=set.getString("baseEncodedAttachment")
String module = set.getString("baseEncodedAttachment");

 Generics pattern public class TestFile was added at revision 294ae1129618f7dccc9f5f558ee633c40e8f8e45

conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("proj")
String project = set.getString("proj");
classType=set.getString("class")
String classType = set.getString("class");
HeteroVisitor visitor = new HeteroVisitor(u);
projectName=u.getJavaProject().getElementName()
String projectName = u.getJavaProject().getElementName();
path=u.getResource().getFullPath()
IPath path = u.getResource().getFullPath();
writer=getWriter()
FileWriter writer = getWriter();
superTypes=ref.superTypes()
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
JFileChooser fr = new JFileChooser();
fw=fr.getFileSystemView()
FileSystemView fw = fr.getFileSystemView();
dir=fw.getDefaultDirectory().toString()
String dir = fw.getDefaultDirectory().toString();
FileWriter writer = new FileWriter(dir + "/HeteroAdds.sql", true);
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
unit=unitsToInspect.get(i)
ICompilationUnit unit = unitsToInspect.get(i);
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit) parser
				.createAST(new NullProgressMonitor());
methodName=mi.getName().getIdentifier()
String methodName = mi.getName().getIdentifier();
expression=mi.getExpression()
Expression expression = mi.getExpression();
SimpleName sn = (SimpleName) expression;
binding=sn.resolveBinding()
IBinding binding = sn.resolveBinding();
IVariableBinding varBinding = (IVariableBinding) binding;
type=varBinding.getType()
ITypeBinding type = varBinding.getType();
decl=varBinding.getVariableDeclaration()
IVariableBinding decl = varBinding
								.getVariableDeclaration();
existingTypes=typeInserts.get(decl)
List<Expression> existingTypes = typeInserts.get(decl);
List<Expression> existingTypes = typeInserts.get(decl);
Expression expr = (Expression) mi.arguments().get(0);
List<Bag<String>> superClasses = new LinkedList<Bag<String>>();
Set<String> baseClasses = new HashSet<String>();
iterator=ref.superTypes().entrySet().iterator()
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
int i = 0;
pair=iterator.next()
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Bag<String> potentialsSoFar = new HashBag<String>();
HashMap<String, Integer> superTypes = new HashMap<String, Integer>();
expressionType=expression.resolveTypeBinding()
ITypeBinding expressionType = expression.resolveTypeBinding();
SuperTypeMapSort sortedSuperTypes = new SuperTypeMapSort(superTypes);
SortedMap<String, Integer> sortedMap = new TreeMap<String, Integer>(
				sortedSuperTypes);
binding=expression.resolveTypeBinding()
ITypeBinding binding = expression.resolveTypeBinding();
bindingName=typeBinding.getName()
String bindingName = typeBinding.getName();
List<ITypeBinding> directSupertypes = new ArrayList<ITypeBinding>(
				Arrays.asList(typeBinding.getInterfaces()));
superClass=typeBinding.getSuperclass()
ITypeBinding superClass = typeBinding.getSuperclass();
oldLevel=superTypes.get(bindingName)
Integer oldLevel = superTypes.get(bindingName);
int diff = sort.get(x) - sort.get(y);
ArrayList<String> subtracts = new ArrayList<String>();
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;")
PreparedStatement stmt = conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;");
rs=stmt.executeQuery()
ResultSet rs = stmt.executeQuery();
ArrayList<String> projects = new ArrayList<String>();
String count = "", previous = "";
rsRevisions=stmt.executeQuery()
ResultSet rsRevisions = stmt.executeQuery();
ArrayList<Integer> revisions = new ArrayList<Integer>();
r=rsRevisions.getInt(1)
Integer r = rsRevisions.getInt(1);
rsCount=stmt.executeQuery()
ResultSet rsCount = stmt.executeQuery();
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
ResultSet rs;
projectName=rs.getString("ProjectName")
String projectName = rs.getString("ProjectName");
declType=rs.getString("DeclType")
String declType = rs.getString("DeclType");
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://<database>:4747/generics";
File dataFile = new File(project + "/" + module + ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(dataFile));
st=conn.createStatement()
Statement st = conn.createStatement();
List<Revision> revisions = new ArrayList<Revision>();
Revision revisionInst = new Revision();
BufferedReader reader = new BufferedReader(new FileReader(file));
String line, path;
String timestampStr;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
long timeWindow = 1000 * 60 * 15;
DateFormat CVSDateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
DateFormat otherCVSDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);", flags);
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
pattern=Pattern.compile("branches:\\s+[0-9.]+;")
Pattern pattern = Pattern.compile("branches:\\s+[0-9.]+;");
matcherLog=pattern.matcher(revisionInst.logMessage)
Matcher matcherLog = pattern.matcher(revisionInst.logMessage);
int transactionId = 1;
Revision r1, r2;
int j;
Hashtable<Integer, List<Revision>> trans = new Hashtable<Integer, List<Revision>>();
List<Transaction> transactions = new ArrayList<Transaction>();
Transaction t = new Transaction(trans.get(id));
int id = 0;
overlaps=FindOverlaps(transactions)
HashSet<Transaction> overlaps = FindOverlaps(transactions);
HashSet<Transaction> overlaps = FindOverlaps(transactions);
overlapSize=overlaps.size()
int overlapSize = overlaps.size();
tempPath=dataFile.getAbsolutePath()
String tempPath = dataFile.getAbsolutePath();
o=c.Parent.HasRevisionWithFile(r.filename)
Revision o = c.Parent.HasRevisionWithFile(r.filename);
oVersion=Integer.parseInt(o.revision.split("[.]")[1])
int oVersion = Integer.parseInt(o.revision.split("[.]")[1]);
rVersion=Integer.parseInt(r.revision.split("[.]")[1])
int rVersion = Integer.parseInt(r.revision.split("[.]")[1]);
HashSet<Transaction> overlaps = new HashSet<Transaction>();
boolean afterStart = t.First().date.compareTo(p.Last().date) < 0;
boolean overlapsStart = p.Last().date.compareTo(t.Last().date) < 0;
boolean beforeEnd = t.Last().date.compareTo(p.First().date) > 0;
boolean overlapsEnd = p.First().date.compareTo(t.First().date) > 0;
String info = t.First().date + " to " + t.Last().date + " overlaps with " + 
					              p.First().date + " to " + p.Last().date;
String nums = t.Id + " " + p.Id;
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
filename=parts[1].replace("/Attic","")
String filename = parts[1].replace("/Attic", "");
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path)
String fileName = formatFile(path);
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
FastRevisionCVSLogParser logParser = new FastRevisionCVSLogParser();
BufferedWriter sqlWriter = new BufferedWriter(new FileWriter(outputBase + ".sql"));
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(outputBase + ".data"));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
String project = args[0];
String logFilename = args[1];
String outputBase = args[2];
FastRevisionSVNLogParser logParser = new FastRevisionSVNLogParser(project);
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
BufferedReader logReader = new BufferedReader(new FileReader(file));
DateFormat gitDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
StringBuilder sb;
String line;
String revision, committer, parent, msg, status, path, diffUrl;
Date dateTime;
String[] parts;
int transaction = 1;
boolean validTransaction = false;
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String logCmd = "git log --reverse --full-history --all --date=iso --name-status -M -C --pretty=format:\"" +
    			"__START_GIT_COMMIT_LOG_MSG__%nrevision: %H%ncommitter: %cn%ndate: %ci%nparent: %P%n%s%n%b%n__END_GIT_COMMIT_LOG_MSG__\"";
String project = args[0];
String logFilename = args[1];
String jdbcUrl = args[2];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
GitLogParser logParser = new GitLogParser(project);
nodeList=node.getElementsByTagName(tag)
NodeList nodeList = node.getElementsByTagName(tag);
Element valueNode = (Element)nodeList.item(0);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
BufferedReader reader = new BufferedReader(new FileReader(file));
String line;
String filename, revision, author, timestampStr;
Timestamp timestamp;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);", flags);
statement=conn.createStatement()
Statement statement = conn.createStatement();
String insertPart = "insert into revisions (project, filename, datetime, revision, userid, logmessage, module, diffUrl) VALUES ";
insertStatement=conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)")
PreparedStatement insertStatement = conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)");
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
StringBuilder bigInsert = new StringBuilder(insertPart);
boolean first = true;
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
String filename = module + parts[1];
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path,project,module)
String fileName = formatFile( path, project, module);
StringBuilder sb = new StringBuilder("update revisions set transactionid = " + transaction + " where fileid in (");
boolean first = true;
st=conn.createStatement()
Statement st = conn.createStatement();
String sql = "select userid, datetime, fileID from revisions where project = '" 
    			+ project + "' and module = '" + module + "' order by userid, datetime asc";
st=conn.createStatement()
Statement st = conn.createStatement();
long timeWindow = 1000 * 60 * 60;
rs=st.getResultSet()
ResultSet rs = st.getResultSet();
String lastUser = null;
String currentUser;
Date lastCommitDate = new Date(0);
Date currentCommitDate;
int transaction = 1;
List<Integer> transactionFileIds = new LinkedList<Integer>();
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionCVSLogParser logParser = new RevisionCVSLogParser();
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
java.util.Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
diffUrl=formatRevisionLink(project,path,revision)
String diffUrl = formatRevisionLink(project, path, revision);
action=fileNode.getAttributes().getNamedItem("action").getTextContent()
String action = fileNode.getAttributes().getNamedItem("action").getTextContent();
String state = "";
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String baseUrl = "http://" + project + ".svn.sourceforge.net/viewvc/" + project;
a=Integer.parseInt(version)
int a = Integer.parseInt(version);
int b = a - 1;
String fileName = path;
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionSVNLogParser logParser = new RevisionSVNLogParser(project, module);
List<ProjectEntry> projects = new ArrayList<ProjectEntry>(100);
int pageNum = projects.size()/10+1;
doc=getDoc("p.xml?page=" + pageNum + "&q=language%3Ajava&sort=users&")
Document doc =getDoc("p.xml?page="+pageNum+"&q=language%3Ajava&sort=users&");
Element resultElement = (Element)element.getElementsByTagName("result").item(0);
projectId=elementIn(projectNode,"id")
String projectId = elementIn(projectNode, "id");
projectName=elementIn(projectNode,"name")
String projectName = elementIn(projectNode, "name");
ProjectEntry p = new ProjectEntry();
boolean complete = false;
int page = 0;
String pageString;
doc=getDoc("p/" + projectId + "/enlistments.xml"+ pageString)
Document doc = getDoc("p/" + projectId+ "/enlistments.xml"+pageString);
itemsReturned=Integer.parseInt(elementIn(response,"items_returned"))
int itemsReturned = Integer.parseInt(elementIn(response, "items_returned"));
itemsAvailable=Integer.parseInt(elementIn(response,"items_available"))
int itemsAvailable = Integer.parseInt(elementIn(response, "items_available"));
firstItemPosition=Integer.parseInt(elementIn(response,"first_item_position"))
int firstItemPosition = Integer.parseInt(elementIn(response, "first_item_position"));
Element resultElement = (Element)response.getElementsByTagName("result").item(0);
type=elementIn(repo,"type")
String type = elementIn(repo, "type");
repoURL=elementIn(repo,"url")
String repoURL = elementIn(repo, "url");
module=elementIn(repo,"module_name")
String module = elementIn(repo, "module_name");
username=elementIn(repo,"username")
String username = elementIn(repo, "username");
password=elementIn(repo,"password")
String password = elementIn(repo, "password");
status=elementIn(repo,"ohloh_job_status")
String status = elementIn(repo, "ohloh_job_status");
Repo r = new Repo(type,repoURL,module,username,password,status);
String pre = "https://www.ohloh.net/";
String post = "api_key=waDryU9cuiDEO64aJLYMA";
URL url = new URL(pre+string+post);
con=url.openConnection()
URLConnection con = url.openConnection();
builder=DocumentBuilderFactory.newInstance().newDocumentBuilder()
DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
doc=builder.parse(con.getInputStream())
Document doc = builder.parse(con.getInputStream());
elem=parent.getElementsByTagName(s)
NodeList elem = parent.getElementsByTagName(s);
StringBuilder sb = new StringBuilder();
Element temp = next;
item=coll.item(pointer++)
Node item = coll.item(pointer++);
wholeText=((Text)item).getWholeText()
String wholeText = ((Text)item).getWholeText();
Element elem = (Element) item;
statusList=element.getElementsByTagName("status")
NodeList statusList = element.getElementsByTagName("status");
statusNode=statusList.item(0)
Node statusNode = statusList.item(0);

Diff of 294ae1129618f7dccc9f5f558ee633c40e8f8e45 and ca156fcc3eb5158008510c691e1c901475032fcb:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 3
	--> recency = years
	--> Added type declarations  = 157
	--> recency = years
	--> Added type parameter methods = 3
	--> recency = years
	--> Added type parameter fields = 3
	--> recency = years
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 72
	--> recency = years
	--> Added class instantiations = 255
	--> recency = years
	--> Added nested = 24
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 294ae1129618f7dccc9f5f558ee633c40e8f8e45 to ca156fcc3eb5158008510c691e1c901475032fcb


****Parsing for addition at revision ca156fcc3eb5158008510c691e1c901475032fcb****


Diff of ca156fcc3eb5158008510c691e1c901475032fcb and 8dea7a3696373866c1fe6e698d2a88e1f66566c6:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 3
	--> recency = years
	--> Added type declarations  = 157
	--> recency = years
	--> Added type parameter methods = 3
	--> recency = years
	--> Added type parameter fields = 3
	--> recency = years
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 72
	--> recency = years
	--> Added class instantiations = 255
	--> recency = years
	--> Added nested = 24
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision ca156fcc3eb5158008510c691e1c901475032fcb to 8dea7a3696373866c1fe6e698d2a88e1f66566c6


****Parsing for addition at revision 8dea7a3696373866c1fe6e698d2a88e1f66566c6****

Added GetTransactions.java to .\generic.tools\ repository source files.
Added Run.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added AnalyzeDeclarations.java to .\generic.tools\ repository source files.
Added GenericDeclVisitor.java to .\generic.tools\ repository source files.
Added Results.java to .\generic.tools\ repository source files.
Added TestVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added CheckoutAll.java to .\generic.tools\ repository source files.
Added TestTimezones.java to .\generic.tools\ repository source files.
Added DevelopersController.2890.java to .\generic.tools\ repository source files.
Added DevelopersController.3838.java to .\generic.tools\ repository source files.
Added AbstractVisitor.java to .\generic.tools\ repository source files.
Added AnnotationVisitor.java to .\generic.tools\ repository source files.
Added CastsVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersAndMethoParametersVisitor.java to .\generic.tools\ repository source files.
Added ClassTypeParametersVisitor.java to .\generic.tools\ repository source files.
Added ContainerGranularity.java to .\generic.tools\ repository source files.
Added HalsteadVisitor.java to .\generic.tools\ repository source files.
Added ParameterizedTypeVisitor.java to .\generic.tools\ repository source files.
Added RawTypesVisitor.java to .\generic.tools\ repository source files.
Added Activator.java to .\generic.tools\ repository source files.
Added Application.java to .\generic.tools\ repository source files.
Added MyAnnotation.java to .\generic.tools\ repository source files.
Added package-info.java to .\generic.tools\ repository source files.
Added TokenizeServer.java to .\generic.tools\ repository source files.
Added Util.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added AdoptionTiming7_3.java to .\generic.tools\ repository source files.
Added Analysis.java to .\generic.tools\ repository source files.
Added AnalyzeAll.java to .\generic.tools\ repository source files.
Added AnnotationAnalysis.java to .\generic.tools\ repository source files.
Added BasicAnalysis.java to .\generic.tools\ repository source files.
Added BasicMetric.java to .\generic.tools\ repository source files.
Added CastAnalysis.java to .\generic.tools\ repository source files.
Added CastInvestigation.java to .\generic.tools\ repository source files.
Added DeveloperFeatureUsage.java to .\generic.tools\ repository source files.
Added GeneralFeatureUsage.java to .\generic.tools\ repository source files.
Added HalsteadAnalysis.java to .\generic.tools\ repository source files.
Added HalsteadMetric.java to .\generic.tools\ repository source files.
Added MethodClassFeatureUsage.java to .\generic.tools\ repository source files.
Added ParameterizedDeclarationAnalysis.java to .\generic.tools\ repository source files.
Added ParameterizedTypeAnalysis.java to .\generic.tools\ repository source files.
Added RawAnalysis.java to .\generic.tools\ repository source files.
Added SQLtoAccess.java to .\generic.tools\ repository source files.
Added TestFile.java to .\generic.tools\ repository source files.
Added UniqueParamAnalysis.java to .\generic.tools\ repository source files.
Added ExtractMethodFinderPlugin.java to .\generic.tools\ repository source files.
Added FindHeteroAdds.java to .\generic.tools\ repository source files.
Added FindInterestingMethods.java to .\generic.tools\ repository source files.
Added HeteroVisitor.java to .\generic.tools\ repository source files.
Added Variable.java to .\generic.tools\ repository source files.
Added VariableReference.java to .\generic.tools\ repository source files.
Added SubtractFinder.java to .\generic.tools\ repository source files.
Added SuperTypeCollector.java to .\generic.tools\ repository source files.
Added FastRevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added FastRevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GitLogParser.java to .\generic.tools\ repository source files.
Added LogParser.java to .\generic.tools\ repository source files.
Added RevisionCVSLogParser.java to .\generic.tools\ repository source files.
Added RevisionSVNLogParser.java to .\generic.tools\ repository source files.
Added GetTop100Projects.java to .\generic.tools\ repository source files.
Added Repo.java to .\generic.tools\ repository source files.
String project = args[0];
String module = args[1];
String jdbcUrl = args[2];
boolean doingGit=false;
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
results=stmt.getResultSet()
ResultSet results = stmt.getResultSet();
files=results.getString("filename")
String files = results.getString("filename");
transId=results.getInt("transactionId")
int transId = results.getInt("transactionId");
datetime=results.getString("datetimestr")
String datetime = results.getString("datetimestr");
state=results.getString("state")
String state = results.getString("state");
revision=results.getString("revision")
String revision = results.getString("revision");
String jdbcUrl = "jdbc:mysql://chimp.cs.ubc.ca:4747/udc_temp";
conn=DriverManager.getConnection(jdbcUrl,"chris","capcom")
Connection conn = DriverManager.getConnection(jdbcUrl,"chris","capcom");
Hashtable<Integer, User> users = new Hashtable<Integer, User>();
FileWriter writer = new FileWriter("results.txt");
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
results=stmt.getResultSet()
ResultSet results = stmt.getResultSet();
userid=results.getInt("userId")
int userid = results.getInt("userId");
User user = new User();
user=users.get(userid)
User user = users.get(userid);
week=results.getInt("weekday")
int week = results.getInt("weekday");
count=results.getInt("count")
int count = results.getInt("count");
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
int zeroRows = 0;
results=stmt.getResultSet()
ResultSet results = stmt.getResultSet();
userid=results.getInt("userId")
int userid = results.getInt("userId");
user=users.get(userid)
User user = users.get(userid);
week=results.getInt("weekday")
int week = results.getInt("weekday");
count=results.getInt("count")
int count = results.getInt("count");
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit)parser.createAST(new NullProgressMonitor());
GenericDeclVisitor v = new GenericDeclVisitor();
TestVisitor test = new TestVisitor();
SimpleType st = (SimpleType)t;
b=st.getName().resolveBinding()
IBinding b = st.getName().resolveBinding();
gb=computeDistanceToDecl(st.getName())
GenericBinding gb = computeDistanceToDecl(st.getName());
bound=((WildcardType)t).getBound()
Type bound = ((WildcardType) t).getBound();
ArrayType at = (ArrayType) t;
QualifiedType qt = (QualifiedType) t;
ASTNode node = sn;
int depth = 0;
targetName=sn.getFullyQualifiedName()
String targetName = sn.getFullyQualifiedName();
TypeParameter tp = (TypeParameter) o;
TypeParameter tp = (TypeParameter) o;
superclassType=td.getSuperclassType()
Type superclassType = td.getSuperclassType();
returnType=md.getReturnType2()
Type returnType = md.getReturnType2();
SingleVariableDeclaration sd = (SingleVariableDeclaration) o;
A a2;
M m2;
A a2;
M m2;
binding=st.resolveBinding()
IBinding binding = st.resolveBinding();
Set<Type> otherCopy = new HashSet<Type>(typesProducedByOtherVisitor);
Set<Type> thisCopy = new HashSet<Type>(found);
List<ProjectInterval> changes = new ArrayList<ProjectInterval>();
activeEditor=targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor()
IEditorPart activeEditor = targetPart.getSite().getWorkbenchWindow().getActivePage().getActiveEditor();
ITextSelection selection = (ITextSelection)((ITextEditor)activeEditor).getSelectionProvider().getSelection();
lines=selection.getText()
String lines = selection.getText();
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S");
str=line.replace("\r","").replace("\n","")
String str = line.replace("\r", "").replace("\n", "");
components=line.split(",")
String[] components = line.split(",");
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
IWorkbenchAdapter adapter = (IWorkbenchAdapter)firstElement;
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
IStructuredSelection selection = (IStructuredSelection)((PluginAction) activeAction).getSelection();
firstElement=selection.getFirstElement()
Object firstElement = selection.getFirstElement();
ICVSRemoteFolder f = (ICVSRemoteFolder)firstElement;
l=((CVSTagElement)firstElement).getRoot()
ICVSRepositoryLocation l = ((CVSTagElement)firstElement).getRoot();
resources=getRemoteResource()
ICVSRemoteResource[] resources = getRemoteResource();
List<CheckoutSingleProjectOperation> checkouts = 
			new LinkedList<CheckoutSingleProjectOperation>();
Job job = new Job("Checking out..."){
			public IStatus run(IProgressMonitor mon){
				
				mon.beginTask("Checking out projects from CVS", checkouts.size());
				
				List<IStatus> status = new ArrayList<IStatus>();
				
				for(CheckoutSingleProjectOperation checkout : checkouts){
					try {
						checkout.execute(new SubProgressMonitor(mon,1));						
						checkForErrors(status,checkout);
					} catch (Exception e) {
						e.printStackTrace();
					}
					 if (mon.isCanceled()) return Status.CANCEL_STATUS;
				}
				
				mon.done();
				
				return new MultiStatus(	Activator.PLUGIN_ID, 
										IStatus.WARNING, 
										status.toArray(new IStatus[0]), 
										"Checkout Warnings", 
										new RuntimeException());
			}

			private void checkForErrors(List<IStatus> existing, CheckoutSingleProjectOperation checkout) throws Exception {
				Method m = CVSOperation.class.getDeclaredMethod("getErrors");
				m.setAccessible(true);
				IStatus[] status = (IStatus[]) m.invoke(checkout);
				for(IStatus s : status){
					existing.add(s);
				}
			}
		};
List<IStatus> status = new ArrayList<IStatus>();
m=CVSOperation.class.getDeclaredMethod("getErrors")
Method m = CVSOperation.class.getDeclaredMethod("getErrors");
IStatus[] status = (IStatus[]) m.invoke(checkout);
Calendar cal = new GregorianCalendar();
Timestamp timestamp = new Timestamp(timeInUTC.getTime()
				+ cal.get(Calendar.DST_OFFSET) + cal.get(Calendar.ZONE_OFFSET)
				+ offset);
projectBefore=remoteFolderAtTime(time)
RemoteFolder projectBefore = remoteFolderAtTime(time);
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH.mm.ss");
String projectName = this.projectName + " " + df.format(time) + " " + resource.getName() + " " + postfix;
newProject=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName)
IProject newProject = ResourcesPlugin.getWorkspace().getRoot().
						getProject(projectName);
Timestamp predaylightSavings = new Timestamp(1172625369000l);
int oneMonthInMillis = 1000*60*60*24*50000000;
Timestamp postDaylightSavings = new Timestamp(1172625369000l+oneMonthInMillis);
Timestamp old = new Timestamp(fromDb.getTime()-60*60*1000*8);
nu=localTime(fromDb)
Timestamp nu = localTime(fromDb);
Calendar cal = new GregorianCalendar();
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList newProps = new ArrayList();
ArrayList replaceProps = new ArrayList();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{new Integer(occurrences),
													          new Integer(occurrencesFound),
																 files[i].getPath() };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[]{new Integer(newProps.size()), new Integer(replaceProps.size()), i18nStringFile.getPath()};
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList linesToPrint = new ArrayList();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
sourceDir=prefs.get(PREF_KEY_SOURCE_DIR,null)
String sourceDir = prefs.get(PREF_KEY_SOURCE_DIR, null);
startDir=System.getProperties().getProperty("user.home")
String startDir = System.getProperties().getProperty("user.home");
JFileChooser chooser = new JFileChooser(startDir);
sourceDir=getSourceDir()
File sourceDir = getSourceDir();
files=sourceDir.listFiles()
File[] files = sourceDir.listFiles();
ArrayList<String> newProps = new ArrayList<String>();
ArrayList<String> replaceProps = new ArrayList<String>();
File i18nStringFile = new File(sourceDir, "I18NStrings.properties");
Properties curProps = new Properties();
FileInputStream fis;
int occurrences = 0;
StringBuffer code = new StringBuffer();
buf=fis.read()
int buf = fis.read();
occurrencesFound=fixSourceFile(files[i].getAbsolutePath())
int occurrencesFound = fixSourceFile(files[i].getAbsolutePath());
Object[] params =
                                    new Object[]{
                                        Integer.valueOf(occurrences),
										Integer.valueOf(occurrencesFound),
										files[i].getPath() 
                                    };
msg=s_stringMgr.getString("i18n.unequalOccurrences",params)
String msg = s_stringMgr.getString("i18n.unequalOccurrences", params);
Object[] params = new Object[]{files[i].getPath(), e.toString()};
FileOutputStream fos = new FileOutputStream(i18nStringFile, true);
PrintWriter ps = new PrintWriter(fos);
includeTimestamp=prefs.get(PREF_KEY_INCLUDE_TIMESTAMP,"true")
String includeTimestamp = prefs.get(PREF_KEY_INCLUDE_TIMESTAMP, "true");
Object[] params = new Object[] {
                        Integer.valueOf(newProps.size()), 
                        Integer.valueOf(replaceProps.size()), 
                        i18nStringFile.getPath()
                };
int occurrences = 0;
pat=Pattern.compile("//\\x20*i18n\\[(.*)")
Pattern pat = Pattern.compile("//\\x20*i18n\\[(.*)");
m=pat.matcher(code)
Matcher m = pat.matcher(code);
int[] propBounds = new int[]{0,0};
prop=getProp(code,propBounds)
String prop = getProp(code, propBounds);
equalsPos=prop.indexOf('=')
int equalsPos = prop.indexOf('=');
key=prop.substring(0,equalsPos)
String key = prop.substring(0, equalsPos);
val=prop.substring(equalsPos + 1).trim()
String val = prop.substring(equalsPos + 1).trim();
boolean found = false;
boolean isInComment = true;
boolean isABracket = false;
boolean isASlash = false;
boolean isInCommentBegin = false;
StringBuffer ret = new StringBuffer();
buf=_panel.txtSourceDir.getText()
String buf = _panel.txtSourceDir.getText();
msg=s_stringMgr.getString("I18n.NoSourceDir")
String msg = s_stringMgr.getString("I18n.NoSourceDir");
File sourceDir = new File(buf);
msg=s_stringMgr.getString("I18n.SourceDirIsNotADirectory",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirIsNotADirectory", sourceDir.getPath());
msg=s_stringMgr.getString("I18n.SourceDirDoesNotExist",sourceDir.getPath())
String msg = s_stringMgr.getString("I18n.SourceDirDoesNotExist", sourceDir.getPath());
BufferedReader in = new BufferedReader(new FileReader(filename));
nextLine=in.readLine()
String nextLine = in.readLine();
String lineToPrint = nextLine;
int occurrencesReplaced = 0;
boolean writeFixFile =false;
ArrayList<String> linesToPrint = new ArrayList<String>();
pat=Pattern.compile("\\s*//\\s*i18n\\[(.*)")
Pattern pat = Pattern.compile("\\s*//\\s*i18n\\[(.*)");
commentLinePattern=Pattern.compile("\\s*//")
Pattern commentLinePattern = Pattern.compile("\\s*//");
m=pat.matcher(nextLine)
Matcher m = pat.matcher(nextLine);
parts=nextLine.split("\\[")
String[] parts = nextLine.split("\\[");
String key = parts[0];
String val = parts[1];
commentMatch=commentLinePattern.matcher(nextLine)
Matcher commentMatch = commentLinePattern.matcher(nextLine);
String quotedVal = "\"" + val + "\"";
indexOfQuotedVal=nextLine.indexOf(quotedVal)
int indexOfQuotedVal = nextLine.indexOf(quotedVal);
String stringManager = "s_stringMgr.getString(\"" + key + "\")";
String stringManagerBegin = "s_stringMgr.getString(\"" + key + "\"";
String outFileName = filename + ".fixed";
PrintWriter out = new PrintWriter(new FileOutputStream(outFileName));
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator<?> iter = s.iterator();
Iterator<?> iter = s.iterator();
StringBuffer s = new StringBuffer();
int bracketCount = 0;
chars=containerSignature.toCharArray()
char []chars = containerSignature.toCharArray();
parent=input.getParent()
ASTNode parent = input.getParent();
ArrayList<String> names = new ArrayList<String>();
SingleVariableDeclaration param = (SingleVariableDeclaration)method.parameters().get(i);
parent=GetEnclosingContainer(input)
ASTNode parent = GetEnclosingContainer(input);
String name = "ERROR";
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
List<String> values = new ArrayList<String>();
MemberValuePair pair = (MemberValuePair)obj;
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
MethodDeclaration meth = (MethodDeclaration)node;
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
parent=GetParentName(annotation.getParent())
String parent = GetParentName(annotation.getParent());
property=annotation.getTypeNameProperty().toString()
String property = annotation.getTypeNameProperty().toString();
typeName=annotation.getTypeName()
Name typeName = annotation.getTypeName();
lineNumber=Unit.getLineNumber(cast.getStartPosition())
int lineNumber = Unit.getLineNumber(cast.getStartPosition());
t=cast.getType()
Type t = cast.getType();
parent=GetEnclosingContainerName(cast)
String parent = GetEnclosingContainerName(cast);
lineNumber=Unit.getLineNumber(method.getStartPosition())
int lineNumber = Unit.getLineNumber(method.getStartPosition());
name=method.getName().getFullyQualifiedName()
String name = method.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
lineNumber=Unit.getLineNumber(type.getStartPosition())
int lineNumber = Unit.getLineNumber(type.getStartPosition());
name=type.getName().getFullyQualifiedName()
String name = type.getName().getFullyQualifiedName();
ArrayList<String> names = new ArrayList<String>();
TypeParameter p = (TypeParameter)param;
binding=type.resolveBinding()
ITypeBinding binding = type.resolveBinding();
ParameterizedType pt = (ParameterizedType) type;
lineNumber=Unit.getLineNumber(pt.getStartPosition())
int lineNumber = Unit.getLineNumber(pt.getStartPosition());
parent=GetEnclosingContainerName(pt)
String parent = GetEnclosingContainerName(pt);
StringBuffer typeArgs = new StringBuffer();
boolean first = true;
String rawTypesString = "BlockingQueue, List, Queue, Set, SortedSet, AbstractCollection, AbstractList, " +
				"AbstractQueue, AbstractSequentialList, AbstractSet, ArrayBlockingQueue, ArrayList, ConcurrentLinkedQueue, " +
				"CopyOnWriteArrayList, CopyOnWriteArraySet, DelayQueue, EnumSet, HashSet, LinkedBlockingQueue, LinkedHashSet, " +
				"LinkedList, PriorityBlockingQueue, PriorityQueue, Stack, SynchronousQueue, TreeSet, Vector, " + 
				"Map, ConcurrentMap, SortedMap, AbstractMap, ConcurrentHashMap, EnumMap, HashMap, Hashtable, IdentityHashMap, " +
				"LinkedHashMap, TreeMap, WeakHashMap";
ParameterizedType pt = (ParameterizedType) type;
o=type.getProperty("typeArguments")
Object o = type.getProperty("typeArguments");
parts=type.toString().split("\\.")
String[] parts = type.toString().split("\\.");
String simpleTypeName = parts[parts.length-1];
lineNumber=sourceNode.getStartPosition()
int lineNumber = sourceNode.getStartPosition();
parent=GetEnclosingContainerName(sourceNode)
String parent = GetEnclosingContainerName(sourceNode);
sp=type.structuralPropertiesForType()
List sp = type.structuralPropertiesForType();
type=node.getReturnType2()
Type type = node.getReturnType2();
SingleVariableDeclaration svd = (SingleVariableDeclaration) o;
type=node.getType()
Type type = node.getType();
String foo;
int a, b = 4, c;
List badList;
String bar = "fred";
List<String> l = new LinkedList<String>();
java.util.Map m;
options=ProcessCommandArgs()
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		Hashtable<String,String> options = ProcessCommandArgs();
@MyAnnotation(first="local",last=11)
		int test,test1,test2;
String output = "output.txt";
TokenizeServer server = new TokenizeServer(this);
int port = 6000;
Writer outputWriter = new FileWriter(output);
File dir = new File(options.get("directory"));
path=javaFile.getAbsolutePath()
String path = javaFile.getAbsolutePath();
List<File> files = new LinkedList<File>();
args=Platform.getCommandLineArgs()
String[] args = Platform.getCommandLineArgs();
Hashtable<String,String> options = new Hashtable<String,String>();
String arg = args[i];
BufferedReader r=null;
StringBuffer buffer = new StringBuffer();
String line = null;
buffer=GetFileContents(file)
StringBuffer buffer = GetFileContents(file);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
node=parser.createAST(null)
ASTNode node = parser.createAST(null);
visitor=AbstractVisitor.getVisitor(pattern,output)
AbstractVisitor visitor = AbstractVisitor.getVisitor(pattern, output);
FileWriter writer = null;
int x = (int)3.0f;
T too = null;
T[] array = (T[]) new Object[3];
ArrayList<T> a = new ArrayList<T>();
List<Double> ints = new ArrayList<Double>();
List<Double> nums = ints;
List<Double> nums = ints;
x=ints.get(1)
Number x=ints.get(1);
lineNumber=Unit.getLineNumber(t.getStartPosition())
int lineNumber = Unit.getLineNumber(t.getStartPosition());
lineNumber=Unit.getLineNumber(p.getStartPosition())
int lineNumber = Unit.getLineNumber(p.getStartPosition());
scanner=ToolFactory.createScanner(true,true,false,true)
IScanner scanner = ToolFactory.createScanner(true, true, false, true);
int token = 0;
ServerSocket serverSocket = new ServerSocket(port);
BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
Writer out = new PrintWriter(clientSocket.getOutputStream(), true);
request=reader.readLine()
String request = reader.readLine();
parts[]=request.trim().split(":")
String parts[] = request.trim().split(":");
String filepath = parts[0];
String pattern = parts[1];
ContainerGranularity containerGranularity = ContainerGranularity.FULL;
String args = parts[2];
argParts[]=args.split("=")
String argParts[] = args.split("=");
gran=argParts[1].trim().toLowerCase()
String gran = argParts[1].trim().toLowerCase();
StringBuffer buffer = new StringBuffer();
iter=s.iterator()
Iterator iter = s.iterator();
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						"DBQ=C:/Users/Adminuser/Documents/java_generics_working_copy.accdb");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
String annotationsQuery = new AnnotationAnalysis(null).query()+", revisions.DateTime";
String typesQuery = new ParameterizedTypeAnalysis(null).query()+", revisions.DateTime";
Hashtable<String,ProjectTiming> timing = new Hashtable<String,ProjectTiming>();
set=s.executeQuery(annotationsQuery)
ResultSet set = s.executeQuery(annotationsQuery);
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
date=set.getDate("revisions.DateTime")
Date date = set.getDate("revisions.DateTime");
ProjectTiming p = new ProjectTiming();
Connection conn = null;
Statement statement = null;
ResultSet results = null;
results=statement.executeQuery(query())
ResultSet results = statement.executeQuery(query());
Map<String,Revision> mostRecentRevision = new HashMap<String, Revision>();
t=e.getKey()
Timestamp t = e.getKey();
String lastProjectName = null;
Revision rev = new Revision();
project=r.getString("revisions.project")
String project = r.getString("revisions.project");
project=projects.get(projectName)
Project project = projects.get(projectName);
revs=project.timeToRevs.get(time)
List<Revision> revs = project.timeToRevs.get(time);
List<Revision> revs = project.timeToRevs.get(time);
String url = "jdbc:mysql://eb2-2291-fas01.csc.ncsu.edu:4747/generics?netTimeoutForStreamingResults=200000";
FileWriter writer = new FileWriter("output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("an_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
int total = 0;
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
revs=getRevisionsFor(timestamp,projectName)
List<Revision> revs = getRevisionsFor(timestamp,projectName);
List<Revision> revs = getRevisionsFor(timestamp,projectName);
int val = 0;
tg=gatherResults()
TimeGraph<CombinedMetric> tg = gatherResults();
TimeGraph<CombinedMetric> tg = gatherResults();
PrintWriter out = new PrintWriter(System.out);
CastReducer cr = new CastReducer(out);
GenericReducer gr = new GenericReducer(out);
HalsteadReducer hr = new HalsteadReducer(out);
TimeGraph<CombinedMetric> tg = new TimeGraph<CombinedMetric>();
project=e.getKey()
String project = e.getKey();
CombinedMetric cm = new CombinedMetric();
map=cr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map = cr.tg.totals.get(project);
map2=gr.tg.totals.get(project)
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
Map<Timestamp, BasicMetric> map2 = gr.tg.totals.get(project);
CombinedMetric last = null;
map=totals.get(projectName)
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
SortedMap<Timestamp, Metric> map = totals.get(projectName);
castIncrease=subset(projectName,castIncreasePredicate)
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
ArrayList<Timestamp> castIncrease = subset(projectName,castIncreasePredicate);
Random r = new Random();
Set<Timestamp> stamps = new HashSet<Timestamp>();
rand=r.nextInt(castIncrease.size())
int rand = r.nextInt(castIncrease.size());
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
statement=conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?")
PreparedStatement statement = conn.prepareStatement("SELECT DISTINCT module from revisions where DateTime = ? AND project = ?");
rs=statement.executeQuery()
ResultSet rs = statement.executeQuery();
module=rs.getString(1)
String module = rs.getString(1);
next=values.next()
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
SortedMap<Timestamp, Metric> next = values.next();
metrics=totals.get(projectName)
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
SortedMap<Timestamp, Metric> metrics = totals.get(projectName);
castIncrease=PredicatedSortedMap.decorate(new TreeMap<Timestamp,Metric>(),TruePredicate.INSTANCE,castIncreasePredicate)
@SuppressWarnings("unchecked")
		SortedMap<Timestamp, Metric> castIncrease = PredicatedSortedMap.decorate(new TreeMap<Timestamp, Metric>(), TruePredicate.INSTANCE, castIncreasePredicate);
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,DeveloperData> devInfo = new Hashtable<String,DeveloperData>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
kind=set.getString(paramDecs() + ".kind")
String kind = set.getString(paramDecs()+".kind");
num=set.getString("num")
String num = set.getString("num");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
String key = project+"^_^"+userId;
DeveloperData data = new DeveloperData();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
num=set.getInt("num")
int num = set.getInt("num");
String key = project+"^_^"+userId;
devAnnotations=CalculateAnnotationsDeltas(s)
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
Hashtable<String,Integer> devAnnotations = CalculateAnnotationsDeltas(s);
DeveloperData data = new DeveloperData();
Hashtable<String,Integer> developerCount = new Hashtable<String,Integer>();
set=s.executeQuery(annotationsQuery())
ResultSet set = s.executeQuery(annotationsQuery());
Hashtable<String,Integer> fileCount = new Hashtable<String,Integer>();
project=set.getString("revisions.project")
String project = set.getString("revisions.project");
module=set.getString("revisions.module")
String module = set.getString("revisions.module");
file=set.getString("revisions.filename")
String file = set.getString("revisions.filename");
userId=set.getString("revisions.userId")
String userId = set.getString("revisions.userId");
state=set.getString("revisions.state")
String state = set.getString("revisions.state");
String key = project + "." + module + "." + file;
int last = 0;
int delta =  set.getInt("num") - last;
int lastDev = 0;
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
project=set.getString("project")
String project = set.getString("project");
num=set.getInt("num")
int num = set.getInt("num");
sumMetric=metricFrom(mostRecentRevisions.values())
HalsteadMetric sumMetric = metricFrom(mostRecentRevisions.values());
timeString=time.toString().replace(".0","")
String timeString = time.toString().replace(".0", "");
HalsteadMetric m = new HalsteadMetric();
HalsteadMetric sumMetric = new HalsteadMetric();
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(totalQuery())
ResultSet set = s.executeQuery(totalQuery());
project=set.getString("project")
String project = set.getString("project");
module=set.getString("module")
String module = set.getString("module");
filename=set.getString("filename")
String filename = set.getString("filename");
kind=set.getString("kind")
String kind = set.getString("kind");
classType=set.getString("class_type")
String classType = set.getString("class_type");
typeArgs=set.getString("type_args")
String typeArgs = set.getString("type_args");
String key = module + "." + filename + "." + classType + "." + typeArgs;
FileWriter writer = new FileWriter("pt_output.sql");
BufferedWriter out = new BufferedWriter(writer);
FileWriter writer = new FileWriter("raw_output.sql");
BufferedWriter out = new BufferedWriter(writer);
BasicMetric m = new BasicMetric(0);
l=rs.getString("num")
String l = rs.getString("num");
connection=getConnection()
Connection connection = getConnection();
s=connection.createStatement()
Statement s = connection.createStatement();
FileInputStream fis = new FileInputStream(sqlFileLocation);
DataInputStream dis = new DataInputStream(fis);
BufferedReader br = new BufferedReader(new InputStreamReader(dis));
String line;
c=DriverManager.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" + "DBQ=C:/schoolwork/activity/generics/working_database.accdb")
Connection c = DriverManager
				.getConnection("jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};" +
						//"DBQ=C:/Users/Adminuser/Documents/Database2.accdb");
						"DBQ=C:/schoolwork/activity/generics/working_database.accdb");
String url = "jdbc:mysql://eb2-2291-fas01.csc.ncsu.edu:4747/generics?netTimeoutForStreamingResults=200000";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
set=s.executeQuery("SELECT project,baseEncodedAttachment FROM table")
ResultSet set = s.executeQuery("SELECT project,baseEncodedAttachment FROM table");
project=set.getString("project")
String project = set.getString("project");
module=set.getString("baseEncodedAttachment")
String module = set.getString("baseEncodedAttachment");
conn=Analysis.getDatabaseConnection()
Connection conn = Analysis.getDatabaseConnection();
s=conn.createStatement()
Statement s = conn.createStatement();
Hashtable<String,ProjectInfo> projectInfo = new Hashtable<String,ProjectInfo>();
set=s.executeQuery(query())
ResultSet set = s.executeQuery(query());
project=set.getString("proj")
String project = set.getString("proj");
classType=set.getString("class")
String classType = set.getString("class");
HeteroVisitor visitor = new HeteroVisitor(u);
projectName=u.getJavaProject().getElementName()
String projectName = u.getJavaProject().getElementName();
path=u.getResource().getFullPath()
IPath path = u.getResource().getFullPath();
writer=getWriter()
FileWriter writer = getWriter();
superTypes=ref.superTypes()
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
SortedMap<String, Integer> superTypes = ref.superTypes();
JFileChooser fr = new JFileChooser();
fw=fr.getFileSystemView()
FileSystemView fw = fr.getFileSystemView();
dir=fw.getDefaultDirectory().toString()
String dir = fw.getDefaultDirectory().toString();
FileWriter writer = new FileWriter(dir + "/HeteroAdds.sql", true);
ProgressMonitorDialog d = new ProgressMonitorDialog(
					PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell()
					);
IStructuredSelection sel = (IStructuredSelection)selection;
iter=sel.iterator()
Iterator<?> iter = sel.iterator();
Iterator<?> iter = sel.iterator();
o=iter.next()
Object o = iter.next();
IParent parent = (IParent)o;
unit=unitsToInspect.get(i)
ICompilationUnit unit = unitsToInspect.get(i);
p=JavaUI.openInEditor(m)
IEditorPart p = JavaUI.openInEditor(m);
parser=ASTParser.newParser(AST.JLS3)
ASTParser parser = ASTParser.newParser(AST.JLS3);
CompilationUnit node = (CompilationUnit) parser
				.createAST(new NullProgressMonitor());
methodName=mi.getName().getIdentifier()
String methodName = mi.getName().getIdentifier();
expression=mi.getExpression()
Expression expression = mi.getExpression();
SimpleName sn = (SimpleName) expression;
binding=sn.resolveBinding()
IBinding binding = sn.resolveBinding();
IVariableBinding varBinding = (IVariableBinding) binding;
type=varBinding.getType()
ITypeBinding type = varBinding.getType();
decl=varBinding.getVariableDeclaration()
IVariableBinding decl = varBinding
								.getVariableDeclaration();
existingTypes=typeInserts.get(decl)
List<Expression> existingTypes = typeInserts.get(decl);
List<Expression> existingTypes = typeInserts.get(decl);
Expression expr = (Expression) mi.arguments().get(0);
List<Bag<String>> superClasses = new LinkedList<Bag<String>>();
Set<String> baseClasses = new HashSet<String>();
iterator=ref.superTypes().entrySet().iterator()
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
Iterator<Entry<String, Integer>> iterator = ref.superTypes().entrySet().iterator();
int i = 0;
pair=iterator.next()
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Entry<String, Integer> pair = iterator.next();
Bag<String> potentialsSoFar = new HashBag<String>();
HashMap<String, Integer> superTypes = new HashMap<String, Integer>();
expressionType=expression.resolveTypeBinding()
ITypeBinding expressionType = expression.resolveTypeBinding();
SuperTypeMapSort sortedSuperTypes = new SuperTypeMapSort(superTypes);
SortedMap<String, Integer> sortedMap = new TreeMap<String, Integer>(
				sortedSuperTypes);
binding=expression.resolveTypeBinding()
ITypeBinding binding = expression.resolveTypeBinding();
bindingName=typeBinding.getName()
String bindingName = typeBinding.getName();
List<ITypeBinding> directSupertypes = new ArrayList<ITypeBinding>(
				Arrays.asList(typeBinding.getInterfaces()));
superClass=typeBinding.getSuperclass()
ITypeBinding superClass = typeBinding.getSuperclass();
oldLevel=superTypes.get(bindingName)
Integer oldLevel = superTypes.get(bindingName);
int diff = sort.get(x) - sort.get(y);
ArrayList<String> subtracts = new ArrayList<String>();
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;")
PreparedStatement stmt = conn.prepareStatement("SELECT DISTINCT project FROM generics.parameterized_declarations;");
rs=stmt.executeQuery()
ResultSet rs = stmt.executeQuery();
ArrayList<String> projects = new ArrayList<String>();
String count = "", previous = "";
rsRevisions=stmt.executeQuery()
ResultSet rsRevisions = stmt.executeQuery();
ArrayList<Integer> revisions = new ArrayList<Integer>();
r=rsRevisions.getInt(1)
Integer r = rsRevisions.getInt(1);
rsCount=stmt.executeQuery()
ResultSet rsCount = stmt.executeQuery();
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://eb2-2291-fas01.csc.ncsu.edu:4747/generics";
conn=getDatabaseConnection()
Connection conn = getDatabaseConnection();
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
ResultSet rs;
projectName=rs.getString("ProjectName")
String projectName = rs.getString("ProjectName");
declType=rs.getString("DeclType")
String declType = rs.getString("DeclType");
String dbUsername, dbPassword;
InputDialog dbUser = new InputDialog(null, "DB Credential Check", "Enter your MySQL User Name:", "USERNAME", null);
InputDialog dbPass = new InputDialog(null, "DB Credential Check", "Enter your MySQL Password:", "PASSWORD", null);
String url = "jdbc:mysql://eb2-2291-fas01.csc.ncsu.edu:4747/generics";
File dataFile = new File(project + "/" + module + ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(dataFile));
st=conn.createStatement()
Statement st = conn.createStatement();
List<Revision> revisions = new ArrayList<Revision>();
Revision revisionInst = new Revision();
BufferedReader reader = new BufferedReader(new FileReader(file));
String line, path;
String timestampStr;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
long timeWindow = 1000 * 60 * 15;
DateFormat CVSDateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
DateFormat otherCVSDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);\\s+state: ([^;]+);", flags);
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
pattern=Pattern.compile("branches:\\s+[0-9.]+;")
Pattern pattern = Pattern.compile("branches:\\s+[0-9.]+;");
matcherLog=pattern.matcher(revisionInst.logMessage)
Matcher matcherLog = pattern.matcher(revisionInst.logMessage);
int transactionId = 1;
Revision r1, r2;
int j;
Hashtable<Integer, List<Revision>> trans = new Hashtable<Integer, List<Revision>>();
List<Transaction> transactions = new ArrayList<Transaction>();
Transaction t = new Transaction(trans.get(id));
int id = 0;
overlaps=FindOverlaps(transactions)
HashSet<Transaction> overlaps = FindOverlaps(transactions);
HashSet<Transaction> overlaps = FindOverlaps(transactions);
overlapSize=overlaps.size()
int overlapSize = overlaps.size();
tempPath=dataFile.getAbsolutePath()
String tempPath = dataFile.getAbsolutePath();
o=c.Parent.HasRevisionWithFile(r.filename)
Revision o = c.Parent.HasRevisionWithFile(r.filename);
oVersion=Integer.parseInt(o.revision.split("[.]")[1])
int oVersion = Integer.parseInt(o.revision.split("[.]")[1]);
rVersion=Integer.parseInt(r.revision.split("[.]")[1])
int rVersion = Integer.parseInt(r.revision.split("[.]")[1]);
HashSet<Transaction> overlaps = new HashSet<Transaction>();
boolean afterStart = t.First().date.compareTo(p.Last().date) < 0;
boolean overlapsStart = p.Last().date.compareTo(t.Last().date) < 0;
boolean beforeEnd = t.Last().date.compareTo(p.First().date) > 0;
boolean overlapsEnd = p.First().date.compareTo(t.First().date) > 0;
String info = t.First().date + " to " + t.Last().date + " overlaps with " + 
					              p.First().date + " to " + p.Last().date;
String nums = t.Id + " " + p.Id;
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
filename=parts[1].replace("/Attic","")
String filename = parts[1].replace("/Attic", "");
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path)
String fileName = formatFile(path);
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
FastRevisionCVSLogParser logParser = new FastRevisionCVSLogParser();
BufferedWriter sqlWriter = new BufferedWriter(new FileWriter(outputBase + ".sql"));
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(outputBase + ".data"));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
String project = args[0];
String logFilename = args[1];
String outputBase = args[2];
FastRevisionSVNLogParser logParser = new FastRevisionSVNLogParser(project);
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
BufferedReader logReader = new BufferedReader(new FileReader(file));
DateFormat gitDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
StringBuilder sb;
String line;
String revision, committer, parent, msg, status, path, diffUrl;
Date dateTime;
String[] parts;
int transaction = 1;
boolean validTransaction = false;
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String logCmd = "git log --reverse --full-history --all --date=iso --name-status -M -C --pretty=format:\"" +
    			"__START_GIT_COMMIT_LOG_MSG__%nrevision: %H%ncommitter: %cn%ndate: %ci%nparent: %P%n%s%n%b%n__END_GIT_COMMIT_LOG_MSG__\"";
String project = args[0];
String logFilename = args[1];
String jdbcUrl = args[2];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
GitLogParser logParser = new GitLogParser(project);
nodeList=node.getElementsByTagName(tag)
NodeList nodeList = node.getElementsByTagName(tag);
Element valueNode = (Element)nodeList.item(0);
stmt=conn.createStatement()
Statement stmt = conn.createStatement();
conn=DriverManager.getConnection(jdbcUrl)
Connection conn = DriverManager.getConnection(jdbcUrl);
BufferedReader reader = new BufferedReader(new FileReader(file));
String line;
String filename, revision, author, timestampStr;
Timestamp timestamp;
String fileEntryDelimiter = "=============================================================================";
String revisionEntryDelimiter = "----------------------------";
DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
int flags = Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.UNIX_LINES;
filenamePattern=Pattern.compile("(working|RCS) file:(.+)",flags)
Pattern filenamePattern = Pattern.compile("(working|RCS) file:(.+)", flags);
revisionPattern=Pattern.compile("revision (.+)",flags)
Pattern revisionPattern = Pattern.compile("revision (.+)", flags);
infoPattern=Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);",flags)
Pattern infoPattern = Pattern.compile("date: ([^;]+);\\s+ author: ([^;]+);", flags);
statement=conn.createStatement()
Statement statement = conn.createStatement();
String insertPart = "insert into revisions (project, filename, datetime, revision, userid, logmessage, module, diffUrl) VALUES ";
insertStatement=conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)")
PreparedStatement insertStatement = conn.prepareStatement(insertPart + "(?, ?, ?, ?, ?, ?, ?,?)");
boolean done = false;
int i = 0;
fm=filenamePattern.matcher(line.trim())
Matcher fm = filenamePattern.matcher(line.trim());
StringBuilder bigInsert = new StringBuilder(insertPart);
boolean first = true;
rm=revisionPattern.matcher(line)
Matcher rm = revisionPattern.matcher(line);
im=infoPattern.matcher(line)
Matcher im = infoPattern.matcher(line);
StringBuilder logBuilder = new StringBuilder();
parts=path.split(Pattern.quote(project + "/" + module))
String[] parts = path.split(Pattern.quote(project + "/" + module));
String filename = module + parts[1];
String baseUrl = "http://" + project + ".cvs.sourceforge.net/viewvc/" + project + "/";
v=version.split("[.]")
String[] v = version.split("[.]");
a=Integer.parseInt(v[1])
int a = Integer.parseInt(v[1]);
int b = a - 1;
fileName=formatFile(path,project,module)
String fileName = formatFile( path, project, module);
StringBuilder sb = new StringBuilder("update revisions set transactionid = " + transaction + " where fileid in (");
boolean first = true;
st=conn.createStatement()
Statement st = conn.createStatement();
String sql = "select userid, datetime, fileID from revisions where project = '" 
    			+ project + "' and module = '" + module + "' order by userid, datetime asc";
st=conn.createStatement()
Statement st = conn.createStatement();
long timeWindow = 1000 * 60 * 60;
rs=st.getResultSet()
ResultSet rs = st.getResultSet();
String lastUser = null;
String currentUser;
Date lastCommitDate = new Date(0);
Date currentCommitDate;
int transaction = 1;
List<Integer> transactionFileIds = new LinkedList<Integer>();
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionCVSLogParser logParser = new RevisionCVSLogParser();
temp=File.createTempFile(file.getName(),".data")
File temp = File.createTempFile(file.getName(), ".data");
BufferedWriter dataWriter = new BufferedWriter(new FileWriter(temp));
dbf=DocumentBuilderFactory.newInstance()
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
db=dbf.newDocumentBuilder()
DocumentBuilder db = dbf.newDocumentBuilder();
doc=db.parse(file)
Document doc = db.parse(file);
DateFormat SVNDateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
DateFormat SQLDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
deleteStatement=conn.createStatement()
Statement deleteStatement = conn.createStatement();
nodeList=doc.getElementsByTagName("logentry")
NodeList nodeList = doc.getElementsByTagName("logentry");
StringBuilder bigQuery;
Element entryNode = (Element)nodeList.item(i);
revision=entryNode.getAttribute("revision")
String revision = entryNode.getAttribute("revision");
author=getText(entryNode,"author")
String author = getText(entryNode, "author");
msg=getText(entryNode,"msg")
String msg = getText(entryNode, "msg");
dateStr=getText(entryNode,"date")
String dateStr = getText(entryNode, "date");
date=SVNDateFormat.parse(dateStr)
java.util.Date date = SVNDateFormat.parse(dateStr);
fileList=entryNode.getElementsByTagName("path")
NodeList fileList = entryNode.getElementsByTagName("path");
numFiles=fileList.getLength()
int numFiles = fileList.getLength();
fileNode=fileList.item(j)
Node fileNode = fileList.item(j);
path=fileNode.getTextContent().trim()
String path = fileNode.getTextContent().trim();
parts[]=path.split("/",3)
String parts[] = path.split("/", 3);
diffUrl=formatRevisionLink(project,path,revision)
String diffUrl = formatRevisionLink(project, path, revision);
action=fileNode.getAttributes().getNamedItem("action").getTextContent()
String action = fileNode.getAttributes().getNamedItem("action").getTextContent();
String state = "";
tempPath=temp.getAbsolutePath()
String tempPath = temp.getAbsolutePath();
st=conn.createStatement()
Statement st = conn.createStatement();
String baseUrl = "http://" + project + ".svn.sourceforge.net/viewvc/" + project;
a=Integer.parseInt(version)
int a = Integer.parseInt(version);
int b = a - 1;
String fileName = path;
String project = args[0];
String module = args[1];
String logFilename = args[2];
String jdbcUrl = args[3];
conn=getConnection(jdbcUrl)
Connection conn = getConnection(jdbcUrl);
RevisionSVNLogParser logParser = new RevisionSVNLogParser(project, module);
List<ProjectEntry> projects = new ArrayList<ProjectEntry>(100);
int pageNum = projects.size()/10+1;
doc=getDoc("p.xml?page=" + pageNum + "&q=language%3Ajava&sort=users&")
Document doc =getDoc("p.xml?page="+pageNum+"&q=language%3Ajava&sort=users&");
Element resultElement = (Element)element.getElementsByTagName("result").item(0);
projectId=elementIn(projectNode,"id")
String projectId = elementIn(projectNode, "id");
projectName=elementIn(projectNode,"name")
String projectName = elementIn(projectNode, "name");
ProjectEntry p = new ProjectEntry();
boolean complete = false;
int page = 0;
String pageString;
doc=getDoc("p/" + projectId + "/enlistments.xml"+ pageString)
Document doc = getDoc("p/" + projectId+ "/enlistments.xml"+pageString);
itemsReturned=Integer.parseInt(elementIn(response,"items_returned"))
int itemsReturned = Integer.parseInt(elementIn(response, "items_returned"));
itemsAvailable=Integer.parseInt(elementIn(response,"items_available"))
int itemsAvailable = Integer.parseInt(elementIn(response, "items_available"));
firstItemPosition=Integer.parseInt(elementIn(response,"first_item_position"))
int firstItemPosition = Integer.parseInt(elementIn(response, "first_item_position"));
Element resultElement = (Element)response.getElementsByTagName("result").item(0);
type=elementIn(repo,"type")
String type = elementIn(repo, "type");
repoURL=elementIn(repo,"url")
String repoURL = elementIn(repo, "url");
module=elementIn(repo,"module_name")
String module = elementIn(repo, "module_name");
username=elementIn(repo,"username")
String username = elementIn(repo, "username");
password=elementIn(repo,"password")
String password = elementIn(repo, "password");
status=elementIn(repo,"ohloh_job_status")
String status = elementIn(repo, "ohloh_job_status");
Repo r = new Repo(type,repoURL,module,username,password,status);
String pre = "https://www.ohloh.net/";
String post = "api_key=waDryU9cuiDEO64aJLYMA";
URL url = new URL(pre+string+post);
con=url.openConnection()
URLConnection con = url.openConnection();
builder=DocumentBuilderFactory.newInstance().newDocumentBuilder()
DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
doc=builder.parse(con.getInputStream())
Document doc = builder.parse(con.getInputStream());
elem=parent.getElementsByTagName(s)
NodeList elem = parent.getElementsByTagName(s);
StringBuilder sb = new StringBuilder();
Element temp = next;
item=coll.item(pointer++)
Node item = coll.item(pointer++);
wholeText=((Text)item).getWholeText()
String wholeText = ((Text)item).getWholeText();
Element elem = (Element) item;
statusList=element.getElementsByTagName("status")
NodeList statusList = element.getElementsByTagName("status");
statusNode=statusList.item(0)
Node statusNode = statusList.item(0);

Diff of 8dea7a3696373866c1fe6e698d2a88e1f66566c6 and 4c562b59193ffe9990e454988f51bf90248d2ed2:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 3
	--> recency = years
	--> Added type declarations  = 157
	--> recency = years
	--> Added type parameter methods = 3
	--> recency = years
	--> Added type parameter fields = 3
	--> recency = years
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 72
	--> recency = years
	--> Added class instantiations = 255
	--> recency = years
	--> Added nested = 24
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 8dea7a3696373866c1fe6e698d2a88e1f66566c6 to 4c562b59193ffe9990e454988f51bf90248d2ed2

************Analysis complete************
Added generics to repository generic.tools = 1

Chris Parnin added type argument method count = 3
	--> recency = years
Chris Parnin added wildcard count = 3
	--> recency = years
Chris Parnin added type declaration count = 157
	--> recency = years
Chris Parnin added type parameter method count = 3
	--> recency = years
Chris Parnin added type parameter field count = 3
	--> recency = years
Chris Parnin added diamond count = 0
	--> recency = null
Chris Parnin added method invocation count = 0
	--> recency = null
Chris Parnin added implicit method invocation count = 72
	--> recency = years
Chris Parnin added class instantiation count = 255
	--> recency = years
Chris Parnin added nested count = 24
	--> recency = null
Chris Parnin added bounds count = 0
	--> recency = null
File copied successfully!
