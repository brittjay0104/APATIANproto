L-Puzzle_Solver -- kjlubick -- Kevin Lubick
https://github.com/kjlubick/L-Puzzle_Solver.git
git clone https://github.com/kjlubick/L-Puzzle_Solver.git
.\L-Puzzle_Solver\
.\L-Puzzle_Solver\.git
0
Project cloned!
Kevin Lubick is responsible for commit 259efa344d013486c26297e1ec0df752d4c914c8
Kevin Lubick is responsible for commit 885b8e7d7e8c7e11b66e52704398b6eea19a4230
Kevin Lubick is responsible for commit ccec4a086a4b6ea7094a32cced2a71f1448558f6
Kevin Lubick is responsible for commit 1047bd8eb010c37428f323355b5c8238a120a26a
Kevin Lubick is responsible for commit d7b6c73757b1e12747b612d0dd2d042e63a79e0c
Kevin Lubick is responsible for commit 136a7c3c19ab7370c1917de0157225e36d4703d6
Kevin Lubick is responsible for commit 6bfe1ac9ab3dc9b04a9db96b4bbf31eee8c20399
Kevin Lubick is responsible for commit 49c9f48740810e7b72e4b90829ebb20129518f4e
Kevin Lubick is responsible for commit 38879675938de22b679a1c6861a05592a97a7a2c
Kevin Lubick is responsible for commit 87192649393e0e8d821722b4141afd2068907935
Kevin Lubick is responsible for commit fd3a8bb4075acbd386fb3180b9af75feba445f79
Kevin Lubick is responsible for commit 3e1632e7eb3ce496f9c347bb05ddc4289ef13e92
Kevin Lubick is responsible for commit 1ce0d320371d8e2a031fb5563c30faa0b7cc899f
Kevin Lubick is responsible for commit bbb39479c76471a5d772bb38cfac36270a83a6e4
Kevin Lubick is responsible for commit 8b7f5928984450cca1048fa0ea86bc4507275d62
Kevin Lubick is responsible for commit 3be1976d9379cb68bb623d651a1dd6dd1314fae8
Kevin Lubick is responsible for commit d81afcad2044c66214f4e068d1f534e44cc81c6e
Kevin Lubick is responsible for commit 1f94555ebc520418d2680424c8b1b889bfdac9be
Kevin Lubick is responsible for commit 28c20f5f36c4a686338eb5ae61173f27a9ae5493
Kevin Lubick is responsible for commit 20d040535f21bdb0d475ec142e244a9b679eb75a
Kevin Lubick is responsible for commit 2eb720b1784a2cd0e025a04eb0041958118bd955
Kevin Lubick is responsible for commit bbf36b8899386634cffddc48e712021a74974750
Kevin Lubick is responsible for commit 9898a656a862b46449b430b05f97588f304252bf
Kevin Lubick is responsible for commit 7b979e4131ba0a7aa793bae3e73c96b9b32423d7
Kevin Lubick is responsible for commit fbeacc02e52eccf2524f31d9383c8ce93e70c049
Kevin Lubick is responsible for commit 72ed41ae3a7e66ef0066c09a7731aebbd1c9aa0c
Kevin Lubick is responsible for commit 5a7227eff1374a6cb437110cda552021f7889be7
Kevin Lubick is responsible for commit 4d090b5d42edd3cc4741d58e0eccab5a9baa2819
Kevin Lubick is responsible for commit 4e8cb5a6c3d17d51d82144354ad3c8570fd65f28
Kevin Lubick is responsible for commit be7da822142c59660765dff7f7a8645a09f909b3
Kevin Lubick is responsible for commit c7ba0d607a56e9adb82f1f2bdb7857de53d0eb7c
Kevin Lubick is responsible for commit c3517a00b14760fb1b295dd89674fac9725fa4a0
Kevin Lubick is responsible for commit ef3841ee5e91bcffadc10687370b32bf9ca2c6d6
Kevin Lubick is responsible for commit 8646580bf2d443fe7ece98b08b301e65b3e030b5
Kevin Lubick is responsible for commit 729d8aef7d6cf612e5600e8a03acd00c68d92fb1
Kevin Lubick is responsible for commit 7c03f6b68687f6e2b7fdb9dec53678451e247ac5
Kevin Lubick is responsible for commit f27991a87a7011f8b78d36bdea35e71e770de676
Kevin Lubick is responsible for commit ea371a6d760d115b131e9f4008222e567bfb90c0
Kevin Lubick is responsible for commit ec03de8951f97ba01ae37585efb6e877a5f861df
Kevin Lubick is responsible for commit 16c5a1ee19015de338c1d410f1833c914505af42
Kevin Lubick is responsible for commit 6c2a38a91ae95f447c1492a6378d09a0794a9cc7
Kevin Lubick is responsible for commit c54a4b58514186f370e100cb0228c6415bbd37d2
Kevin Lubick is responsible for commit bbd1c411f5a4ee5203978e104dcf6fb7f71e4df1
Kevin Lubick is responsible for commit d34077d33de3c87cbe4bc2e54da37f3b01bbeb10
Kevin Lubick is responsible for commit a457aa9512b4368e90bd1d8345827243e29a3ae4
Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.

 ************ ANALYZING FOR USAGE PATTERN ADDITION ************


****Parsing for addition at revision 259efa344d013486c26297e1ec0df752d4c914c8****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 259efa344d013486c26297e1ec0df752d4c914c8 and 885b8e7d7e8c7e11b66e52704398b6eea19a4230:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 259efa344d013486c26297e1ec0df752d4c914c8 to 885b8e7d7e8c7e11b66e52704398b6eea19a4230


****Parsing for addition at revision 885b8e7d7e8c7e11b66e52704398b6eea19a4230****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 885b8e7d7e8c7e11b66e52704398b6eea19a4230 and ccec4a086a4b6ea7094a32cced2a71f1448558f6:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 885b8e7d7e8c7e11b66e52704398b6eea19a4230 to ccec4a086a4b6ea7094a32cced2a71f1448558f6


****Parsing for addition at revision ccec4a086a4b6ea7094a32cced2a71f1448558f6****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of ccec4a086a4b6ea7094a32cced2a71f1448558f6 and 1047bd8eb010c37428f323355b5c8238a120a26a:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision ccec4a086a4b6ea7094a32cced2a71f1448558f6 to 1047bd8eb010c37428f323355b5c8238a120a26a


****Parsing for addition at revision 1047bd8eb010c37428f323355b5c8238a120a26a****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 1047bd8eb010c37428f323355b5c8238a120a26a and d7b6c73757b1e12747b612d0dd2d042e63a79e0c:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 1047bd8eb010c37428f323355b5c8238a120a26a to d7b6c73757b1e12747b612d0dd2d042e63a79e0c


****Parsing for addition at revision d7b6c73757b1e12747b612d0dd2d042e63a79e0c****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of d7b6c73757b1e12747b612d0dd2d042e63a79e0c and 136a7c3c19ab7370c1917de0157225e36d4703d6:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 0
	--> recency = null
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision d7b6c73757b1e12747b612d0dd2d042e63a79e0c to 136a7c3c19ab7370c1917de0157225e36d4703d6


****Parsing for addition at revision 136a7c3c19ab7370c1917de0157225e36d4703d6****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;

 Generics pattern new Stack<TetriPlacement>() was added at revision 136a7c3c19ab7370c1917de0157225e36d4703d6


 Generics pattern new HashMap<Point, List<TetriRotation>>() was added at revision 136a7c3c19ab7370c1917de0157225e36d4703d6


 Generics pattern new ArrayList<TetriRotation>() was added at revision 136a7c3c19ab7370c1917de0157225e36d4703d6


 Generics pattern new HashMap<Tetromino, Integer>(numberOfAvailablePieces) was added at revision 136a7c3c19ab7370c1917de0157225e36d4703d6

String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 136a7c3c19ab7370c1917de0157225e36d4703d6 and 6bfe1ac9ab3dc9b04a9db96b4bbf31eee8c20399:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 6
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 136a7c3c19ab7370c1917de0157225e36d4703d6 to 6bfe1ac9ab3dc9b04a9db96b4bbf31eee8c20399


****Parsing for addition at revision 6bfe1ac9ab3dc9b04a9db96b4bbf31eee8c20399****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 6bfe1ac9ab3dc9b04a9db96b4bbf31eee8c20399 and 49c9f48740810e7b72e4b90829ebb20129518f4e:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 6
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 6bfe1ac9ab3dc9b04a9db96b4bbf31eee8c20399 to 49c9f48740810e7b72e4b90829ebb20129518f4e


****Parsing for addition at revision 49c9f48740810e7b72e4b90829ebb20129518f4e****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 49c9f48740810e7b72e4b90829ebb20129518f4e and 38879675938de22b679a1c6861a05592a97a7a2c:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 6
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 49c9f48740810e7b72e4b90829ebb20129518f4e to 38879675938de22b679a1c6861a05592a97a7a2c


****Parsing for addition at revision 38879675938de22b679a1c6861a05592a97a7a2c****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 38879675938de22b679a1c6861a05592a97a7a2c and 87192649393e0e8d821722b4141afd2068907935:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 6
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 38879675938de22b679a1c6861a05592a97a7a2c to 87192649393e0e8d821722b4141afd2068907935


****Parsing for addition at revision 87192649393e0e8d821722b4141afd2068907935****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 87192649393e0e8d821722b4141afd2068907935 and fd3a8bb4075acbd386fb3180b9af75feba445f79:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 6
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 87192649393e0e8d821722b4141afd2068907935 to fd3a8bb4075acbd386fb3180b9af75feba445f79


****Parsing for addition at revision fd3a8bb4075acbd386fb3180b9af75feba445f79****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of fd3a8bb4075acbd386fb3180b9af75feba445f79 and 3e1632e7eb3ce496f9c347bb05ddc4289ef13e92:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 6
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision fd3a8bb4075acbd386fb3180b9af75feba445f79 to 3e1632e7eb3ce496f9c347bb05ddc4289ef13e92


****Parsing for addition at revision 3e1632e7eb3ce496f9c347bb05ddc4289ef13e92****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 3e1632e7eb3ce496f9c347bb05ddc4289ef13e92 and 1ce0d320371d8e2a031fb5563c30faa0b7cc899f:
	--> Added type argument methods = 0
	--> recency = null
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 0
	--> recency = null
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 0
	--> recency = null
	--> Added class instantiations = 6
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 3e1632e7eb3ce496f9c347bb05ddc4289ef13e92 to 1ce0d320371d8e2a031fb5563c30faa0b7cc899f


****Parsing for addition at revision 1ce0d320371d8e2a031fb5563c30faa0b7cc899f****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

 Generics pattern public class EightByEightLPuzzle was added at revision 1ce0d320371d8e2a031fb5563c30faa0b7cc899f

t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;

 Generics pattern Map<Tetromino, Integer> piecesToUse = getInitialPieces(); was added at revision 1ce0d320371d8e2a031fb5563c30faa0b7cc899f


 Generics pattern protected abstract Map<Tetromino, Integer> getInitialPieces() was added at revision 1ce0d320371d8e2a031fb5563c30faa0b7cc899f

String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

 Generics pattern new HashMap<LPuzzle.Tetromino, Integer>(4) was added at revision 1ce0d320371d8e2a031fb5563c30faa0b7cc899f


Diff of 1ce0d320371d8e2a031fb5563c30faa0b7cc899f and bbb39479c76471a5d772bb38cfac36270a83a6e4:
	--> Added type argument methods = 1
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 1
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 2
	--> recency = years
	--> Added class instantiations = 14
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 1ce0d320371d8e2a031fb5563c30faa0b7cc899f to bbb39479c76471a5d772bb38cfac36270a83a6e4


****Parsing for addition at revision bbb39479c76471a5d772bb38cfac36270a83a6e4****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;

 Generics pattern public abstract class AbstractLPuzzle was added at revision bbb39479c76471a5d772bb38cfac36270a83a6e4


 Generics pattern List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino); was added at revision bbb39479c76471a5d772bb38cfac36270a83a6e4

Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of bbb39479c76471a5d772bb38cfac36270a83a6e4 and 8b7f5928984450cca1048fa0ea86bc4507275d62:
	--> Added type argument methods = 1
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 7
	--> recency = years
	--> Added class instantiations = 14
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision bbb39479c76471a5d772bb38cfac36270a83a6e4 to 8b7f5928984450cca1048fa0ea86bc4507275d62


****Parsing for addition at revision 8b7f5928984450cca1048fa0ea86bc4507275d62****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;

 Generics pattern new ArrayList<Point>(t.xOffsets.length) was added at revision 8b7f5928984450cca1048fa0ea86bc4507275d62

String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 8b7f5928984450cca1048fa0ea86bc4507275d62 and 3be1976d9379cb68bb623d651a1dd6dd1314fae8:
	--> Added type argument methods = 1
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 7
	--> recency = years
	--> Added class instantiations = 15
	--> recency = years
	--> Added nested = 0
	--> recency = null
	--> Added bounds = 0
	--> recency = null

 Reverted revision 8b7f5928984450cca1048fa0ea86bc4507275d62 to 3be1976d9379cb68bb623d651a1dd6dd1314fae8


****Parsing for addition at revision 3be1976d9379cb68bb623d651a1dd6dd1314fae8****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;

 Generics pattern new ArrayList<Point>(getPegLocations()) was added at revision 3be1976d9379cb68bb623d651a1dd6dd1314fae8


 Generics pattern protected Map<Point, List<TetriRotation>> findPossibilitiesForPegs(List<Point> pegsToTest) was added at revision 3be1976d9379cb68bb623d651a1dd6dd1314fae8


 Generics pattern Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate); was added at revision 3be1976d9379cb68bb623d651a1dd6dd1314fae8


 Generics pattern List<TetriRotation> trListToTry = null; was added at revision 3be1976d9379cb68bb623d651a1dd6dd1314fae8


 Generics pattern List<TetriRotation> list = entry.getValue(); was added at revision 3be1976d9379cb68bb623d651a1dd6dd1314fae8


 Generics pattern new ArrayList<Point>(pegsLeftToLocate) was added at revision 3be1976d9379cb68bb623d651a1dd6dd1314fae8

String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of 3be1976d9379cb68bb623d651a1dd6dd1314fae8 and d81afcad2044c66214f4e068d1f534e44cc81c6e:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 17
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 3be1976d9379cb68bb623d651a1dd6dd1314fae8 to d81afcad2044c66214f4e068d1f534e44cc81c6e


****Parsing for addition at revision d81afcad2044c66214f4e068d1f534e44cc81c6e****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);

Diff of d81afcad2044c66214f4e068d1f534e44cc81c6e and 1f94555ebc520418d2680424c8b1b889bfdac9be:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 2
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 0
	--> recency = null
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 17
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision d81afcad2044c66214f4e068d1f534e44cc81c6e to 1f94555ebc520418d2680424c8b1b889bfdac9be


****Parsing for addition at revision 1f94555ebc520418d2680424c8b1b889bfdac9be****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;

 Generics pattern static class TetriRotation was added at revision 1f94555ebc520418d2680424c8b1b889bfdac9be


 Generics pattern static class TetriPlacement was added at revision 1f94555ebc520418d2680424c8b1b889bfdac9be

String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

 Generics pattern new LinkedList<TwelvePieceLPuzzle.TetriPlacement>() was added at revision 1f94555ebc520418d2680424c8b1b889bfdac9be


 Generics pattern new HashMap<>(numberOfAvailablePieces) was added at revision 1f94555ebc520418d2680424c8b1b889bfdac9be


Diff of 1f94555ebc520418d2680424c8b1b889bfdac9be and 28c20f5f36c4a686338eb5ae61173f27a9ae5493:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 20
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 1f94555ebc520418d2680424c8b1b889bfdac9be to 28c20f5f36c4a686338eb5ae61173f27a9ae5493


****Parsing for addition at revision 28c20f5f36c4a686338eb5ae61173f27a9ae5493****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 28c20f5f36c4a686338eb5ae61173f27a9ae5493 and 20d040535f21bdb0d475ec142e244a9b679eb75a:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 20
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 28c20f5f36c4a686338eb5ae61173f27a9ae5493 to 20d040535f21bdb0d475ec142e244a9b679eb75a


****Parsing for addition at revision 20d040535f21bdb0d475ec142e244a9b679eb75a****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 20d040535f21bdb0d475ec142e244a9b679eb75a and 2eb720b1784a2cd0e025a04eb0041958118bd955:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 20
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 20d040535f21bdb0d475ec142e244a9b679eb75a to 2eb720b1784a2cd0e025a04eb0041958118bd955


****Parsing for addition at revision 2eb720b1784a2cd0e025a04eb0041958118bd955****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 2eb720b1784a2cd0e025a04eb0041958118bd955 and bbf36b8899386634cffddc48e712021a74974750:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 20
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 2eb720b1784a2cd0e025a04eb0041958118bd955 to bbf36b8899386634cffddc48e712021a74974750


****Parsing for addition at revision bbf36b8899386634cffddc48e712021a74974750****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of bbf36b8899386634cffddc48e712021a74974750 and 9898a656a862b46449b430b05f97588f304252bf:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 20
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision bbf36b8899386634cffddc48e712021a74974750 to 9898a656a862b46449b430b05f97588f304252bf


****Parsing for addition at revision 9898a656a862b46449b430b05f97588f304252bf****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 9898a656a862b46449b430b05f97588f304252bf and 7b979e4131ba0a7aa793bae3e73c96b9b32423d7:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 20
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 9898a656a862b46449b430b05f97588f304252bf to 7b979e4131ba0a7aa793bae3e73c96b9b32423d7


****Parsing for addition at revision 7b979e4131ba0a7aa793bae3e73c96b9b32423d7****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 7b979e4131ba0a7aa793bae3e73c96b9b32423d7 and fbeacc02e52eccf2524f31d9383c8ce93e70c049:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 22
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 7b979e4131ba0a7aa793bae3e73c96b9b32423d7 to fbeacc02e52eccf2524f31d9383c8ce93e70c049


****Parsing for addition at revision fbeacc02e52eccf2524f31d9383c8ce93e70c049****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of fbeacc02e52eccf2524f31d9383c8ce93e70c049 and 72ed41ae3a7e66ef0066c09a7731aebbd1c9aa0c:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 24
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision fbeacc02e52eccf2524f31d9383c8ce93e70c049 to 72ed41ae3a7e66ef0066c09a7731aebbd1c9aa0c


****Parsing for addition at revision 72ed41ae3a7e66ef0066c09a7731aebbd1c9aa0c****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

 Generics pattern new HashSet<Point>(12) was added at revision 72ed41ae3a7e66ef0066c09a7731aebbd1c9aa0c


Diff of 72ed41ae3a7e66ef0066c09a7731aebbd1c9aa0c and 5a7227eff1374a6cb437110cda552021f7889be7:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 26
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 72ed41ae3a7e66ef0066c09a7731aebbd1c9aa0c to 5a7227eff1374a6cb437110cda552021f7889be7


****Parsing for addition at revision 5a7227eff1374a6cb437110cda552021f7889be7****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 5a7227eff1374a6cb437110cda552021f7889be7 and 4d090b5d42edd3cc4741d58e0eccab5a9baa2819:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 26
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 5a7227eff1374a6cb437110cda552021f7889be7 to 4d090b5d42edd3cc4741d58e0eccab5a9baa2819


****Parsing for addition at revision 4d090b5d42edd3cc4741d58e0eccab5a9baa2819****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 4d090b5d42edd3cc4741d58e0eccab5a9baa2819 and 4e8cb5a6c3d17d51d82144354ad3c8570fd65f28:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 26
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 4d090b5d42edd3cc4741d58e0eccab5a9baa2819 to 4e8cb5a6c3d17d51d82144354ad3c8570fd65f28


****Parsing for addition at revision 4e8cb5a6c3d17d51d82144354ad3c8570fd65f28****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 4e8cb5a6c3d17d51d82144354ad3c8570fd65f28 and be7da822142c59660765dff7f7a8645a09f909b3:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 26
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 4e8cb5a6c3d17d51d82144354ad3c8570fd65f28 to be7da822142c59660765dff7f7a8645a09f909b3


****Parsing for addition at revision be7da822142c59660765dff7f7a8645a09f909b3****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of be7da822142c59660765dff7f7a8645a09f909b3 and c7ba0d607a56e9adb82f1f2bdb7857de53d0eb7c:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 28
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision be7da822142c59660765dff7f7a8645a09f909b3 to c7ba0d607a56e9adb82f1f2bdb7857de53d0eb7c


****Parsing for addition at revision c7ba0d607a56e9adb82f1f2bdb7857de53d0eb7c****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

 Generics pattern new HashSet<Point>(12) was added at revision c7ba0d607a56e9adb82f1f2bdb7857de53d0eb7c


Diff of c7ba0d607a56e9adb82f1f2bdb7857de53d0eb7c and c3517a00b14760fb1b295dd89674fac9725fa4a0:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 30
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision c7ba0d607a56e9adb82f1f2bdb7857de53d0eb7c to c3517a00b14760fb1b295dd89674fac9725fa4a0


****Parsing for addition at revision c3517a00b14760fb1b295dd89674fac9725fa4a0****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of c3517a00b14760fb1b295dd89674fac9725fa4a0 and ef3841ee5e91bcffadc10687370b32bf9ca2c6d6:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 30
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision c3517a00b14760fb1b295dd89674fac9725fa4a0 to ef3841ee5e91bcffadc10687370b32bf9ca2c6d6


****Parsing for addition at revision ef3841ee5e91bcffadc10687370b32bf9ca2c6d6****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

 Generics pattern new HashMap<LPuzzle.Tetromino, Integer>(4) was added at revision ef3841ee5e91bcffadc10687370b32bf9ca2c6d6


Diff of ef3841ee5e91bcffadc10687370b32bf9ca2c6d6 and 8646580bf2d443fe7ece98b08b301e65b3e030b5:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 4
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 11
	--> recency = years
	--> Added class instantiations = 35
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision ef3841ee5e91bcffadc10687370b32bf9ca2c6d6 to 8646580bf2d443fe7ece98b08b301e65b3e030b5


****Parsing for addition at revision 8646580bf2d443fe7ece98b08b301e65b3e030b5****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;

 Generics pattern static class TetriRotation was added at revision 8646580bf2d443fe7ece98b08b301e65b3e030b5

String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 8646580bf2d443fe7ece98b08b301e65b3e030b5 and 729d8aef7d6cf612e5600e8a03acd00c68d92fb1:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 5
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 19
	--> recency = years
	--> Added class instantiations = 38
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 8646580bf2d443fe7ece98b08b301e65b3e030b5 to 729d8aef7d6cf612e5600e8a03acd00c68d92fb1


****Parsing for addition at revision 729d8aef7d6cf612e5600e8a03acd00c68d92fb1****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;

 Generics pattern new ArrayList<Point>(pegsLeftToLocate) was added at revision 729d8aef7d6cf612e5600e8a03acd00c68d92fb1

String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

 Generics pattern new ArrayList<Point>(pegsLeftToLocate) was added at revision 729d8aef7d6cf612e5600e8a03acd00c68d92fb1


Diff of 729d8aef7d6cf612e5600e8a03acd00c68d92fb1 and 7c03f6b68687f6e2b7fdb9dec53678451e247ac5:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 5
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 19
	--> recency = years
	--> Added class instantiations = 40
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 729d8aef7d6cf612e5600e8a03acd00c68d92fb1 to 7c03f6b68687f6e2b7fdb9dec53678451e247ac5


****Parsing for addition at revision 7c03f6b68687f6e2b7fdb9dec53678451e247ac5****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 7c03f6b68687f6e2b7fdb9dec53678451e247ac5 and f27991a87a7011f8b78d36bdea35e71e770de676:
	--> Added type argument methods = 2
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 5
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 1
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 19
	--> recency = years
	--> Added class instantiations = 40
	--> recency = years
	--> Added nested = 1
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 7c03f6b68687f6e2b7fdb9dec53678451e247ac5 to f27991a87a7011f8b78d36bdea35e71e770de676


****Parsing for addition at revision f27991a87a7011f8b78d36bdea35e71e770de676****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;

 Generics pattern Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate); was added at revision f27991a87a7011f8b78d36bdea35e71e770de676


 Generics pattern List<TetriRotation> trListToTry = null; was added at revision f27991a87a7011f8b78d36bdea35e71e770de676

String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

 Generics pattern new ArrayList<Point>(pegs) was added at revision f27991a87a7011f8b78d36bdea35e71e770de676


 Generics pattern private Map<Point, List<TetriRotation>> findPossibilitiesForPegs(List<Point> pegsToTest) was added at revision f27991a87a7011f8b78d36bdea35e71e770de676


 Generics pattern Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate); was added at revision f27991a87a7011f8b78d36bdea35e71e770de676


 Generics pattern List<TetriRotation> trListToTry = null; was added at revision f27991a87a7011f8b78d36bdea35e71e770de676


Diff of f27991a87a7011f8b78d36bdea35e71e770de676 and ea371a6d760d115b131e9f4008222e567bfb90c0:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 5
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 4
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 29
	--> recency = years
	--> Added class instantiations = 41
	--> recency = years
	--> Added nested = 3
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision f27991a87a7011f8b78d36bdea35e71e770de676 to ea371a6d760d115b131e9f4008222e567bfb90c0


****Parsing for addition at revision ea371a6d760d115b131e9f4008222e567bfb90c0****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

 Generics pattern new ArrayList<>() was added at revision ea371a6d760d115b131e9f4008222e567bfb90c0


 Generics pattern new HashMap<>() was added at revision ea371a6d760d115b131e9f4008222e567bfb90c0


Diff of ea371a6d760d115b131e9f4008222e567bfb90c0 and ec03de8951f97ba01ae37585efb6e877a5f861df:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 5
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 6
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 29
	--> recency = years
	--> Added class instantiations = 41
	--> recency = years
	--> Added nested = 4
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision ea371a6d760d115b131e9f4008222e567bfb90c0 to ec03de8951f97ba01ae37585efb6e877a5f861df


****Parsing for addition at revision ec03de8951f97ba01ae37585efb6e877a5f861df****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of ec03de8951f97ba01ae37585efb6e877a5f861df and 16c5a1ee19015de338c1d410f1833c914505af42:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 5
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 6
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 29
	--> recency = years
	--> Added class instantiations = 41
	--> recency = years
	--> Added nested = 4
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision ec03de8951f97ba01ae37585efb6e877a5f861df to 16c5a1ee19015de338c1d410f1833c914505af42


****Parsing for addition at revision 16c5a1ee19015de338c1d410f1833c914505af42****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 16c5a1ee19015de338c1d410f1833c914505af42 and 6c2a38a91ae95f447c1492a6378d09a0794a9cc7:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 5
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 6
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 29
	--> recency = years
	--> Added class instantiations = 41
	--> recency = years
	--> Added nested = 4
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 16c5a1ee19015de338c1d410f1833c914505af42 to 6c2a38a91ae95f447c1492a6378d09a0794a9cc7


****Parsing for addition at revision 6c2a38a91ae95f447c1492a6378d09a0794a9cc7****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];

 Generics pattern public class LPuzzleRunner was added at revision 6c2a38a91ae95f447c1492a6378d09a0794a9cc7

job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of 6c2a38a91ae95f447c1492a6378d09a0794a9cc7 and c54a4b58514186f370e100cb0228c6415bbd37d2:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 6
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 6
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 29
	--> recency = years
	--> Added class instantiations = 41
	--> recency = years
	--> Added nested = 4
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision 6c2a38a91ae95f447c1492a6378d09a0794a9cc7 to c54a4b58514186f370e100cb0228c6415bbd37d2


****Parsing for addition at revision c54a4b58514186f370e100cb0228c6415bbd37d2****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of c54a4b58514186f370e100cb0228c6415bbd37d2 and bbd1c411f5a4ee5203978e104dcf6fb7f71e4df1:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 6
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 6
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 29
	--> recency = years
	--> Added class instantiations = 41
	--> recency = years
	--> Added nested = 4
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision c54a4b58514186f370e100cb0228c6415bbd37d2 to bbd1c411f5a4ee5203978e104dcf6fb7f71e4df1


****Parsing for addition at revision bbd1c411f5a4ee5203978e104dcf6fb7f71e4df1****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of bbd1c411f5a4ee5203978e104dcf6fb7f71e4df1 and d34077d33de3c87cbe4bc2e54da37f3b01bbeb10:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 6
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 6
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 29
	--> recency = years
	--> Added class instantiations = 41
	--> recency = years
	--> Added nested = 4
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision bbd1c411f5a4ee5203978e104dcf6fb7f71e4df1 to d34077d33de3c87cbe4bc2e54da37f3b01bbeb10


****Parsing for addition at revision d34077d33de3c87cbe4bc2e54da37f3b01bbeb10****

Added AbstractLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added EightByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added LPuzzleRunner.java to .\L-Puzzle_Solver\ repository source files.
Added PNGMaker.java to .\L-Puzzle_Solver\ repository source files.
Added SixByEightLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
Added TwelvePieceLPuzzle.java to .\L-Puzzle_Solver\ repository source files.
int x = p.x;
int y = p.y;
int expectedLength = 2 + getWidth()*getHeight();
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Tetromino t = p.tetromino;
offsets=getRotatedTetrominoOffsets(p.rotation,t)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, t);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
int adjX = x + i;
int adjY = y + j;
offsets=getRotatedTetrominoOffsets(p.rotation,p.tetromino)
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
List<Point> offsets = getRotatedTetrominoOffsets(p.rotation, p.tetromino);
int x = p.peg.x + offset.x;
int y = p.peg.y + offset.y;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(16);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(16);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 16) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new EightByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(16);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
t=getTetromino(x,y)
Tetromino t = getTetromino(x, y);
String s = (t == null ? " " : t.symbol);
StringBuilder builder = new StringBuilder(getWidth() * getHeight());
List<Point> retVal = new ArrayList<Point>(t.xOffsets.length);
int xOff = t.xOffsets[i];
int yOff = t.yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
piecesToUse=getInitialPieces()
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
Map<Tetromino, Integer> piecesToUse = getInitialPieces();
int i = 1;
Map<Point, List<TetriRotation>> originalRotations = new HashMap<Point, List<TetriRotation>>();
List<TetriRotation> tetriRotations = new ArrayList<TetriRotation>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<Tetromino, Integer>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
n=entry.getValue().size()
int n = entry.getValue().size();
final int prime = 31;
int result = 1;
TetriRotation other = (TetriRotation) obj;
final int gridSize = 36;
int widthInPts = getWidth() * gridSize;
int heightInPts = getHeight() * gridSize;
String puzzleType = null;
int numberToGenerate = 0;
int numberThreads = 0;
String numberToGenerateString = args[1];
String numberThreadsString = args[2];
job=PrinterJob.getPrinterJob()
PrinterJob job = PrinterJob.getPrinterJob();
PageFormat pf = new PageFormat();
defaultPaper=pf.getPaper()
Paper defaultPaper = pf.getPaper();
ok=job.printDialog()
boolean ok = job.printDialog();
Graphics2D g2d = (Graphics2D)g;
int arrayOffset = pageIndex*4;
LPuzzle p = puzzles[arrayOffset + i];
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
AbstractLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    AbstractLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new SixByEightLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
AbstractLPuzzle random = null;
Thread thread = new Thread(runnable);
int x = initialPegs[i][0];
int y = initialPegs[i][1];
int x = p.x;
int y = p.y;
newPiece=PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()))
PuzzleElement newPiece = PuzzleElement.fromChar(exportedString.charAt(1 + x + y * getWidth()));
TwelvePieceLPuzzle random = null;
Random rand = new Random();
Set<Point> pegs = new HashSet<Point>(12);
long i = 0;
final AtomicInteger puzzleCount = new AtomicInteger();
final AtomicLong puzzlesTried = new AtomicLong();
final Object syncObject = new Object();
Runnable runnable = new Runnable() {     
            @Override
            public void run() {

                System.out.println("Generating random puzzles");
                Set<Point> pegs = new HashSet<Point>(12);
                Random rand = new Random(new SecureRandom().nextLong());
                while(puzzleCount.get() < numPuzzles) {
                    TwelvePieceLPuzzle random = null;
                    do {
                        pegs.clear();
                        while (pegs.size() < 12) {
                            pegs.add(new Point(rand.nextInt(WIDTH), rand.nextInt(HEIGHT)));
                        }

                        random = new TwelvePieceLPuzzle(pegs);
                        puzzlesTried.incrementAndGet();
                    } while (!random.solve(SolvingVerbosity.SILENT));
                    puzzleCount.incrementAndGet();
                    synchronized (syncObject) {
                        System.out.printf("Difficulty %1.2f:  %s%n", Math.log(random.getDifficulty()), random.export());
                    }
                }
                System.out.println("Tried "+puzzlesTried.get()+" puzzles to generate "+numPuzzles);

                System.out.println(new Date());
            }
        };
Set<Point> pegs = new HashSet<Point>(12);
Random rand = new Random(new SecureRandom().nextLong());
TwelvePieceLPuzzle random = null;
Thread thread = new Thread(runnable);
Tetromino t = placement.tetromino;
int pegX = placement.point.x;
int pegY = placement.point.y;
calc=calculateRotation(placement.rotation,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(placement.rotation, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
int adjX = x + i;
int adjY = y+ j;
calc=calculateRotation(r,t.yOffsets,t.xOffsets)
int[][] calc = calculateRotation(r, t.yOffsets, t.xOffsets);
int x = pegX + calc[i][0];
int y = pegY + calc[i][1];
calc=calculateRotation(p.rotation,p.tetromino.yOffsets,p.tetromino.xOffsets)
int[][] calc = calculateRotation(p.rotation, p.tetromino.yOffsets, p.tetromino.xOffsets);
int x = p.point.x + calc[i][0];
int y = p.point.y + calc[i][1];
int[][] retVal = new int[xOffsets.length][2];
int xOff = xOffsets[i];
int yOff = yOffsets[i];
int rotX = r.rotMatrix[0][0] * xOff + r.rotMatrix[1][0] * yOff;
int rotY = r.rotMatrix[0][1] * xOff + r.rotMatrix[1][1] * yOff;
Map<Tetromino, Integer> piecesToUse = new HashMap<LPuzzle.Tetromino, Integer>(4);
int i = 1;
rotations=findPossibilitiesForPegs(pegsLeftToLocate)
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Map<Point, List<TetriRotation>> rotations = findPossibilitiesForPegs(pegsLeftToLocate);
Point pegToTry = null;
List<TetriRotation> trListToTry = null;
List<TetriRotation> trListToTry = null;
int smallestRotations = Integer.MAX_VALUE;
list=entry.getValue()
List<TetriRotation> list = entry.getValue();
List<TetriRotation> list = entry.getValue();
tr=trListToTry.get(i)
TetriRotation tr = trListToTry.get(i);
Map<Tetromino, Integer> revisedAvailablePieces = new HashMap<>(numberOfAvailablePieces);
TetriPlacement placement = new TetriPlacement(pegToTry, tr);
Map<Point, List<TetriRotation>> originalRotations = new HashMap<>();
List<TetriRotation> tetriRotations = new ArrayList<>();
TetriPlacement placement = new TetriPlacement(peg, t, r);
n=entry.getValue().size()
int n = entry.getValue().size();

Diff of d34077d33de3c87cbe4bc2e54da37f3b01bbeb10 and a457aa9512b4368e90bd1d8345827243e29a3ae4:
	--> Added type argument methods = 3
	--> recency = years
	--> Added wildcards = 0
	--> recency = null
	--> Added type declarations  = 6
	--> recency = years
	--> Added type parameter methods = 0
	--> recency = null
	--> Added type parameter fields = 0
	--> recency = null
	--> Added diamonds = 6
	--> recency = years
	--> Added explicit method invocations = 0
	--> recency = null
	--> Added implicit method invocations = 29
	--> recency = years
	--> Added class instantiations = 41
	--> recency = years
	--> Added nested = 4
	--> recency = years
	--> Added bounds = 0
	--> recency = null

 Reverted revision d34077d33de3c87cbe4bc2e54da37f3b01bbeb10 to a457aa9512b4368e90bd1d8345827243e29a3ae4

************Analysis complete************
Added generics to repository L-Puzzle_Solver = 36

Kevin Lubick added type argument method count = 3
	--> recency = years
Kevin Lubick added wildcard count = 0
	--> recency = null
Kevin Lubick added type declaration count = 6
	--> recency = years
Kevin Lubick added type parameter method count = 0
	--> recency = null
Kevin Lubick added type parameter field count = 0
	--> recency = null
Kevin Lubick added diamond count = 6
	--> recency = years
Kevin Lubick added method invocation count = 0
	--> recency = null
Kevin Lubick added implicit method invocation count = 29
	--> recency = years
Kevin Lubick added class instantiation count = 41
	--> recency = years
Kevin Lubick added nested count = 4
	--> recency = null
Kevin Lubick added bounds count = 0
	--> recency = null
File copied successfully!
