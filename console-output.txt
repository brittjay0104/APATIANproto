0
Luca Falsina is responsible for commit cd51242040b529e198a015f246e1c3ede79a1c00
Luca Falsina is responsible for commit 05f2feeb0a534e95a6cb1c6aaf1b8bf4091f7150
Luca Falsina is responsible for commit 1cf44f0133ace0b7e0783f7939a271e758beafcd
Luca Falsina is responsible for commit 393a4176aa39b9d9e633d75b2eb94c33cf66e0ae
Luca Falsina is responsible for commit 7de4de65b60735b01c102547e9d0b4fafa7eeecd
Luca Falsina is responsible for commit 66bcd265577257d9cffe53f6fce6a58c2709c97d
Luca Falsina is responsible for commit 245d7729a2494a2a89e9aece4bcc0866edd3b5f1
Luca Falsina is responsible for commit b418467bf6353b7083470e000324ec8df0f94986
Luca Falsina is responsible for commit 9b50783ca664357e518b1a7035401dc34bc5175a
Luca Falsina is responsible for commit 10f9beb8ee1817bf5d767d6714c9fd00116a0101
Luca Falsina is responsible for commit adfa1ee381848e77b8b5389b20abb77984f155d0
Luca Falsina is responsible for commit 9ceae9f983ea684b642d1fefe70b1520c67f4ae9
Luca Falsina is responsible for commit 2c23468cf8280fdd6b99be96a43e1ac28c4d5705
Luca Falsina is responsible for commit bd534365b6320180c700e762fe32e375d22ceb13
Luca Falsina is responsible for commit e7123377b4c4ed360a3204f9d955bbf03479ffc3
Luca Falsina is responsible for commit 0b874020352750c7d01ffcbd9c875a94bcb27290
Luca Falsina is responsible for commit 34dae70727285c0c5f3f44730359248ea7e527f6
Luca Falsina is responsible for commit 9c932c7214879c12bc7dd63ef558faeb07311578
Luca Falsina is responsible for commit 9849068bc23dabf573d9a28ba0cafd50ed83df90
Luca Falsina is responsible for commit ddb969ca2ec2743d5e8fe5036ff33008e4862f85
Luca Falsina is responsible for commit 3de55aad15be4c5175b3dff859ed150a0ffd84c0
Luca Falsina is responsible for commit 446ac642acfa035a619992c33704879da0de022a
Luca Falsina is responsible for commit b7250ec299798e0d8acf0355f9352031a3ca1c29
Luca Falsina is responsible for commit e34547fcf3d62e5f9d37df5bc20d9bffefa1d3c1
Luca Falsina is responsible for commit 8f3adb55822345e536920b18f31699f003c9159e
Luca Falsina is responsible for commit 3709191040b1b8b0a0aba256c68b3e535e48bea4
Luca Falsina is responsible for commit cd595fc66a696e6862590149dfb486fbd0f20587
Luca Falsina is responsible for commit 9382d09975de53226dddfb6779d526915130b647
Luca Falsina is responsible for commit b514827b87d2b372154441c293483740706770ba
Luca Falsina is responsible for commit 79a7eaf64fce6d24a20732d6be908caad534d8e3
Luca Falsina is responsible for commit b63ba87dec99a77811fd217d64d6b1542a6badd7
Luca Falsina is responsible for commit c0f6824fd46f238c3c61c8f3ad13f17fa467efd7
Luca Falsina is responsible for commit 031531ac508e5e92456269a90cc723542ba8f483
Luca Falsina is responsible for commit 8383b8888286033739abfbef6923404a32e49d4c
Luca Falsina is responsible for commit 6532638f3cb0cf7c0a62c4f812da54e5b47f3e30
Luca Falsina is responsible for commit 565ae0012cfbc28fc273f5da0e1a25624225eca9
Luca Falsina is responsible for commit 3b281aa698cc29d0cd1866b6b9f200ee6143dd71
Luca Falsina is responsible for commit 505127ff9b46c27764749a11a07d69f32573e3f8
Luca Falsina is responsible for commit 0ee4f2ad31970a4476fb1ea1f5ac50da08a67cc6
Luca Falsina is responsible for commit 631559dd78cc6fa34229a3b21765f8354573c7df
Luca Falsina is responsible for commit b8c8c71be793b1d7bf76240c262211c9846ae4fa
Luca Falsina is responsible for commit 86bc6deeb6d8bba117ad74e96f2182f0b73be405
Luca Falsina is responsible for commit e37c60de769f88be1ed33632dea0251171b044fd
Luca Falsina is responsible for commit 362e8235d181cb516db8d8bf10f172ca9bf1dcf3
Luca Falsina is responsible for commit c7be70123b0a06538cb60a2ceabf3c72b7e8f25f
Luca Falsina is responsible for commit 3e9ffa752421e07c9fa9d11d1199264a5d6685cb
Luca Falsina is responsible for commit fd6ca8ce79a3b9fa3fd05221686e93bc93f1df79
Luca Falsina is responsible for commit 3890fa8ecc1c37910e255c9fb1019f3a1303bb1d
Luca Falsina is responsible for commit 82e43d05351ae81ae535a271929150a7bc6997df
Luca Falsina is responsible for commit 8699fe047c1c906ed12624e38f6458dfd02ced7a
Luca Falsina is responsible for commit 7e0a6b5fa8f7067389bd0c99ac3044247ae20f43
Luca Falsina is responsible for commit 06a65b5b185fe0de8a47870425d4a4c38869afa9
Luca Falsina is responsible for commit 73f2e5e0d9ab955e13737c6cbd62b102714d66b2
Luca Falsina is responsible for commit eee202febd58f47f2b8d3f3be9d9938e305b47e7
Luca Falsina is responsible for commit 1008c79e894eec682f205e73434e84d81efb75e4
Luca Falsina is responsible for commit 660a2e73ea7db945a43859ace9f31d5b5d163ae0
Luca Falsina is responsible for commit 3be7bf5b6ba170d08a8c68ec0a8da5949e1e40ac
Luca Falsina is responsible for commit d9701624183ac3e64b4486ddbd721b0a710e2cd9
Luca Falsina is responsible for commit 06cdd9853525c0a5821f9f5e3b27918dd3cf22ee
Luca Falsina is responsible for commit 96141a7ab84b9c1fb8c4f793d8d3469b83c3714a
Luca Falsina is responsible for commit 6fb83bbad5d08f8764a905aa56c6d6114d8beb6e
Luca Falsina is responsible for commit 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6
Luca Falsina is responsible for commit bffdeb593b1f3b638c6adae6ba88aa32a3a5a2b0
Luca Falsina is responsible for commit 0701d9d3176a2b0569cd6040d7e2ff0a7f757657
Luca Falsina is responsible for commit 5005cbc482f2177ead5a50a3591c694d8d4fb835
Luca Falsina is responsible for commit ecafd52fb56a3a15ad78666b5330da769ec68799
Luca Falsina is responsible for commit 1d132825f0db667c181b1bd46a4a6c6cf54e289d
Luca Falsina is responsible for commit d5953e767f84cb6f5968ce6f6151e5b93b4fb327
Luca Falsina is responsible for commit df9ff7674dc70cab561c925fa29a3c6b49d7770d
Luca Falsina is responsible for commit 37e460b4564d5b460bd767d611f4fac6994b4cb9
Luca Falsina is responsible for commit d43a41dbcc15c5475f76dca4402f8bdd3d2bd077
Luca Falsina is responsible for commit 1dedb372aefc4444eaa181afb03808c7105000cb
Luca Falsina is responsible for commit 5e000dccf9d66e693c27085c12cc421cd70994fc
Luca Falsina is responsible for commit ab35ec185917e3bd76e8dc1d326b32427f57e0a3
Luca Falsina is responsible for commit 6ae1395238ccfb5f4ef00cf81a14b7bd867448ac
Luca Falsina is responsible for commit dbe480bba1e897de5dd08ec8e8d572779efd4134
Luca Falsina is responsible for commit f3b69e5473f24b359e7ccb10789f58af0783b06a
Luca Falsina is responsible for commit 1d6416bd8b1ec282e5bd28eeeb4de6ccae23b2cd
Luca Falsina is responsible for commit 5b3cb4ec9717e7e5cd512367e64ae00f210978e4
Luca Falsina is responsible for commit fde198733730b6c305e0516f1c8d5e079a99d528
Luca Falsina is responsible for commit 66644ee317cdbb4c6856739ae6d0f1827177f639
Luca Falsina is responsible for commit 04699661bababb483cb56932486d4db0e9b695ee
Luca Falsina is responsible for commit 3a7ee533e77d321204595f26f57a134d40d00823
Luca Falsina is responsible for commit eb9512b05dad8545c33a56d6f410fb4bfef80639
Luca Falsina is responsible for commit 4d6c56a7fb54edbb9d9dc09cd5a39204c794df20
Luca Falsina is responsible for commit 868352e994fb786525683379a9c8a5caaf24aca5
Luca Falsina is responsible for commit 979056fabe9012a0af210d034a1a3bb2572fdf9d
Luca Falsina is responsible for commit cf799cd89e11c0e3bfa0846a554291ca30d9ad20
Luca Falsina is responsible for commit 4af8f70ab085e4abb54fe3bf9174b5d38effc54c
Luca Falsina is responsible for commit 16a61cd29889f60d4cd00fc5038b8b8d96a31495
Luca Falsina is responsible for commit b306695f95ac230defbade7a336d20dac96c305f
Luca Falsina is responsible for commit 59531cbe22522f7f31030131f45d8a246ab3b2f1
Luca Falsina is responsible for commit 8b58d31004996b5d1ab75dba13cebefff306000a
Luca Falsina is responsible for commit 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
Luca Falsina is responsible for commit eee8229b44c8b0c47c288764a56cddf9c9fc2318
Luca Falsina is responsible for commit 07a443dd6f5a305976c93317b1612349acf25309
Luca Falsina is responsible for commit 2179acab1e637b772cd3d0ec7a9608eb7dcc53ea
Luca Falsina is responsible for commit 4a8aa7c799156066274644d43078a5aae7006ccb
Luca Falsina is responsible for commit 1e1f6f2d72acf75e2387ce5bf6da2bd653c4a07c
Luca Falsina is responsible for commit 3cf1b4d31c8816b954be457cc4ce8e6e3b4481d6
Luca Falsina is responsible for commit 5b6f0ad503861cc2a8c88306321e8c4efe871f9d
Luca Falsina is responsible for commit 2be486b368efd9b55767b346b13c60a4edfcab49
Luca Falsina is responsible for commit 4ddef96a13f97c311b737c65283ed17eb6a1199a
Luca Falsina is responsible for commit 8e95b7dc9d3bdc4eec67f456d1d394848b09a28e
Luca Falsina is responsible for commit 894c45317bfa6eff072bfc8a6da812acb9b7179b
Luca Falsina is responsible for commit 74db6f11414da5d923258bf43e0ada667620055c
Luca Falsina is responsible for commit caf66665fca6184f2af69797a41432c0aa34c706
Luca Falsina is responsible for commit effdb6fef47c414fd161c2d443cf621ade624786
Luca Falsina is responsible for commit 8834f9150ddc7700833449abf8f084786703be0b
Luca Falsina is responsible for commit bffc76a6ea986af32d62b8a5d422f6e02983a711
Luca Falsina is responsible for commit 9c33a011f8c7a9b44467e94f726d1f7b27c95917
Luca Falsina is responsible for commit 5a80e0e67e92bd104e483cb8155d6f4397054827
Luca Falsina is responsible for commit e8567b1491974e71dadc5a2132b5c128cdc7b06e
Luca Falsina is responsible for commit 3b08777feb57bff0219b6207ac19fcf31b6b4471
Luca Falsina is responsible for commit a888115ec084f443980f04838e860b45677ebc3d
Luca Falsina is responsible for commit 7f57db788095644f15e4f2d745cf4414503e518f
Luca Falsina is responsible for commit a10da2f5dcdf84c36c52b56de7f69a117c64e096
Luca Falsina is responsible for commit fb66a611ef30da180f5f8ef90cd6226202897745
Luca Falsina is responsible for commit 454a50b0a39693e47cb63f2e6d55d03b8b4de84e
Luca Falsina is responsible for commit a2e9ac284278c0f57cf5213d6aa30aad25bb54eb
Luca Falsina is responsible for commit 8fc27d2c01d0744e9b863c1b64fcf730ef6e2945
Luca Falsina is responsible for commit 22b616653b5d219c827c372a021d70dd8a83da2a
Luca Falsina is responsible for commit 0872fc008df286e58436382b8ffd66dde684da02
Luca Falsina is responsible for commit ad3ca2e7d24ddb2e317c13436191c87671030bcc
Luca Falsina is responsible for commit 6bd9131b4afda374a5e76120e1cacb4c52b1bf7c
Luca Falsina is responsible for commit bbbc68377aa43e6dc266c1ae9f93864c92f9a159
Luca Falsina is responsible for commit 834c73e0014e1cb5db955cf0fcb686e2224cbf6f
Luca Falsina is responsible for commit 3601d6cc6dffd1c0c5be89173829d902ccba7473
Luca Falsina is responsible for commit 7e86a7bd13ad172c1681d5aa544558d2ba79dcaf
Luca Falsina is responsible for commit 3235eda6f6682b9fc300561cb7876162f09bae3a
Luca Falsina is responsible for commit bdf12a6ce486bc94a34879d97fdd3e019d2f7d0c
Luca Falsina is responsible for commit d304f7840afa80ad0202369f0dd9be526a67a5ba
Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.

Reverted to commit cd51242040b529e198a015f246e1c3ede79a1c00

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 05f2feeb0a534e95a6cb1c6aaf1b8bf4091f7150 and cd51242040b529e198a015f246e1c3ede79a1c00:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 05f2feeb0a534e95a6cb1c6aaf1b8bf4091f7150

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 1cf44f0133ace0b7e0783f7939a271e758beafcd and 05f2feeb0a534e95a6cb1c6aaf1b8bf4091f7150:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0
GitAPIException thrown!
Cannot revert commit '1cf44f0133ace0b7e0783f7939a271e758beafcd' because it has 2 parents, only commits with exactly one parent are supported

Reverted to commit 393a4176aa39b9d9e633d75b2eb94c33cf66e0ae

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 7de4de65b60735b01c102547e9d0b4fafa7eeecd and 393a4176aa39b9d9e633d75b2eb94c33cf66e0ae:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 7de4de65b60735b01c102547e9d0b4fafa7eeecd

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 66bcd265577257d9cffe53f6fce6a58c2709c97d and 7de4de65b60735b01c102547e9d0b4fafa7eeecd:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 66bcd265577257d9cffe53f6fce6a58c2709c97d

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 245d7729a2494a2a89e9aece4bcc0866edd3b5f1 and 66bcd265577257d9cffe53f6fce6a58c2709c97d:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 245d7729a2494a2a89e9aece4bcc0866edd3b5f1

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of b418467bf6353b7083470e000324ec8df0f94986 and 245d7729a2494a2a89e9aece4bcc0866edd3b5f1:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit b418467bf6353b7083470e000324ec8df0f94986

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 9b50783ca664357e518b1a7035401dc34bc5175a and b418467bf6353b7083470e000324ec8df0f94986:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 9b50783ca664357e518b1a7035401dc34bc5175a

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 10f9beb8ee1817bf5d767d6714c9fd00116a0101 and 9b50783ca664357e518b1a7035401dc34bc5175a:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 10f9beb8ee1817bf5d767d6714c9fd00116a0101

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of adfa1ee381848e77b8b5389b20abb77984f155d0 and 10f9beb8ee1817bf5d767d6714c9fd00116a0101:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit adfa1ee381848e77b8b5389b20abb77984f155d0

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 9ceae9f983ea684b642d1fefe70b1520c67f4ae9 and adfa1ee381848e77b8b5389b20abb77984f155d0:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 9ceae9f983ea684b642d1fefe70b1520c67f4ae9

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 2c23468cf8280fdd6b99be96a43e1ac28c4d5705 and 9ceae9f983ea684b642d1fefe70b1520c67f4ae9:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 2c23468cf8280fdd6b99be96a43e1ac28c4d5705

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of bd534365b6320180c700e762fe32e375d22ceb13 and 2c23468cf8280fdd6b99be96a43e1ac28c4d5705:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit bd534365b6320180c700e762fe32e375d22ceb13

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of e7123377b4c4ed360a3204f9d955bbf03479ffc3 and bd534365b6320180c700e762fe32e375d22ceb13:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit e7123377b4c4ed360a3204f9d955bbf03479ffc3

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 0b874020352750c7d01ffcbd9c875a94bcb27290 and e7123377b4c4ed360a3204f9d955bbf03479ffc3:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 0b874020352750c7d01ffcbd9c875a94bcb27290

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 34dae70727285c0c5f3f44730359248ea7e527f6 and 0b874020352750c7d01ffcbd9c875a94bcb27290:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 34dae70727285c0c5f3f44730359248ea7e527f6

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 9c932c7214879c12bc7dd63ef558faeb07311578 and 34dae70727285c0c5f3f44730359248ea7e527f6:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 9c932c7214879c12bc7dd63ef558faeb07311578

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 9849068bc23dabf573d9a28ba0cafd50ed83df90 and 9c932c7214879c12bc7dd63ef558faeb07311578:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 9849068bc23dabf573d9a28ba0cafd50ed83df90

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of ddb969ca2ec2743d5e8fe5036ff33008e4862f85 and 9849068bc23dabf573d9a28ba0cafd50ed83df90:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit ddb969ca2ec2743d5e8fe5036ff33008e4862f85

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3de55aad15be4c5175b3dff859ed150a0ffd84c0 and ddb969ca2ec2743d5e8fe5036ff33008e4862f85:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 3de55aad15be4c5175b3dff859ed150a0ffd84c0

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 446ac642acfa035a619992c33704879da0de022a and 3de55aad15be4c5175b3dff859ed150a0ffd84c0:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 446ac642acfa035a619992c33704879da0de022a

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of b7250ec299798e0d8acf0355f9352031a3ca1c29 and 446ac642acfa035a619992c33704879da0de022a:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit b7250ec299798e0d8acf0355f9352031a3ca1c29

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of e34547fcf3d62e5f9d37df5bc20d9bffefa1d3c1 and b7250ec299798e0d8acf0355f9352031a3ca1c29:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit e34547fcf3d62e5f9d37df5bc20d9bffefa1d3c1

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 8f3adb55822345e536920b18f31699f003c9159e and e34547fcf3d62e5f9d37df5bc20d9bffefa1d3c1:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 8f3adb55822345e536920b18f31699f003c9159e

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3709191040b1b8b0a0aba256c68b3e535e48bea4 and 8f3adb55822345e536920b18f31699f003c9159e:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 3709191040b1b8b0a0aba256c68b3e535e48bea4

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of cd595fc66a696e6862590149dfb486fbd0f20587 and 3709191040b1b8b0a0aba256c68b3e535e48bea4:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit cd595fc66a696e6862590149dfb486fbd0f20587

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 9382d09975de53226dddfb6779d526915130b647 and cd595fc66a696e6862590149dfb486fbd0f20587:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit 9382d09975de53226dddfb6779d526915130b647

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of b514827b87d2b372154441c293483740706770ba and 9382d09975de53226dddfb6779d526915130b647:
	--> Added null checks = 0
	--> Removed null checks = 0
	--> Null dereferences checked for null = 0

Reverted to commit b514827b87d2b372154441c293483740706770ba

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
Null check was added at revision b514827b87d2b372154441c293483740706770ba
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
Null check was added at revision b514827b87d2b372154441c293483740706770ba
Null check was added at revision b514827b87d2b372154441c293483740706770ba
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 79a7eaf64fce6d24a20732d6be908caad534d8e3 and b514827b87d2b372154441c293483740706770ba:
	--> Added null checks = 3
	--> Removed null checks = 0
	--> Null dereferences checked for null = 2

Reverted to commit 79a7eaf64fce6d24a20732d6be908caad534d8e3

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of b63ba87dec99a77811fd217d64d6b1542a6badd7 and 79a7eaf64fce6d24a20732d6be908caad534d8e3:
	--> Added null checks = 3
	--> Removed null checks = 0
	--> Null dereferences checked for null = 2

Reverted to commit b63ba87dec99a77811fd217d64d6b1542a6badd7

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of c0f6824fd46f238c3c61c8f3ad13f17fa467efd7 and b63ba87dec99a77811fd217d64d6b1542a6badd7:
	--> Added null checks = 3
	--> Removed null checks = 0
	--> Null dereferences checked for null = 2

Reverted to commit c0f6824fd46f238c3c61c8f3ad13f17fa467efd7

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 031531ac508e5e92456269a90cc723542ba8f483 and c0f6824fd46f238c3c61c8f3ad13f17fa467efd7:
	--> Added null checks = 3
	--> Removed null checks = 0
	--> Null dereferences checked for null = 2

Reverted to commit 031531ac508e5e92456269a90cc723542ba8f483

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 8383b8888286033739abfbef6923404a32e49d4c and 031531ac508e5e92456269a90cc723542ba8f483:
	--> Added null checks = 3
	--> Removed null checks = 0
	--> Null dereferences checked for null = 2

Reverted to commit 8383b8888286033739abfbef6923404a32e49d4c

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 8383b8888286033739abfbef6923404a32e49d4c
Null check was added at revision 8383b8888286033739abfbef6923404a32e49d4c
Null check was added at revision 8383b8888286033739abfbef6923404a32e49d4c
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> inStream
In method loadClass found:
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 8383b8888286033739abfbef6923404a32e49d4c
Null check was added at revision 8383b8888286033739abfbef6923404a32e49d4c
Null check was added at revision 8383b8888286033739abfbef6923404a32e49d4c
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> inStream
In method loadClass found:
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 6532638f3cb0cf7c0a62c4f812da54e5b47f3e30 and 8383b8888286033739abfbef6923404a32e49d4c:
	--> Added null checks = 9
	--> Removed null checks = 0
	--> Null dereferences checked for null = 13

Reverted to commit 6532638f3cb0cf7c0a62c4f812da54e5b47f3e30

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> inStream
	--> verifiedCertificate
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 565ae0012cfbc28fc273f5da0e1a25624225eca9 and 6532638f3cb0cf7c0a62c4f812da54e5b47f3e30:
	--> Added null checks = 9
	--> Removed null checks = 0
	--> Null dereferences checked for null = 13

Reverted to commit 565ae0012cfbc28fc273f5da0e1a25624225eca9

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3b281aa698cc29d0cd1866b6b9f200ee6143dd71 and 565ae0012cfbc28fc273f5da0e1a25624225eca9:
	--> Added null checks = 9
	--> Removed null checks = 0
	--> Null dereferences checked for null = 13

Reverted to commit 3b281aa698cc29d0cd1866b6b9f200ee6143dd71

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 505127ff9b46c27764749a11a07d69f32573e3f8 and 3b281aa698cc29d0cd1866b6b9f200ee6143dd71:
	--> Added null checks = 9
	--> Removed null checks = 0
	--> Null dereferences checked for null = 13

Reverted to commit 505127ff9b46c27764749a11a07d69f32573e3f8

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 0ee4f2ad31970a4476fb1ea1f5ac50da08a67cc6 and 505127ff9b46c27764749a11a07d69f32573e3f8:
	--> Added null checks = 9
	--> Removed null checks = 0
	--> Null dereferences checked for null = 13

Reverted to commit 0ee4f2ad31970a4476fb1ea1f5ac50da08a67cc6

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 631559dd78cc6fa34229a3b21765f8354573c7df and 0ee4f2ad31970a4476fb1ea1f5ac50da08a67cc6:
	--> Added null checks = 9
	--> Removed null checks = 0
	--> Null dereferences checked for null = 13

Reverted to commit 631559dd78cc6fa34229a3b21765f8354573c7df

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 631559dd78cc6fa34229a3b21765f8354573c7df
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 631559dd78cc6fa34229a3b21765f8354573c7df
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
Null check was added at revision 631559dd78cc6fa34229a3b21765f8354573c7df
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of b8c8c71be793b1d7bf76240c262211c9846ae4fa and 631559dd78cc6fa34229a3b21765f8354573c7df:
	--> Added null checks = 12
	--> Removed null checks = 0
	--> Null dereferences checked for null = 15

Reverted to commit b8c8c71be793b1d7bf76240c262211c9846ae4fa

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 86bc6deeb6d8bba117ad74e96f2182f0b73be405 and b8c8c71be793b1d7bf76240c262211c9846ae4fa:
	--> Added null checks = 12
	--> Removed null checks = 0
	--> Null dereferences checked for null = 15

Reverted to commit 86bc6deeb6d8bba117ad74e96f2182f0b73be405

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of e37c60de769f88be1ed33632dea0251171b044fd and 86bc6deeb6d8bba117ad74e96f2182f0b73be405:
	--> Added null checks = 12
	--> Removed null checks = 0
	--> Null dereferences checked for null = 15

Reverted to commit e37c60de769f88be1ed33632dea0251171b044fd

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision e37c60de769f88be1ed33632dea0251171b044fd
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision e37c60de769f88be1ed33632dea0251171b044fd
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 362e8235d181cb516db8d8bf10f172ca9bf1dcf3 and e37c60de769f88be1ed33632dea0251171b044fd:
	--> Added null checks = 14
	--> Removed null checks = 0
	--> Null dereferences checked for null = 18

Reverted to commit 362e8235d181cb516db8d8bf10f172ca9bf1dcf3

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> dexFile
	--> containerJar
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of c7be70123b0a06538cb60a2ceabf3c72b7e8f25f and 362e8235d181cb516db8d8bf10f172ca9bf1dcf3:
	--> Added null checks = 14
	--> Removed null checks = 0
	--> Null dereferences checked for null = 18

Reverted to commit c7be70123b0a06538cb60a2ceabf3c72b7e8f25f

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3e9ffa752421e07c9fa9d11d1199264a5d6685cb and c7be70123b0a06538cb60a2ceabf3c72b7e8f25f:
	--> Added null checks = 14
	--> Removed null checks = 0
	--> Null dereferences checked for null = 18

Reverted to commit 3e9ffa752421e07c9fa9d11d1199264a5d6685cb

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of fd6ca8ce79a3b9fa3fd05221686e93bc93f1df79 and 3e9ffa752421e07c9fa9d11d1199264a5d6685cb:
	--> Added null checks = 14
	--> Removed null checks = 0
	--> Null dereferences checked for null = 18

Reverted to commit fd6ca8ce79a3b9fa3fd05221686e93bc93f1df79

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3890fa8ecc1c37910e255c9fb1019f3a1303bb1d and fd6ca8ce79a3b9fa3fd05221686e93bc93f1df79:
	--> Added null checks = 14
	--> Removed null checks = 0
	--> Null dereferences checked for null = 18

Reverted to commit 3890fa8ecc1c37910e255c9fb1019f3a1303bb1d

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 82e43d05351ae81ae535a271929150a7bc6997df and 3890fa8ecc1c37910e255c9fb1019f3a1303bb1d:
	--> Added null checks = 14
	--> Removed null checks = 0
	--> Null dereferences checked for null = 18

Reverted to commit 82e43d05351ae81ae535a271929150a7bc6997df

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 8699fe047c1c906ed12624e38f6458dfd02ced7a and 82e43d05351ae81ae535a271929150a7bc6997df:
	--> Added null checks = 14
	--> Removed null checks = 0
	--> Null dereferences checked for null = 18

Reverted to commit 8699fe047c1c906ed12624e38f6458dfd02ced7a

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 7e0a6b5fa8f7067389bd0c99ac3044247ae20f43 and 8699fe047c1c906ed12624e38f6458dfd02ced7a:
	--> Added null checks = 14
	--> Removed null checks = 0
	--> Null dereferences checked for null = 18

Reverted to commit 7e0a6b5fa8f7067389bd0c99ac3044247ae20f43

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 7e0a6b5fa8f7067389bd0c99ac3044247ae20f43
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 7e0a6b5fa8f7067389bd0c99ac3044247ae20f43
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 06a65b5b185fe0de8a47870425d4a4c38869afa9 and 7e0a6b5fa8f7067389bd0c99ac3044247ae20f43:
	--> Added null checks = 16
	--> Removed null checks = 0
	--> Null dereferences checked for null = 20

Reverted to commit 06a65b5b185fe0de8a47870425d4a4c38869afa9

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
Null check was added at revision 06a65b5b185fe0de8a47870425d4a4c38869afa9
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 73f2e5e0d9ab955e13737c6cbd62b102714d66b2 and 06a65b5b185fe0de8a47870425d4a4c38869afa9:
	--> Added null checks = 17
	--> Removed null checks = 0
	--> Null dereferences checked for null = 20

Reverted to commit 73f2e5e0d9ab955e13737c6cbd62b102714d66b2

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
Null check was added at revision 73f2e5e0d9ab955e13737c6cbd62b102714d66b2
Null check was added at revision 73f2e5e0d9ab955e13737c6cbd62b102714d66b2
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
In method finalizeLog found:
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of eee202febd58f47f2b8d3f3be9d9938e305b47e7 and 73f2e5e0d9ab955e13737c6cbd62b102714d66b2:
	--> Added null checks = 19
	--> Removed null checks = 0
	--> Null dereferences checked for null = 22

Reverted to commit eee202febd58f47f2b8d3f3be9d9938e305b47e7

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
Null check was added at revision eee202febd58f47f2b8d3f3be9d9938e305b47e7
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 1008c79e894eec682f205e73434e84d81efb75e4 and eee202febd58f47f2b8d3f3be9d9938e305b47e7:
	--> Added null checks = 20
	--> Removed null checks = 0
	--> Null dereferences checked for null = 22

Reverted to commit 1008c79e894eec682f205e73434e84d81efb75e4

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
Null check was added at revision 1008c79e894eec682f205e73434e84d81efb75e4
Null check was added at revision 1008c79e894eec682f205e73434e84d81efb75e4
Null check was added at revision 1008c79e894eec682f205e73434e84d81efb75e4
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> inStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 660a2e73ea7db945a43859ace9f31d5b5d163ae0 and 1008c79e894eec682f205e73434e84d81efb75e4:
	--> Added null checks = 23
	--> Removed null checks = 0
	--> Null dereferences checked for null = 24

Reverted to commit 660a2e73ea7db945a43859ace9f31d5b5d163ae0

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 660a2e73ea7db945a43859ace9f31d5b5d163ae0
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 660a2e73ea7db945a43859ace9f31d5b5d163ae0
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3be7bf5b6ba170d08a8c68ec0a8da5949e1e40ac and 660a2e73ea7db945a43859ace9f31d5b5d163ae0:
	--> Added null checks = 25
	--> Removed null checks = 0
	--> Null dereferences checked for null = 28

Reverted to commit 3be7bf5b6ba170d08a8c68ec0a8da5949e1e40ac

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of d9701624183ac3e64b4486ddbd721b0a710e2cd9 and 3be7bf5b6ba170d08a8c68ec0a8da5949e1e40ac:
	--> Added null checks = 25
	--> Removed null checks = 0
	--> Null dereferences checked for null = 28
GitAPIException thrown!
Cannot revert commit 'd9701624183ac3e64b4486ddbd721b0a710e2cd9' because it has 2 parents, only commits with exactly one parent are supported

Reverted to commit 06cdd9853525c0a5821f9f5e3b27918dd3cf22ee

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 96141a7ab84b9c1fb8c4f793d8d3469b83c3714a and 06cdd9853525c0a5821f9f5e3b27918dd3cf22ee:
	--> Added null checks = 25
	--> Removed null checks = 0
	--> Null dereferences checked for null = 28

Reverted to commit 96141a7ab84b9c1fb8c4f793d8d3469b83c3714a

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 6fb83bbad5d08f8764a905aa56c6d6114d8beb6e and 96141a7ab84b9c1fb8c4f793d8d3469b83c3714a:
	--> Added null checks = 25
	--> Removed null checks = 0
	--> Null dereferences checked for null = 28

Reverted to commit 6fb83bbad5d08f8764a905aa56c6d6114d8beb6e

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6 and 6fb83bbad5d08f8764a905aa56c6d6114d8beb6e:
	--> Added null checks = 25
	--> Removed null checks = 0
	--> Null dereferences checked for null = 28

Reverted to commit 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6
Null check was added at revision 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6
Null check was added at revision 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
Null check was added at revision 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6
Null check was added at revision 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6
Null check was added at revision 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
Null check was added at revision 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6
Null check was added at revision 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6
Null check was added at revision 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of bffdeb593b1f3b638c6adae6ba88aa32a3a5a2b0 and 36cbcc9f0a7594dfee3ada207fccfeb21dde33b6:
	--> Added null checks = 34
	--> Removed null checks = 0
	--> Null dereferences checked for null = 28

Reverted to commit bffdeb593b1f3b638c6adae6ba88aa32a3a5a2b0

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was removed at revision bffdeb593b1f3b638c6adae6ba88aa32a3a5a2b0
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
Null check was removed at revision bffdeb593b1f3b638c6adae6ba88aa32a3a5a2b0
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
Null check was removed at revision bffdeb593b1f3b638c6adae6ba88aa32a3a5a2b0
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 0701d9d3176a2b0569cd6040d7e2ff0a7f757657 and bffdeb593b1f3b638c6adae6ba88aa32a3a5a2b0:
	--> Added null checks = 34
	--> Removed null checks = 3
	--> Null dereferences checked for null = 28

Reverted to commit 0701d9d3176a2b0569cd6040d7e2ff0a7f757657

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 5005cbc482f2177ead5a50a3591c694d8d4fb835 and 0701d9d3176a2b0569cd6040d7e2ff0a7f757657:
	--> Added null checks = 34
	--> Removed null checks = 3
	--> Null dereferences checked for null = 28

Reverted to commit 5005cbc482f2177ead5a50a3591c694d8d4fb835

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of ecafd52fb56a3a15ad78666b5330da769ec68799 and 5005cbc482f2177ead5a50a3591c694d8d4fb835:
	--> Added null checks = 34
	--> Removed null checks = 3
	--> Null dereferences checked for null = 28

Reverted to commit ecafd52fb56a3a15ad78666b5330da769ec68799

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision ecafd52fb56a3a15ad78666b5330da769ec68799
Null check was added at revision ecafd52fb56a3a15ad78666b5330da769ec68799
Null check was added at revision ecafd52fb56a3a15ad78666b5330da769ec68799
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
Null check was added at revision ecafd52fb56a3a15ad78666b5330da769ec68799
Null check was added at revision ecafd52fb56a3a15ad78666b5330da769ec68799
Null check was added at revision ecafd52fb56a3a15ad78666b5330da769ec68799
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
Null check was added at revision ecafd52fb56a3a15ad78666b5330da769ec68799
Null check was added at revision ecafd52fb56a3a15ad78666b5330da769ec68799
Null check was added at revision ecafd52fb56a3a15ad78666b5330da769ec68799
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 1d132825f0db667c181b1bd46a4a6c6cf54e289d and ecafd52fb56a3a15ad78666b5330da769ec68799:
	--> Added null checks = 43
	--> Removed null checks = 3
	--> Null dereferences checked for null = 28

Reverted to commit 1d132825f0db667c181b1bd46a4a6c6cf54e289d

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of d5953e767f84cb6f5968ce6f6151e5b93b4fb327 and 1d132825f0db667c181b1bd46a4a6c6cf54e289d:
	--> Added null checks = 43
	--> Removed null checks = 3
	--> Null dereferences checked for null = 28

Reverted to commit d5953e767f84cb6f5968ce6f6151e5b93b4fb327

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of df9ff7674dc70cab561c925fa29a3c6b49d7770d and d5953e767f84cb6f5968ce6f6151e5b93b4fb327:
	--> Added null checks = 43
	--> Removed null checks = 3
	--> Null dereferences checked for null = 28

Reverted to commit df9ff7674dc70cab561c925fa29a3c6b49d7770d

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
Null check was removed at revision df9ff7674dc70cab561c925fa29a3c6b49d7770d
Null check was added at revision df9ff7674dc70cab561c925fa29a3c6b49d7770d
Null check was added at revision df9ff7674dc70cab561c925fa29a3c6b49d7770d
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 37e460b4564d5b460bd767d611f4fac6994b4cb9 and df9ff7674dc70cab561c925fa29a3c6b49d7770d:
	--> Added null checks = 45
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 37e460b4564d5b460bd767d611f4fac6994b4cb9

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of d43a41dbcc15c5475f76dca4402f8bdd3d2bd077 and 37e460b4564d5b460bd767d611f4fac6994b4cb9:
	--> Added null checks = 45
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit d43a41dbcc15c5475f76dca4402f8bdd3d2bd077

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision d43a41dbcc15c5475f76dca4402f8bdd3d2bd077
Null check was added at revision d43a41dbcc15c5475f76dca4402f8bdd3d2bd077
Null check was added at revision d43a41dbcc15c5475f76dca4402f8bdd3d2bd077
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
Null check was added at revision d43a41dbcc15c5475f76dca4402f8bdd3d2bd077
Null check was added at revision d43a41dbcc15c5475f76dca4402f8bdd3d2bd077
Null check was added at revision d43a41dbcc15c5475f76dca4402f8bdd3d2bd077
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
Null check was added at revision d43a41dbcc15c5475f76dca4402f8bdd3d2bd077
Null check was added at revision d43a41dbcc15c5475f76dca4402f8bdd3d2bd077
Null check was added at revision d43a41dbcc15c5475f76dca4402f8bdd3d2bd077
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 1dedb372aefc4444eaa181afb03808c7105000cb and d43a41dbcc15c5475f76dca4402f8bdd3d2bd077:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 1dedb372aefc4444eaa181afb03808c7105000cb

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 5e000dccf9d66e693c27085c12cc421cd70994fc and 1dedb372aefc4444eaa181afb03808c7105000cb:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 5e000dccf9d66e693c27085c12cc421cd70994fc

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of ab35ec185917e3bd76e8dc1d326b32427f57e0a3 and 5e000dccf9d66e693c27085c12cc421cd70994fc:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit ab35ec185917e3bd76e8dc1d326b32427f57e0a3

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 6ae1395238ccfb5f4ef00cf81a14b7bd867448ac and ab35ec185917e3bd76e8dc1d326b32427f57e0a3:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 6ae1395238ccfb5f4ef00cf81a14b7bd867448ac

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of dbe480bba1e897de5dd08ec8e8d572779efd4134 and 6ae1395238ccfb5f4ef00cf81a14b7bd867448ac:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit dbe480bba1e897de5dd08ec8e8d572779efd4134

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of f3b69e5473f24b359e7ccb10789f58af0783b06a and dbe480bba1e897de5dd08ec8e8d572779efd4134:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit f3b69e5473f24b359e7ccb10789f58af0783b06a

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 1d6416bd8b1ec282e5bd28eeeb4de6ccae23b2cd and f3b69e5473f24b359e7ccb10789f58af0783b06a:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 1d6416bd8b1ec282e5bd28eeeb4de6ccae23b2cd

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 5b3cb4ec9717e7e5cd512367e64ae00f210978e4 and 1d6416bd8b1ec282e5bd28eeeb4de6ccae23b2cd:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 5b3cb4ec9717e7e5cd512367e64ae00f210978e4

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of fde198733730b6c305e0516f1c8d5e079a99d528 and 5b3cb4ec9717e7e5cd512367e64ae00f210978e4:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit fde198733730b6c305e0516f1c8d5e079a99d528

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 66644ee317cdbb4c6856739ae6d0f1827177f639 and fde198733730b6c305e0516f1c8d5e079a99d528:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 66644ee317cdbb4c6856739ae6d0f1827177f639

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 04699661bababb483cb56932486d4db0e9b695ee and 66644ee317cdbb4c6856739ae6d0f1827177f639:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 04699661bababb483cb56932486d4db0e9b695ee

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3a7ee533e77d321204595f26f57a134d40d00823 and 04699661bababb483cb56932486d4db0e9b695ee:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 3a7ee533e77d321204595f26f57a134d40d00823

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of eb9512b05dad8545c33a56d6f410fb4bfef80639 and 3a7ee533e77d321204595f26f57a134d40d00823:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit eb9512b05dad8545c33a56d6f410fb4bfef80639

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 4d6c56a7fb54edbb9d9dc09cd5a39204c794df20 and eb9512b05dad8545c33a56d6f410fb4bfef80639:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 4d6c56a7fb54edbb9d9dc09cd5a39204c794df20

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 868352e994fb786525683379a9c8a5caaf24aca5 and 4d6c56a7fb54edbb9d9dc09cd5a39204c794df20:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 868352e994fb786525683379a9c8a5caaf24aca5

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 979056fabe9012a0af210d034a1a3bb2572fdf9d and 868352e994fb786525683379a9c8a5caaf24aca5:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30
GitAPIException thrown!
Cannot revert commit '979056fabe9012a0af210d034a1a3bb2572fdf9d' because it has 2 parents, only commits with exactly one parent are supported

Reverted to commit cf799cd89e11c0e3bfa0846a554291ca30d9ad20

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 4af8f70ab085e4abb54fe3bf9174b5d38effc54c and cf799cd89e11c0e3bfa0846a554291ca30d9ad20:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 4af8f70ab085e4abb54fe3bf9174b5d38effc54c

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 16a61cd29889f60d4cd00fc5038b8b8d96a31495 and 4af8f70ab085e4abb54fe3bf9174b5d38effc54c:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit 16a61cd29889f60d4cd00fc5038b8b8d96a31495

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of b306695f95ac230defbade7a336d20dac96c305f and 16a61cd29889f60d4cd00fc5038b8b8d96a31495:
	--> Added null checks = 54
	--> Removed null checks = 4
	--> Null dereferences checked for null = 30

Reverted to commit b306695f95ac230defbade7a336d20dac96c305f

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
Null check was added at revision b306695f95ac230defbade7a336d20dac96c305f
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 59531cbe22522f7f31030131f45d8a246ab3b2f1 and b306695f95ac230defbade7a336d20dac96c305f:
	--> Added null checks = 55
	--> Removed null checks = 4
	--> Null dereferences checked for null = 31

Reverted to commit 59531cbe22522f7f31030131f45d8a246ab3b2f1

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 59531cbe22522f7f31030131f45d8a246ab3b2f1
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 59531cbe22522f7f31030131f45d8a246ab3b2f1
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 8b58d31004996b5d1ab75dba13cebefff306000a and 59531cbe22522f7f31030131f45d8a246ab3b2f1:
	--> Added null checks = 57
	--> Removed null checks = 4
	--> Null dereferences checked for null = 34

Reverted to commit 8b58d31004996b5d1ab75dba13cebefff306000a

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> dexFile
	--> containerJar
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 034039daba0b5b5e1dc7794eee9a2b233d8f36eb and 8b58d31004996b5d1ab75dba13cebefff306000a:
	--> Added null checks = 57
	--> Removed null checks = 4
	--> Null dereferences checked for null = 34

Reverted to commit 034039daba0b5b5e1dc7794eee9a2b233d8f36eb

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
Null check was added at revision 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
Null check was added at revision 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
Null check was added at revision 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
Null check was added at revision 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
Null check was added at revision 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
Null check was added at revision 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
Null check was added at revision 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
Null check was added at revision 034039daba0b5b5e1dc7794eee9a2b233d8f36eb
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of eee8229b44c8b0c47c288764a56cddf9c9fc2318 and 034039daba0b5b5e1dc7794eee9a2b233d8f36eb:
	--> Added null checks = 67
	--> Removed null checks = 4
	--> Null dereferences checked for null = 45

Reverted to commit eee8229b44c8b0c47c288764a56cddf9c9fc2318

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 07a443dd6f5a305976c93317b1612349acf25309 and eee8229b44c8b0c47c288764a56cddf9c9fc2318:
	--> Added null checks = 67
	--> Removed null checks = 4
	--> Null dereferences checked for null = 45

Reverted to commit 07a443dd6f5a305976c93317b1612349acf25309

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 07a443dd6f5a305976c93317b1612349acf25309
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 07a443dd6f5a305976c93317b1612349acf25309
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 2179acab1e637b772cd3d0ec7a9608eb7dcc53ea and 07a443dd6f5a305976c93317b1612349acf25309:
	--> Added null checks = 69
	--> Removed null checks = 4
	--> Null dereferences checked for null = 48

Reverted to commit 2179acab1e637b772cd3d0ec7a9608eb7dcc53ea

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> inStream
	--> verifiedCertificate
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 4a8aa7c799156066274644d43078a5aae7006ccb and 2179acab1e637b772cd3d0ec7a9608eb7dcc53ea:
	--> Added null checks = 69
	--> Removed null checks = 4
	--> Null dereferences checked for null = 48

Reverted to commit 4a8aa7c799156066274644d43078a5aae7006ccb

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 1e1f6f2d72acf75e2387ce5bf6da2bd653c4a07c and 4a8aa7c799156066274644d43078a5aae7006ccb:
	--> Added null checks = 69
	--> Removed null checks = 4
	--> Null dereferences checked for null = 48

Reverted to commit 1e1f6f2d72acf75e2387ce5bf6da2bd653c4a07c

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3cf1b4d31c8816b954be457cc4ce8e6e3b4481d6 and 1e1f6f2d72acf75e2387ce5bf6da2bd653c4a07c:
	--> Added null checks = 69
	--> Removed null checks = 4
	--> Null dereferences checked for null = 48

Reverted to commit 3cf1b4d31c8816b954be457cc4ce8e6e3b4481d6

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
Null check was added at revision 3cf1b4d31c8816b954be457cc4ce8e6e3b4481d6
Null check was added at revision 3cf1b4d31c8816b954be457cc4ce8e6e3b4481d6
Null check was added at revision 3cf1b4d31c8816b954be457cc4ce8e6e3b4481d6
Null check was added at revision 3cf1b4d31c8816b954be457cc4ce8e6e3b4481d6
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 5b6f0ad503861cc2a8c88306321e8c4efe871f9d and 3cf1b4d31c8816b954be457cc4ce8e6e3b4481d6:
	--> Added null checks = 73
	--> Removed null checks = 4
	--> Null dereferences checked for null = 52

Reverted to commit 5b6f0ad503861cc2a8c88306321e8c4efe871f9d

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 5b6f0ad503861cc2a8c88306321e8c4efe871f9d
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 5b6f0ad503861cc2a8c88306321e8c4efe871f9d
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 2be486b368efd9b55767b346b13c60a4edfcab49 and 5b6f0ad503861cc2a8c88306321e8c4efe871f9d:
	--> Added null checks = 75
	--> Removed null checks = 4
	--> Null dereferences checked for null = 56

Reverted to commit 2be486b368efd9b55767b346b13c60a4edfcab49

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 4ddef96a13f97c311b737c65283ed17eb6a1199a and 2be486b368efd9b55767b346b13c60a4edfcab49:
	--> Added null checks = 75
	--> Removed null checks = 4
	--> Null dereferences checked for null = 56

Reverted to commit 4ddef96a13f97c311b737c65283ed17eb6a1199a

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 8e95b7dc9d3bdc4eec67f456d1d394848b09a28e and 4ddef96a13f97c311b737c65283ed17eb6a1199a:
	--> Added null checks = 75
	--> Removed null checks = 4
	--> Null dereferences checked for null = 56

Reverted to commit 8e95b7dc9d3bdc4eec67f456d1d394848b09a28e

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 894c45317bfa6eff072bfc8a6da812acb9b7179b and 8e95b7dc9d3bdc4eec67f456d1d394848b09a28e:
	--> Added null checks = 75
	--> Removed null checks = 4
	--> Null dereferences checked for null = 56

Reverted to commit 894c45317bfa6eff072bfc8a6da812acb9b7179b

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 894c45317bfa6eff072bfc8a6da812acb9b7179b
Null check was added at revision 894c45317bfa6eff072bfc8a6da812acb9b7179b
Null check was added at revision 894c45317bfa6eff072bfc8a6da812acb9b7179b
Null check was added at revision 894c45317bfa6eff072bfc8a6da812acb9b7179b
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 894c45317bfa6eff072bfc8a6da812acb9b7179b
Null check was added at revision 894c45317bfa6eff072bfc8a6da812acb9b7179b
Null check was added at revision 894c45317bfa6eff072bfc8a6da812acb9b7179b
Null check was added at revision 894c45317bfa6eff072bfc8a6da812acb9b7179b
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 74db6f11414da5d923258bf43e0ada667620055c and 894c45317bfa6eff072bfc8a6da812acb9b7179b:
	--> Added null checks = 83
	--> Removed null checks = 4
	--> Null dereferences checked for null = 58

Reverted to commit 74db6f11414da5d923258bf43e0ada667620055c

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 74db6f11414da5d923258bf43e0ada667620055c
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> mPackageManager
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 74db6f11414da5d923258bf43e0ada667620055c
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of caf66665fca6184f2af69797a41432c0aa34c706 and 74db6f11414da5d923258bf43e0ada667620055c:
	--> Added null checks = 85
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit caf66665fca6184f2af69797a41432c0aa34c706

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision caf66665fca6184f2af69797a41432c0aa34c706
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision caf66665fca6184f2af69797a41432c0aa34c706
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of effdb6fef47c414fd161c2d443cf621ade624786 and caf66665fca6184f2af69797a41432c0aa34c706:
	--> Added null checks = 87
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit effdb6fef47c414fd161c2d443cf621ade624786

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
Null check was added at revision effdb6fef47c414fd161c2d443cf621ade624786
Null check was added at revision effdb6fef47c414fd161c2d443cf621ade624786
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 8834f9150ddc7700833449abf8f084786703be0b and effdb6fef47c414fd161c2d443cf621ade624786:
	--> Added null checks = 89
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit 8834f9150ddc7700833449abf8f084786703be0b

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of bffc76a6ea986af32d62b8a5d422f6e02983a711 and 8834f9150ddc7700833449abf8f084786703be0b:
	--> Added null checks = 89
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit bffc76a6ea986af32d62b8a5d422f6e02983a711

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 9c33a011f8c7a9b44467e94f726d1f7b27c95917 and bffc76a6ea986af32d62b8a5d422f6e02983a711:
	--> Added null checks = 89
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit 9c33a011f8c7a9b44467e94f726d1f7b27c95917

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
Null check was added at revision 9c33a011f8c7a9b44467e94f726d1f7b27c95917
Null check was added at revision 9c33a011f8c7a9b44467e94f726d1f7b27c95917
Null check was added at revision 9c33a011f8c7a9b44467e94f726d1f7b27c95917
Null check was added at revision 9c33a011f8c7a9b44467e94f726d1f7b27c95917
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 5a80e0e67e92bd104e483cb8155d6f4397054827 and 9c33a011f8c7a9b44467e94f726d1f7b27c95917:
	--> Added null checks = 93
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit 5a80e0e67e92bd104e483cb8155d6f4397054827

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of e8567b1491974e71dadc5a2132b5c128cdc7b06e and 5a80e0e67e92bd104e483cb8155d6f4397054827:
	--> Added null checks = 93
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit e8567b1491974e71dadc5a2132b5c128cdc7b06e

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3b08777feb57bff0219b6207ac19fcf31b6b4471 and e8567b1491974e71dadc5a2132b5c128cdc7b06e:
	--> Added null checks = 93
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit 3b08777feb57bff0219b6207ac19fcf31b6b4471

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of a888115ec084f443980f04838e860b45677ebc3d and 3b08777feb57bff0219b6207ac19fcf31b6b4471:
	--> Added null checks = 93
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit a888115ec084f443980f04838e860b45677ebc3d

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 7f57db788095644f15e4f2d745cf4414503e518f and a888115ec084f443980f04838e860b45677ebc3d:
	--> Added null checks = 93
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit 7f57db788095644f15e4f2d745cf4414503e518f

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of a10da2f5dcdf84c36c52b56de7f69a117c64e096 and 7f57db788095644f15e4f2d745cf4414503e518f:
	--> Added null checks = 93
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit a10da2f5dcdf84c36c52b56de7f69a117c64e096

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of fb66a611ef30da180f5f8ef90cd6226202897745 and a10da2f5dcdf84c36c52b56de7f69a117c64e096:
	--> Added null checks = 93
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit fb66a611ef30da180f5f8ef90cd6226202897745

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 454a50b0a39693e47cb63f2e6d55d03b8b4de84e and fb66a611ef30da180f5f8ef90cd6226202897745:
	--> Added null checks = 93
	--> Removed null checks = 4
	--> Null dereferences checked for null = 60

Reverted to commit 454a50b0a39693e47cb63f2e6d55d03b8b4de84e

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
Null check was added at revision 454a50b0a39693e47cb63f2e6d55d03b8b4de84e
Null check was added at revision 454a50b0a39693e47cb63f2e6d55d03b8b4de84e
Null check was added at revision 454a50b0a39693e47cb63f2e6d55d03b8b4de84e
Null check was added at revision 454a50b0a39693e47cb63f2e6d55d03b8b4de84e
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
Null check was added at revision 454a50b0a39693e47cb63f2e6d55d03b8b4de84e
Null check was added at revision 454a50b0a39693e47cb63f2e6d55d03b8b4de84e
Null check was added at revision 454a50b0a39693e47cb63f2e6d55d03b8b4de84e
Null check was added at revision 454a50b0a39693e47cb63f2e6d55d03b8b4de84e
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of a2e9ac284278c0f57cf5213d6aa30aad25bb54eb and 454a50b0a39693e47cb63f2e6d55d03b8b4de84e:
	--> Added null checks = 101
	--> Removed null checks = 4
	--> Null dereferences checked for null = 66

Reverted to commit a2e9ac284278c0f57cf5213d6aa30aad25bb54eb

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> containerToVerify
	--> inStream
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 8fc27d2c01d0744e9b863c1b64fcf730ef6e2945 and a2e9ac284278c0f57cf5213d6aa30aad25bb54eb:
	--> Added null checks = 101
	--> Removed null checks = 4
	--> Null dereferences checked for null = 66

Reverted to commit 8fc27d2c01d0744e9b863c1b64fcf730ef6e2945

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 22b616653b5d219c827c372a021d70dd8a83da2a and 8fc27d2c01d0744e9b863c1b64fcf730ef6e2945:
	--> Added null checks = 101
	--> Removed null checks = 4
	--> Null dereferences checked for null = 66

Reverted to commit 22b616653b5d219c827c372a021d70dd8a83da2a

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 0872fc008df286e58436382b8ffd66dde684da02 and 22b616653b5d219c827c372a021d70dd8a83da2a:
	--> Added null checks = 101
	--> Removed null checks = 4
	--> Null dereferences checked for null = 66

Reverted to commit 0872fc008df286e58436382b8ffd66dde684da02

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of ad3ca2e7d24ddb2e317c13436191c87671030bcc and 0872fc008df286e58436382b8ffd66dde684da02:
	--> Added null checks = 101
	--> Removed null checks = 4
	--> Null dereferences checked for null = 66

Reverted to commit ad3ca2e7d24ddb2e317c13436191c87671030bcc

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 6bd9131b4afda374a5e76120e1cacb4c52b1bf7c and ad3ca2e7d24ddb2e317c13436191c87671030bcc:
	--> Added null checks = 101
	--> Removed null checks = 4
	--> Null dereferences checked for null = 66

Reverted to commit 6bd9131b4afda374a5e76120e1cacb4c52b1bf7c

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of bbbc68377aa43e6dc266c1ae9f93864c92f9a159 and 6bd9131b4afda374a5e76120e1cacb4c52b1bf7c:
	--> Added null checks = 101
	--> Removed null checks = 4
	--> Null dereferences checked for null = 66

Reverted to commit bbbc68377aa43e6dc266c1ae9f93864c92f9a159

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 834c73e0014e1cb5db955cf0fcb686e2224cbf6f and bbbc68377aa43e6dc266c1ae9f93864c92f9a159:
	--> Added null checks = 101
	--> Removed null checks = 4
	--> Null dereferences checked for null = 66

Reverted to commit 834c73e0014e1cb5db955cf0fcb686e2224cbf6f

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
Null check was added at revision 834c73e0014e1cb5db955cf0fcb686e2224cbf6f
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3601d6cc6dffd1c0c5be89173829d902ccba7473 and 834c73e0014e1cb5db955cf0fcb686e2224cbf6f:
	--> Added null checks = 102
	--> Removed null checks = 4
	--> Null dereferences checked for null = 67

Reverted to commit 3601d6cc6dffd1c0c5be89173829d902ccba7473

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 7e86a7bd13ad172c1681d5aa544558d2ba79dcaf and 3601d6cc6dffd1c0c5be89173829d902ccba7473:
	--> Added null checks = 102
	--> Removed null checks = 4
	--> Null dereferences checked for null = 67

Reverted to commit 7e86a7bd13ad172c1681d5aa544558d2ba79dcaf

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of 3235eda6f6682b9fc300561cb7876162f09bae3a and 7e86a7bd13ad172c1681d5aa544558d2ba79dcaf:
	--> Added null checks = 102
	--> Removed null checks = 4
	--> Null dereferences checked for null = 67

Reverted to commit 3235eda6f6682b9fc300561cb7876162f09bae3a

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of bdf12a6ce486bc94a34879d97fdd3e019d2f7d0c and 3235eda6f6682b9fc300561cb7876162f09bae3a:
	--> Added null checks = 102
	--> Removed null checks = 4
	--> Null dereferences checked for null = 67

Reverted to commit bdf12a6ce486bc94a34879d97fdd3e019d2f7d0c

Added ComponentModifier.java to ./Grab-n-Run/ repository source files.
Added DexClassSampleActivity.java to ./Grab-n-Run/ repository source files.
Added MainActivity.java to ./Grab-n-Run/ repository source files.
Added CacheLogger.java to ./Grab-n-Run/ repository source files.
Added CertFileFilter.java to ./Grab-n-Run/ repository source files.
Added FileDownloader.java to ./Grab-n-Run/ repository source files.
Added FileFilterByName.java to ./Grab-n-Run/ repository source files.
Added PackageNameTrie.java to ./Grab-n-Run/ repository source files.
Added SecureDexClassLoader.java to ./Grab-n-Run/ repository source files.
Added SecureLoaderFactory.java to ./Grab-n-Run/ repository source files.
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file ComponentModifier.java************

Null checks:

Null fields: 

Null variables: 
Null assignments: 
************ For file DexClassSampleActivity.java************

Null checks:
retComponentModifier != null?final String shortClassName = retComponentModifier.getClass().getSimpleName();
loadedClass != null?try {
				retComponentModifier = (ComponentModifier) loadedClass.newInstance();
			} catch (InstantiationException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the instantiation of the target class!");
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				Log.e(TAG_DEX_SAMPLE, "Problem in the access to the target class!");
				e.printStackTrace();
			}
mComponentModifier != null?mComponentModifier.customizeButtons(buttonList);

Null fields: 
	--> mSecureDexClassLoader
	--> toastHandler
	--> switchSlider
	--> thirdBtn
	--> mComponentModifier
	--> textView

Null variables: 
In method retrieveComponentModifierSecurely found:
	--> retComponentModifier
	--> loadedClass
In method retrieveComponentModifier found:
	--> retComponentModifier
	--> mDexClassLoader
Null assignments: 
In method retrieveComponentModifierSecurely found: 
	--> mSecureDexClassLoader
In method onCreate found: 
	--> mSecureDexClassLoader
************ For file MainActivity.java************

Null checks:
loadedClass != null?final Activity NasaDailyActivity = (Activity) loadedClass.newInstance();
loadedClass != null?Log.w(TAG_MAIN, "No class should be returned in this case!!");
loadedClass != null?Log.w(TAG_MAIN, "No class should be loaded!");

Null fields: 
	--> classNameInAPK
	--> toastHandler

Null variables: 
In method setUpDexClassLoader found:
	--> mDexClassLoader
Null assignments: 
In method setUpSecureDexClassLoader found: 
	--> mSecureDexClassLoader
In method setUpProfileSecureDexClassLoader found: 
	--> mSecureDexClassLoader
************ For file CacheLogger.java************

Null checks:
in != null?in.close();
mPrintWriter != null?mPrintWriter.close();

Null fields: 
	--> helperFile
	--> remoteURLToLocalFileMap
	--> remoteURLToCreationTimestamp
	--> cacheDirectoryPath

Null variables: 
In method CacheLogger found:
	--> in
In method finalizeLog found:
	--> mPrintWriter
Null assignments: 
************ For file CertFileFilter.java************

Null checks:

Null fields: 
	--> certificateName

Null variables: 
Null assignments: 
************ For file FileDownloader.java************

Null checks:
activeNetworkInfo == null?Log.w(TAG_FILE_DOWNLOADER, "No connectivity is available. Download failed!");
urlConnection != null?((HttpURLConnection) urlConnection).disconnect();
inputStream != null?try {
    						inputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
outputStream != null?try {
    						// outputStream.flush();
    						outputStream.close();
    					} catch (IOException e) {
    						e.printStackTrace();
    					}
fileMimeType == null?return null;

Null fields: 
	--> mConnectivityManager
	--> activeNetworkInfo

Null variables: 
In method downloadRemoteUrl found:
	--> dataThread
In method run found:
	--> urlConnection
	--> inputStream
	--> outputStream
Null assignments: 
In method FileDownloader found: 
	--> fileMimeType
************ For file FileFilterByName.java************

Null checks:

Null fields: 
	--> name
	--> extension

Null variables: 
Null assignments: 
************ For file PackageNameTrie.java************

Null checks:

Null fields: 
	--> packageNameToHasCertificateMap

Null variables: 
Null assignments: 
************ For file SecureDexClassLoader.java************

Null checks:
packageNameList != null?for (String packageName : packageNameList) {
					
					// This is a valid entry so it must be added to packageNameToContainerPathMap
					String previousPath = packageNameToContainerPathMap.put(packageName, currentPath);
					
					// Also fill auxiliary Trie-like data structure
					mPackageNameTrie.generateEntriesForPackageName(packageName);
					
					// If previous path is not null, it means that one of the previous analyzed
					// path had the same package name (this is a possibility for JAR containers..)
					if (previousPath != null) {
						
						// TODO Up to now only a warning message is registered in the logs and the most
						// fresh of the two references is stored.
						Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
					}
				}
previousPath != null?Log.w(	TAG_SECURE_DEX_CLASS_LOADER, "Package Name " + packageName + " is not unique!\n Previous path: " 
								+ previousPath + ";\n New path: " + currentPath + ";" );
containerPath == null?return null;
mPackageManager.getPackageArchiveInfo(containerPath, 0) != null?packageNameList.add(mPackageManager.getPackageArchiveInfo(containerPath, 0).packageName);
containerJar.getJarEntry("classes.dex") != null?isAValidJar = true;
containerJar != null?try {
						containerJar.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
extPackageNameToCertificateMap != null?packageNameToCertificateMap = extPackageNameToCertificateMap;
packageNameToCertificateMap.get(currentPackageName) == null?URL certificateRemoteURL;
verifiedCertificate != null?signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate != null?boolean signatureCheckIsSuccessful = verifyContainerSignatureAgainstCertificate(containerPath, verifiedCertificate);
verifiedCertificate == null?boolean isCertificateDownloadSuccessful = downloadCertificateRemotelyViaHttps(packageName);
signatures != null?for (Signature sign : signatures) {
					if (sign != null) {
						
						X509Certificate certFromSign = null;
						InputStream inStream = null;
						
						try {
							
							// Recreate the certificate starting from this signature
							inStream = new ByteArrayInputStream(sign.toByteArray());
							certFromSign = (X509Certificate) certificateFactory.generateCertificate(inStream);
							
							// Check that the reconstructed certificate is not expired..
							certFromSign.checkValidity();
							
							// Check whether the reconstructed certificate and the trusted one match
							// Please note that certificates may be self-signed but it's not an issue..
							if (certFromSign.equals(verifiedCertificate))
								// This a necessary but not sufficient condition to
								// prove that the apk container has not been repackaged..
								signatureCheckIsSuccessful = true;

						} catch (CertificateException e) {
							// If this branch is reached certificateFromSign is not valid..
						} finally {
						     if (inStream != null) {
						         try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
						     }
						}
						
					}
				}
sign != null?X509Certificate certFromSign = null;
inStream != null?try {
									inStream.close();
								} catch (IOException e) {
									e.printStackTrace();
								}
containerToVerify != null?try {
						containerToVerify.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
jarFile == null?throw new SecurityException("JarFile or certificate are missing");
trustedCert == null?throw new SecurityException("JarFile or certificate are missing");
man == null?Log.i(TAG_SECURE_DEX_CLASS_LOADER, jarFile.getName() + "is not signed.");
certMatchingFiles != null?InputStream inStream = null;
inStream != null?try {
						inStream.close();
					} catch (IOException e) {
						e.printStackTrace();
					}
verifiedCertificate != null?try {
					verifiedCertificate.checkValidity();
					
					// Evaluate whether the certificate can be used for signature verification
					// keyCertSignIndex is a magic number from ASN.1 definition of Key Usage.
					if (verifiedCertificate.getKeyUsage() != null) {
						
						int keyCertSignIndex = 5;
						if(verifiedCertificate.getKeyUsage()[keyCertSignIndex])
							throw new CertificateExpiredException("This certificate should not be used for code verification!");
						
						Log.d(TAG_SECURE_DEX_CLASS_LOADER, verifiedCertificate.getKeyUsage().toString());
					}
					
					// Check whether the certificate used to verify is the one 
					// used by Android in Debug Mode. If so, discard this certificate
					// since it's not secure.
					String androidDebugModeDN = "C=US,O=Android,CN=Android Debug";
					X500Principal androidDebugModePrincipal = new X500Principal(androidDebugModeDN);
					if (	verifiedCertificate.getIssuerX500Principal().equals(androidDebugModePrincipal) ||
							verifiedCertificate.getSubjectX500Principal().equals(androidDebugModePrincipal)	)
						throw new CertificateExpiredException("Android Debug Certificate can't be accepted to sign containers!");
					
				} catch (CertificateExpiredException
						| CertificateNotYetValidException e) {
					// This certificate is not valid!
					// Discard it and erase the copy of 
					// the file on the device memory
					verifiedCertificate = null;
					String certFileToErase = certMatchingFiles[0].getName();
					if (certMatchingFiles[0].delete()) {
						Log.i(TAG_SECURE_DEX_CLASS_LOADER, "Expired certificate " + certFileToErase + " has been erased.");
					}else {
						Log.w(TAG_SECURE_DEX_CLASS_LOADER, "Problems while deleting expired certificate " + certFileToErase + "!");
					}
				}
verifiedCertificate.getKeyUsage() != null?int keyCertSignIndex = 5;

Null fields: 
	--> resDownloadFolder
	--> containerPath
	--> mPackageManager
	--> packageNameToCertificateMap
	--> mPackageNameTrie
	--> packageNameToContainerPathMap
	--> certificateFactory
	--> rootPackageNameWithCertificate
	--> lazyAlreadyVerifiedPackageNameSet
	--> mDexClassLoader
	--> successVerifiedContainerSet
	--> mFileDownloader

Null variables: 
In method getPackageNamesFromContainerPath found:
	--> containerJar
	--> dexFile
In method verifyAllContainersSignature found:
	--> verifiedCertificate
In method verifyContainerSignatureAgainstCertificate found:
	--> certFromSign
	--> inStream
	--> containerToVerify
In method importCertificateFromAppPrivateDir found:
	--> verifiedCertificate
	--> inStream
In method loadClass found:
	--> verifiedCertificate
Null assignments: 
In method importCertificateFromAppPrivateDir found: 
	--> verifiedCertificate
************ For file SecureLoaderFactory.java************

Null checks:
cachedContainerFileName != null?finalDexPath.append(importedContainerDir.getAbsolutePath() + File.separator + cachedContainerFileName + File.pathSeparator);
downloadedContainerPath != null?String containerDigest = computeDigestFromFilePath(downloadedContainerPath);
containerDigest == null?if (!downloadedContainer.delete())
								Log.w(TAG_SECURE_FACTORY, "Issue while deleting " + downloadedContainerPath);
encodedContainerDigest != null?int extensionIndex = path.lastIndexOf(".");
matchingContainerArray != null?finalDexPath.append(matchingContainerArray[0].getAbsolutePath() + File.pathSeparator);
inStream != null?inStream.close();
outStream != null?outStream.close();
mSecureDexClassLoader != null?mSecureDexClassLoader.setCertificateLocationMap(santiziedPackageNameToCertificateMap);
inStream != null?try {
					inStream.close();
				} catch (IOException e) {
					Log.w(TAG_SECURE_FACTORY, "Issue while closing file stream in message digest computation!");
				}
packageNameToCertificateMap == null?return null;
certificateURL != null?if (certificateURL.getProtocol().equals("http")) {
							// In this case enforce HTTPS protocol
							// santiziedPackageNameToCertificateMap.put(currentPackageName, new URL(certificateURL.toString().replace("http", "https")));
							santiziedPackageNameToCertificateMap.put(currentPackageName, new URL("https", certificateURL.getHost(), certificateURL.getPort(), certificateURL.getFile()));
						}
						else {
							if (!certificateURL.getProtocol().equals("https")) {
								// If the certificate URL protocol is different from HTTPS
								// or HTTP, this entry is not valid
								removeThisPackageName = true;
							}
						}
urlPath == null?return null;
resOutputDir == null?return null;
containerName == null?return null;
extension == null?extension = mFileDownloader.getDownloadedFileExtension();
extension != null?File containerToRename = new File(localContainerPath);

Null fields: 
	--> mFileDownloader
	--> mContextWrapper
	--> messageDigest

Null variables: 
In method downloadContainerIntoFolder found:
	--> extension
In method createDexClassLoader found:
	--> encodedContainerDigest
	--> inStream
	--> outStream
In method computeDigestFromFilePath found:
	--> inStream
	--> digestString
Null assignments: 

Diff of d304f7840afa80ad0202369f0dd9be526a67a5ba and bdf12a6ce486bc94a34879d97fdd3e019d2f7d0c:
	--> Added null checks = 102
	--> Removed null checks = 4
	--> Null dereferences checked for null = 67
Null checks found in initial commit -- added at creation of the repository.
****Analysis complete for first commit****
Luca Falsina added null count = 102 in repository Grab-n-Run
Luca Falsina removed null count = 4 in repository Grab-n-Run
Luca Falsina deref count = 67 in repository Grab-n-Run
GitAPIException thrown!
Cannot revert commit 'd304f7840afa80ad0202369f0dd9be526a67a5ba' because it has 0 parents, only commits with exactly one parent are supported
